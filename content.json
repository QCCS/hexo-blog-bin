{"meta":{"title":"qianchaochushui","subtitle":"subtitle","description":"weichat:qianchaochushui","author":"zhouli","url":"https://qccs.github.io","root":"/"},"pages":[{"title":"about","date":"2019-04-12T07:51:14.000Z","updated":"2019-04-13T06:44:46.010Z","comments":true,"path":"about/index.html","permalink":"https://qccs.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-12T07:51:14.000Z","updated":"2019-04-13T06:44:46.012Z","comments":true,"path":"tags/index.html","permalink":"https://qccs.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-12T07:51:14.000Z","updated":"2019-04-12T07:51:14.642Z","comments":true,"path":"categories/index.html","permalink":"https://qccs.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 语言精粹笔记2-继承、数组、正则表达式","slug":"z/2016-06-08-JavaScript-good-parts-note2","date":"2019-04-14T09:29:00.637Z","updated":"2019-04-14T09:29:00.638Z","comments":true,"path":"2019/04/14/z/2016-06-08-JavaScript-good-parts-note2/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-06-08-JavaScript-good-parts-note2/","excerpt":"content{:toc} 记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。","text":"content{:toc} 记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。 继承继承的两大好处：代码重用，引入一套类型系统的规范。 伪类JavaScript 通过构造器函数产生对象。 构造器调用模式，即用new前缀去调用一个函数。 1234567891011121314var Mammal = function(name) &#123; this.name = name&#125;Mammal.prototype.getName = function() &#123; return this.name&#125;Mammal.prototype.says = function() &#123; return this.saying || ''&#125;;var myMammal = new Mammal('Herb')console.log(myMammal.getName()) //Herb 书中不推荐这样的写法。有很多风险。若忘记添加new前缀，this无法绑定到新的对象上。而是绑定到了全局对象上，破坏了全局变量环境。 对象说明符上一节中的构造器可能要接受一大串参数。我们可以这样写： 1234567var myObject = Maker(&#123; first: f, middle: m, last: l, state: s, city: c&#125;) 将JSON对象传递给构造器，而它返回一个构造完全的对象。 原型在一个纯粹的原型模式中，我们将摒弃类，转而专注于对象。一个新对象可以继承一个就对象的属性。 12345678910111213141516171819var myMammal = &#123; name: 'MM', getName: function() &#123; return this.name &#125;, says: function() &#123; return this.saying || '' &#125;&#125;var myCat = Object.create(myMammal)myCat.name = 'Kitty'myCat.saying = 'meow'myCat.run = function() &#123; return 'Kitty is running'&#125;myCat.getName = function() &#123; return this.says + ' ' + this.name + ' ' + this.says&#125; 这是一种差异化继承。 函数化前文看到的继承模式没法保护隐私。对象的所有属性都是可见的。无法得到私有变量和私有函数。为了解决这一问题，我们有模块模式。 构造一个生成对象的函数需要4步骤： 创建一个新对象。 有选择的定义私有变量和方法。 给这个新对象扩充方法。 返回那个新对象。 1234567891011121314151617181920var mammal = function(spec) &#123; var that = &#123;&#125; that.getName = function() &#123; return spec.name &#125; that.says = function() &#123; return spec.saying || '' &#125; return that&#125;var myMammal = mammal(&#123; name: 'Herb', saying: 'Cheers!'&#125;)console.log(myMammal.getName()) //Herbconsole.log(myMammal.says()) //Cheers! 也可以参考上一篇文章，JavaScript 语言精粹笔记1-语法、对象、函数 之模块部分。 部件这一部分看的不是特别懂，我想等我学完ES2015中的类和模块部分后再看看吧。 数组数组字面量一个数组字面量是在一对方括号中包围零个或多个用逗号分隔的值的表达式。 再大多数语言中，一个数组的多有元素都要求是相同的类型。JavaScript 允许数组包含任意混合类型的值。 长度JavaScript 数组的length属性是没有上界的。如果用大于或等于当前length的数字作为下标来存储一个元素，那么length值会被增大以容纳新元素，不会发生数组越界错误。 删除数组也是对象，可以用delete来删除元素 12345var numbers = ['one', 'two', 3, 'four', 'wu']delete numbers[0]console.log(numbers[0]) //undefinedconsole.log(numbers.length) //5 可以使用splice方法，进行删除和修改操作。 123numbers.splice(0, 1)console.log(numbers[0]) //twoconsole.log(numbers.length) //4 枚举使用常规for循环即可，可以保证数组的顺序。 容易混淆的地方当属性名是小而连续的整数时，应该使用数组，否则使用对象。 1console.log(typeof [1, 2]) //object 返回数组的类型是object，没有任何意义。 判断数组类型的方法 1console.log(Array.isArray(numbers)) //true ECMAScript 5.1 (ECMA-262) 和 ECMAScript 2015 (6th Edition, ECMA-262) 标准中的方法。 或者下面这个方法。1234var is_array = function(value) &#123; return Object.prototype.toString.apply(value) === '[object Array]'&#125;console.log(is_array(numbers)) //true 方法数组的方法被存储在Array.prototype中的函数。 数组是对象，因此Array.prototype也是可扩充的。 指定初始值JavaScript 的数组不会预制值。 JavaScript 没有多维数组，单项大多数类 C 语言一样，支持元素为数组的数组。 123456var matrix = [ [7, 8, 9], [4, 5, 6], [1, 2, 3]]console.log(matrix[1][2]) //6 正则表达式关于正则表达式，以前的博文写的比较多了，详情见： 百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分1 百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分2 浅谈正则表达式中的分组和引用","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"继承 对象 原型 Array 正则","slug":"继承-对象-原型-Array-正则","permalink":"https://qccs.github.io/tags/继承-对象-原型-Array-正则/"}]},{"title":"JavaScript 语言精粹笔记1-语法、对象、函数","slug":"z/2016-06-07-JavaScript-good-parts-note1","date":"2019-04-14T09:29:00.627Z","updated":"2019-04-14T09:29:00.627Z","comments":true,"path":"2019/04/14/z/2016-06-07-JavaScript-good-parts-note1/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-06-07-JavaScript-good-parts-note1/","excerpt":"content{:toc} 记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。","text":"content{:toc} 记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。 原书中第一章为精华，做了一些周边介绍，略去。 语法空白这里说一下JavaScript的注释，一种是 /* */ 包围的块注释，另一种是 // 开头的行注释。 因为块注释的字符可能是JavaScript中正则表达式字面量，因此不是很安全，如： 123/* var rm_a = /a*/.match(s)*/ 标识符标识符由一个字母开头，后面可选择性的加上一个或多个字母、数字或下划线。要避免保留字。 标识符被用于语句、变量、参数、属性名、运算符和标记。 数字可以存在指数部分，100和1e2完全相等 1100 === 1e2 // true 使用isNaN来检测NaN。 字符串当年 JavaScript 被创建的时候，Unicode 是16位字符集，因此 JavaScript 字符串是16位的。 用双引号或单引号包裹。 重点说一下转义字符\\ 反斜杠后面可以跟&quot;, &#39;, \\, /, b (backspace), f (formfeed), n, r (carriage return), t, u1234 1'A' === '\\u0041' // true 语句每个&lt;script&gt;标签的内容被一起抛到一个公共的全局名字空间中。 {...}代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。 下列值当做假： false null undefined &#39;&#39; 0 NaN 其他所有值都当做真 for in语句枚举对象的所有属性名（键名），使用object.hasOwnProperty(variable)来确定这个属性名是该对象成员，还是来自原型链。 12345for (myvar in obj) &#123; if (obj.hasOwnProperty(myvar)) &#123; ... &#125;&#125; 表达式运算符优先级 运算符 说明 . [] () 提取属性与调用函数 delete new typeof + - ! 一元运算符 * / % + - &gt;= &lt;= &gt; &lt; === !== &amp;&amp; 逻辑与 ` ` 逻辑或 ?: 三目 字面量对象字面量是一种可以方便地按指定规格创建新对象的表示法。 数组字面量是一种可以方便地按指定规格创建新数组的表示法。 函数函数字面量定义了函数值。后续章节详谈。 对象对象是属性的容器，每一个属性都拥有名字和值。属性的名字可以是包含空字符串在内的任意字符串。属性的值可以是除undefined值之外的任何值。 JavaScript 包含一种原型链的特性，允许对象继承另一个对象的属性。正确地使用它能减少对象初始化时消耗的时间和内存。 对象字面量一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。 123456var empty_object = &#123;&#125;var stooge = &#123; firstName: 'Haoyang', lastName: 'Gao'&#125; 检索12console.log(stooge.firstName); // Haoyangconsole.log(stooge['firstName']); // Haoyang 不存在的属性返回undefined。 使用||来填充默认值。 12console.log(stooge.firstName || 'Joe'); // Haoyangconsole.log(stooge.age || 25); // 25 更新直接使用赋值语句更新，若不存在这个属性，则作为扩充操作。 123stooge.firstName = 'aaa'stooge.nickName = 'peip'console.log(stooge) //Object &#123;firstName: \"aaa\", lastName: \"Gao\", nickName: \"peip\"&#125; 引用对象通过引用来传递他们永远不会被复制。 123var x = stoogex.hair = 'black'stooge.hair //\"black\" 原型每一个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过字面量创建的对象都连接到Object.prototype，它是JavaScript中的标配对象。 可以使用Object.create()方法创建一个使用原对象作为其原型的新对象。 12345var anotherStooge = Object.create(stooge)anotherStooge.firstName //\"aaa\"anotherStooge.firstName = 'bbb'anotherStooge.firstName //\"bbb\"anotherStooge.hair //\"black\" 新对象先查找自己的属性，若不存在则会向原型方向查找。 当我们对某个对象作出改变时，不会触及该对象的原型。 原型关系是一种动态关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。 反射在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。 检查对象并确定对象有什么属性是很容易的事情，只要试着去检索该属性并验证取得的值。 typeof用来确定对象属性的类型。 hasOwnProperty，若对象拥有独有的属性，它将返回true。不会检查原型链。 枚举使用for in可以遍历一个对象中的所有属性名，包括原型链上的属性名。可以使用hasOwnProperty过滤原型链上的属性，使用typeof来排除函数。 123456for (var name in anotherStooge) &#123; if (anotherStooge.hasOwnProperty(name) &amp;&amp; typeof anotherStooge[name] !== 'function') &#123; console.log(name + '---&gt;' + anotherStooge[name]) &#125;&#125;// firstName---&gt;bbb 属性名是无序的，若想保持顺序应使用数组和for循环。 删除delete可以用来删除对象的属性。若对象包含该属性，则会被移除。它不会触及原型链中的任何对象。 123anotherStooge.firstName //\"bbb\"delete anotherStooge.firstNameanotherStooge.firstName //\"aaa\" 减少全局变量污染JavaScript 可以随意的定义全局变量来容纳应用的所有资源。但这会削弱程序的灵活性，应避免使用全局变量。 最小化使用全局变量的方法之一是为应用只创建一个唯一的全局变量。 123456789var MYAPP = &#123;&#125;MYAPP.stooge = &#123; //...&#125;MYAPP.flight = &#123; //...&#125; 下一章将使用闭包来进行信息隐藏，是另一种有效减少全局污染的方法。 函数函数对象JavaScript 中的函数就是对象。函数对象连接到Function.prototype（该原型对象本身连接到Object.prototype）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。 函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值即为该函数对象。 123function add(a, b) &#123; return a + b&#125; 因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。 函数的与众不同之处在于可以被调用。 函数字面量函数对象通过函数字面量来创建。 123var add = function(a, b) &#123; return a + b&#125; 函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。 调用调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：this和arguments。参数this在面向对象编程中非常重要，它的值取决于调用的模式。JavaScript中一共有4中调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。 实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为undefined。 下面的内容也可以参考我以前的博文 JavaScript 中的 this 方法调用模式当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。 123456789101112var myObject = &#123; value: 0, increment: function(inc) &#123; this.value += typeof inc === 'number' ? inc : 1 &#125;&#125;myObject.increment()console.log(myObject.value) //1myObject.increment(3)console.log(myObject.value) //4 函数调用模式当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。 此时this被绑定到全局对象。即时是内部函数也会将this绑定到全局对象。 可以在函数内创建一个属性并赋值为this来解决这个问题。如下： 1234567891011121314var add = function(a, b) &#123; return a + b&#125;myObject.double = function() &#123; var that = this var helper = function() &#123; that.value = add(that.value, that.value) &#125; helper()&#125;myObject.double()console.log(myObject.value) //8 构造器调用模式JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。 如果在一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。 1234567891011121314//创建构造器函数var Quo = function(string) &#123; this.status = string&#125;//给Que的所有实例提供一个公共方法Quo.prototype.getStatus = function() &#123; return this.status&#125;//实例化var myQuo = new Quo('confused')console.log(myQuo.getStatus()) //confused 书中不推荐这种形式的构造器函数，下一章有更好的解决方案。 Apply 调用模式apply方法让我们构建一个参数数组传递给调用函数。他也允许我们选择this的值。apply方法接受两个参数，第一个是要绑定给this的值，第二个是参数数组。 12345678910var arr = [3, 4]var sum = add.apply(null, arr)console.log(sum) //7var statusObject = &#123; status: 'hello'&#125;var status = Quo.prototype.getStatus.apply(statusObject)console.log(status) //hello 参数当函数被调用时，会得到一个arguments数组。通过此参数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。 12345678var sum = function() &#123; var i, sum = 0 for (i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; return sum&#125;console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)) //45 因语言的设计错误，arguments并不是一个真正的数组。是一个“类似数组”的对象。有length属性，但没有任何数组的方法。 返回函数执行时遇到关闭函数体的}时结束。然后把控制权交还给调用该函数的程序。 return可以使函数提前返回，不在执行余下的语句。 函数总是会返回一个值，若没有指定，则返回undefined。 若函数调用时在前面加上了new前缀，且返回值不是一个对象的时候，则返回this（该新对象）。 异常异常是干扰程序的正常流畅的不寻常的事故。 1234567891011var add2 = function(a, b) &#123; if (typeof a !== 'number' || typeof b !== 'number') &#123; throw &#123; name: 'TypeError', message: 'add needs numbers' &#125; &#125; return a + b&#125;console.log(add2(2, 3)) //5console.log(add2('a', 6)) throw语句中断函数的执行。抛出一个exception对象，该对象包含一个用来识别异常类型的name属性和一个描述性的message属性。也可以自定义其他属性。 12345678var try_it = function() &#123; try &#123; add2('a') &#125; catch (e) &#123; console.log(e.name + ': ' + e.message) &#125;&#125;try_it() //TypeError: add needs numbers 如果在try代码块内抛出一个异常，控制权就会跳转到它的catch语句中。 扩充类型的功能JavaScript 允许给语言的基本类型扩充功能。通过Object.prototype添加方法，可以让该方法对所有对象都适用。 1234567891011121314151617// 先添加方法使得该方法对所有函数可用Function.prototype.method = function(name, func) &#123; this.prototype[name] = func return this&#125;//添加一个取整方法Number.method('integer', function() &#123; return Math[this &lt; 0 ? 'ceil' : 'floor'](this)&#125;)console.log((-10 / 3).integer()) //-3//添加 trim()String.method('trim', function() &#123; return this.replace(/^\\s+|\\s+$/g, '')&#125;)console.log(' hello alibaba '.trim()) //hello alibaba JavaScript 原型继承是动态的，因此新的方法立刻被赋予到所有的对象实例上，即使对象实例是在方法被增加之前就创建好了。 递归递归函数就是会直接或者间接地调用自身的一种函数。 123456789101112131415161718192021222324var walkTheDom = function walk(node, func) &#123; func(node) node = node.firstChild while (node) &#123; walk(node, func) node = node.nextSibling &#125;&#125;var getElementsByAttribute = function(att, value) &#123; var results = [] walkTheDom(document.body, function(node) &#123; var actual = node.nodeType === 1 &amp;&amp; node.getAttribute(att) if (typeof actual === 'string' &amp;&amp; (actual === value || typeof value !== 'string')) &#123; results.push(node) &#125; &#125;) return results&#125;//在知乎主页上操作console.log(getElementsByAttribute('data-za-module', 'AnswerItem'))//得到下列数据//[div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content] 作用域作用域控制着变量与参数的可见性及生命周期。它减少了名称冲突，并提供了自动内存管理。 无块级作用域。 有函数作用域。 建议在函数体的顶部声明函数中可能用到的所有变量。 闭包作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了this和arguments）。 12345678910var quo = function(status) &#123; return &#123; get_status: function() &#123; return status &#125; &#125;&#125;var myQuo = quo('amazed')console.log(myQuo.get_status()) //amazed 狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。 避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前i值的函数，这样就不会导致混淆了。 回调将一个函数作为参数，一旦接收到响应，再调用这个函数。 模块可以用函数和闭包构造模块。 模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。 123456789101112131415161718192021var numberCal = (function() &#123; var half = function(n) &#123; return n / 2 &#125; var double = function(n) &#123; return n * 2 &#125; var tribble = function(n) &#123; return n * 3 &#125; return &#123; half: half, double: double, tribble: tribble &#125;&#125;())console.log(numberCal.half(5)) //2.5console.log(numberCal.half(6)) //3console.log(numberCal.double(7)) //14console.log(numberCal.tribble(7)) //21 级联如果让方法返回this而不是默认的undefined，就可以启用级联，即连续调用。 柯里化柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。 详情见以前的博文 JavaScript 函数 -bind 与 currying。 记忆函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"对象 函数 this 闭包 面向对象 作用域","slug":"对象-函数-this-闭包-面向对象-作用域","permalink":"https://qccs.github.io/tags/对象-函数-this-闭包-面向对象-作用域/"}]},{"title":"前端如何写一个精确的倒计时","slug":"z/2016-11-25-how-to-write-a-count-down","date":"2019-04-14T09:29:00.617Z","updated":"2019-04-14T09:29:00.617Z","comments":true,"path":"2019/04/14/z/2016-11-25-how-to-write-a-count-down/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-11-25-how-to-write-a-count-down/","excerpt":"content{:toc} 关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。","text":"content{:toc} 关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。 原理众所周知 setTimeout 或者 setInterval 调用的时候会有微小的误差。有人做了一个 demo 来观察这个现象并对其做了修正。短时间的误差倒也可以接受，但是作为一个长时间的倒计时，误差累计就会导致倒计时不准确。 因此我们可以在获取剩余时间的时候，每次 new 一个设备时间，因为设备时间的流逝相对是准确的，并且如果设备打开了网络时间同步，也会解决这个问题。 但是，如果用户修改了设备时间，那么整个倒计时就没有意义了，用户只要将设备时间修改为倒计时的 endTime 就可以轻易看到倒计时结束是页面的变化。因此一开始获取服务端时间就是很重要的。 简单的说，一个简单的精确倒计时原理如下： 初始化时请求一次服务器时间 serverTime，再 new 一个设备时间 deviceTime deviceTime 与 serverTime 的差作为时间偏移修正 每次递归时 new 一个系统时间，解决 setTimeout 不准确的问题 代码获取剩余时间的代码如下： 123456789101112131415161718192021/** * 获取剩余时间 * @param &#123;Number&#125; endTime 截止时间 * @param &#123;Number&#125; deviceTime 设备时间 * @param &#123;Number&#125; serverTime 服务端时间 * @return &#123;Object&#125; 剩余时间对象 */let getRemainTime = (endTime, deviceTime, serverTime) =&gt; &#123; let t = endTime - Date.parse(new Date()) - serverTime + deviceTime let seconds = Math.floor((t / 1000) % 60) let minutes = Math.floor((t / 1000 / 60) % 60) let hours = Math.floor((t / (1000 * 60 * 60)) % 24) let days = Math.floor(t / (1000 * 60 * 60 * 24)) return &#123; 'total': t, 'days': days, 'hours': hours, 'minutes': minutes, 'seconds': seconds &#125;&#125; 获取服务器时间可以使用 mtop 接口 mtop.common.getTimestamp 然后可以通过下面的方式来使用： 1234567891011121314151617181920// 获取服务端时间（获取服务端时间代码略）getServerTime((serverTime) =&gt; &#123; //设置定时器 let intervalTimer = setInterval(() =&gt; &#123; // 得到剩余时间 let remainTime = getRemainTime(endTime, deviceTime, serverTime) // 倒计时到两个小时内 if (remainTime.total &lt;= 7200000 &amp;&amp; remainTime.total &gt; 0) &#123; // do something //倒计时结束 &#125; else if (remainTime.total &lt;= 0) &#123; clearInterval(intervalTimer); // do something &#125; &#125;, 1000)&#125;) 这样的的写法也可以做到准确倒计时，同时也比较简洁。不需要隔段时间再去同步一次服务端时间。 补充在写倒计时的时候遇到了一个坑这里记录一下。 千万别在倒计时结束的时候请求接口。会让服务端瞬间 QPS 峰值达到非常高。 如果在倒计时结束的时候要使用新的数据渲染页面，正确的做法是： 在倒计时结束前的一段时间里，先请求好数据，倒计时结束后，再渲染页面。 关于倒计时，如果你有什么更好的解决方案，欢迎评论交流。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"countdown JavaScript","slug":"countdown-JavaScript","permalink":"https://qccs.github.io/tags/countdown-JavaScript/"}],"author":"HyG"},{"title":"如何使用 babel","slug":"z/2016-06-14-how-to-use-babel","date":"2019-04-14T09:29:00.613Z","updated":"2019-04-14T09:29:00.613Z","comments":true,"path":"2019/04/14/z/2016-06-14-how-to-use-babel/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-06-14-how-to-use-babel/","excerpt":"content{:toc} Babel 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。","text":"content{:toc} Babel 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。 学习 Babel 可以通过其手册 Babel handbook。 babel-handbook 其中包含多语言版本，分为用户手册和插件手册。这是一个很好的学习 Babel 的资料。 babel-cli在 node 和 npm 环境安装好的前提下，安装 babel，如下： 1npm install --global babel-cli 安装完成后就可以编译文件了。 1babel main.js 编译后的文件显示在终端上，可以添加其他命令让它输出到指定文件下： 123babel example.js --out-file compiled.js或babel example.js -o compiled.js 或将整个目录编译成一个新的目录： 123babel src --out-dir lib或babel src -d lib 但这很麻烦，并且并不是一个很好的解决方案，请看下一节项目内运行 babel-cli。 在项目内运行 babel-cli初始化项目 1npm init 再安装 babel-cli 1npm install --save-dev babel-cli 项目中的package.json应该包含如下内容： 1234567&#123; \"name\": \"learn-es6\", \"version\": \"1.0.0\", \"devDependencies\": &#123; \"babel-cli\": \"^6.10.1\" &#125;&#125; 添加 npm scripts 命令。 12345678910&#123; \"name\": \"learn-es6\", \"version\": \"1.0.0\",+ \"scripts\": &#123;+ \"build\": \"babel src -d lib\"+ &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.10.1\" &#125;&#125; 此时在终端里运行 1npm run build 还不能成功编译，因为没有配置.babelrc文件。 配置.babelrc通过配置.babelrc来告诉 babel 来做什么。 在项目的根路径下创建.babelrc文件。然后输入以下内容作为开始： 1234&#123; \"presets\": [], \"plugins\": []&#125; 为了让 babel 将 ES2015 转化为 ES5，我们要安装如下： 1npm install --save-dev babel-preset-es2015 安装完成后在.babelrc中添加参数： 123456&#123; \"presets\": [+ \"es2015\" ], \"plugins\": []&#125; 现在在项目src/main.js中写一些 ES2015 的代码试试吧。 1let a = 1 在终端中输入命令 1npm run build 执行后终端中显示： 12&gt; learn-es6@1.0.0 build c:\\gitWorkSpace\\learn-es6&gt; babel src -d lib 然后可以看到目录中出现了lib/main.js 123\"use strict\";var a = 1; 即编译成功。 配置.jshintrc若编辑器中安装了 jshint 语法检查的插件。默认对于 ES2015 的代码可能会报错或者警告，看着可能会不爽。我们可以在配置文件中将它设置为允许 ES2015 的模式。 在项目根目录下创建文件.jshintrc。内容如下： 1234&#123; \"asi\": true, \"esversion\": 2015&#125; 上述文件我分别设置了，使用无分号模式，es 版本使用 2015。 关于.jshintrc的更详细配置可以参见官方示例：https://github.com/jshint/jshint/blob/master/examples/.jshintrc 好，babel 就说到这里，下面开始进入真正的 ES2015 的学习！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"ES2015 ES6 ES5 babel","slug":"ES2015-ES6-ES5-babel","permalink":"https://qccs.github.io/tags/ES2015-ES6-ES5-babel/"}]},{"title":"提升用户体验的前端动画","slug":"z/2018-06-01-animation","date":"2019-04-14T09:29:00.610Z","updated":"2019-04-14T09:29:00.610Z","comments":true,"path":"2019/04/14/z/2018-06-01-animation/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2018-06-01-animation/","excerpt":"content{:toc} 与其他开发人员不同的是，前端开发都是在端上游走舞者，直接与用户交流沟通，这就需要前端开发\b具有更敏锐的交互体验思考，或者能更精准地理解设计师们意图，将最佳的用户体验带给用户。优质的交互体验对于用户来说学习成本应该是极低的，都是非常自然\b的操作，却可以让用户感到畅快愉悦，甚至惊喜。本文将通过一个看似简单的 poplayer 来分析我在这其中通过思考做的体验优化，获得类似 native 的体验感。","text":"content{:toc} 与其他开发人员不同的是，前端开发都是在端上游走舞者，直接与用户交流沟通，这就需要前端开发\b具有更敏锐的交互体验思考，或者能更精准地理解设计师们意图，将最佳的用户体验带给用户。优质的交互体验对于用户来说学习成本应该是极低的，都是非常自然\b的操作，却可以让用户感到畅快愉悦，甚至惊喜。本文将通过一个看似简单的 poplayer 来分析我在这其中通过思考做的体验优化，获得类似 native 的体验感。 关于 poplayer 是什么，详见 POPLAYER起来HIGH~~ 简单的说下需求，这个弹层希望可以像 native 在商品详情页的弹层一样，从下向上滑出，点击遮罩或按钮时关闭。为了给用户带来更好的体验，我在这个基础上又增加了一些手势和过渡的动画效果，如下图。下面简单的拆分一下动画细节： 页面载入，卡片向上滑入 增加 pan 的手势，卡片跟随手指滑动 随着手指滑动，增加遮罩透明度与卡片阴影变化 增加向上和向下的边界条件的处理 动画与手势的运用这些动画利用 CSS 3 的一些属性再加上手势操作即可完成，这里手势操作我选择了老牌的 HammerJS。 点击超级会员专享，折上95折 banner，卡片向上滑入 这里直接使用 transition 控制过渡。发生样式变化的有 3 个地方： 卡片位置，使用 transform: translateY 控制纵向位置 遮罩透明度，随着卡片上滑，背景遮罩由透明变为半透明 卡片的阴影，注意仔细观察，随着卡片的上滑，为了凸显出弹层是悬浮在底层的视觉效果，其阴影的 blur,spread,color 也跟随变重 下面再加入 pan 手势，即拖拽或平移，这里我们使用这个手势实现弹层的拖拽和相关动画。手指不离开屏幕进行滑动操作，如下图： 我们把最外层容器节点作为参数，实例化 hammer 对象，默认 pan 手势只有横向操作，这里设置为所有方向。在监听 pandown panup 时，根据手指移动的差值控制卡片位置、背景遮罩透明度、卡片阴影的样式。代码如下： 12345678910111213141516const hammer = new Hammer(containerEl)hammer.get('pan').set(&#123; direction: Hammer.DIRECTION_ALL &#125;)hammer.on('pandown panup', panDownUp)const panDownUp = (ev) =&gt; &#123; const opacity = 0.7 - ev.deltaY / 1024 coverEle.style.opacity = opacity const boxShadowBlur = 12 - ev.deltaY / 46 const boxShadowSpread = 3 - ev.deltaY / 180 const boxShadowColorAlpha = '' popWrapEle.style.boxShadow = `0 0 $&#123;boxShadowBlur&#125;px $&#123;boxShadowSpread&#125;px rgba(0,0,0,$&#123;opacity&#125;)` const scrollY = ev.deltaY * 1.2 popWrapEle.style.transform = `translateY($&#123;scrollY&#125;px)`&#125; 对于各个样式属性的值，通过乘系数等方式得到需要的值。 这里要注意，pan 的操作中是不需要原有的 transition 过渡的，因为滑动操作时，希望让动画非常跟手，而 transition 是一个消耗时间的过渡，而且多次触发 transition 也会导致性能问题，我们要在 panstart 将其移除，panend 再加回来，添加如下代码： 12345678hammer.on('panstart', () =&gt; &#123; popWrapEle.classList.remove('pop-wrap-transition') coverEle.classList.remove('cover-transition')&#125;)hammer.on('panend', (ev) =&gt; &#123; popWrapEle.classList.add('pop-wrap-transition') coverEle.classList.add('cover-transition')&#125;) 向下滑出的处理用户在向下滑动松手时的距离，如果大于某个值，让卡片滑出，关闭 poplayer，小于某个值，则回弹到原位。 这比较符合用户体验、防止误关闭，同时滑出的关闭方式也给了用户一种流畅感。经过本人多次测试，最终选择的下滑临界值为 180。效果如下图： 在 panend 事件中加入这个逻辑判断 12345678910hammer.on('panend', (ev) =&gt; &#123; if (ev.deltaY &gt; 180) &#123; closePoplayer() &#125; else &#123; popWrapEle.style.transform = 'translateY(0)' popWrapEle.style.boxShadow = '0 0 12px 3px rgba(0,0,0,.74)' coverEle.style.opacity = '0.7' &#125; // ...&#125;) 向上滑动的溢出感这个卡片本身是无法再向上滑动的，但是如果用户想继续滑呢？为了让这个弹层增添一些活力，我在这个操作中让卡片微微膨胀，增添亲和力，仿佛用户想滑动它，但是它又存在着一股粘滞力无法大距离的移动，甚至满足了用户心中的小小控制欲。 效果如下： 在向上滑动事件中加入如下代码： 12345678910const panDownUp = (ev) =&gt; &#123; if (ev.deltaY &lt; 0) &#123; console.log(ev.deltaY) const scrollUpY = ev.deltaY / 80 const scaleX = -ev.deltaY / 20000 + 1 popWrapEle.style.transform = `scale($&#123;scaleX&#125;) translateY($&#123;scrollUpY&#125;px)` return &#125; // ...&#125; 其他小坑webkit 前缀。ios 8 下部分 CSS 3 属性需要添加 -webkit- 前缀。参考flexbox布局的兼容性。 覆盖 status bar。iOS 11 起，需要在 meta 标签中添加 viewport-fit=cover，才能使得 webView 覆盖到顶部的 status bar，meta 标签最终可以写为： 1&lt;meta name=\"viewport\" content=\"viewport-fit=cover,width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\"&gt; 总结\b交互体验体现在各个细节之中，没有大而全的规则，但整体方向就是让用户在使用软件的时候感到更加的自然畅快。而动画只是交互体验中的一小部分。 我认为前端的本质，就是将最优质的用户体验带给用户，我也在为之不断努力，欢迎交流。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"动画 手势","slug":"动画-手势","permalink":"https://qccs.github.io/tags/动画-手势/"}],"author":"HyG"},{"title":"从设计师和开发的角度使用 lottie","slug":"z/2018-09-10-lottie","date":"2019-04-14T09:29:00.599Z","updated":"2019-04-14T09:29:00.600Z","comments":true,"path":"2019/04/14/z/2018-09-10-lottie/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2018-09-10-lottie/","excerpt":"content{:toc} 简介lottie 是一个可以轻易的给各种 native app 添加高质量动画的类库。可以在 iOS、Android 和 React Native 实时渲染 After Effects 动画，就像使用静态图片一样容易。上图即为 lottie 的 logo。 简单的说，lottie 动画制作的流程是，通过 Bodymovin 扩展将 AE 动画导出为 json 数据，然后再将这个 json 渲染在客户端或者 web 端。如下图：","text":"content{:toc} 简介lottie 是一个可以轻易的给各种 native app 添加高质量动画的类库。可以在 iOS、Android 和 React Native 实时渲染 After Effects 动画，就像使用静态图片一样容易。上图即为 lottie 的 logo。 简单的说，lottie 动画制作的流程是，通过 Bodymovin 扩展将 AE 动画导出为 json 数据，然后再将这个 json 渲染在客户端或者 web 端。如下图： 官网宣传了3个特性： 灵活使用AE的特性 随心所欲控制你的动画 很小的文件体积 个人认为 lottie 最大的优势就是可以将设计师设计的动图原原本本的在页面上展现出来，完美还原了动画的精细度，并且对动画拥有足够的控制能力。目前所有使用 gif 或 apng 的场景应该都可以使用 lottie，当然 lottie 不局限与此场景。 本文主要从设计师视角和开发者视角讲述 lottie-web 的原理和使用以及 lottie 在 weex/rax 中的使用。 Demo 设计师视角准备\b在\b AE 中为 lottie 创作动画，你需要\b以下准备 Adobe After Effects Bodymovin AE 插件 Lottiefiles preview app (集成了 lottie sdk 的 app) 安装 Bodymovin 插件的流程如下： 关闭 AE 安装 ZXP installer。 ZXP Installer 就是专门用来安装 Adobe 公司的软件产品的插件的工具。 下载最新的 bodymovin 扩展。https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp 打开 ZXP installer 并把 bodymovin 扩展拖拽进来 打开 AE，在菜单 Window &gt; Extensions 中，你会看到安装好的扩展 安装插件详见 http://airbnb.io/lottie/after-effects/bodymovin-installation.html 从 Sketch/SVG/Illustrator 到 Lottie 的工作流下面讲讲如何从 Sketch 开始，制作一个 lottie 动画文件。如果你使用 svg 图片，跳到步骤3。如果你使用 AI，跳到步骤4。需要准备好 Sketch，AI，AE，并安装好 \bBodymovin \b插件。下面开始： 在 sketch 中确保要导出的内容\b已经群组为一个 group 将这个 group 导出为 svg 在 AI 中打开 svg，并转存为 .ai 文件 将 .ai \b文件导入到 AE 中 \b在 AE 中创建组件，设置动画持续时间和帧率 将 ai 文件转为 shape layers。在组件中选中你的图层，菜单 Layer 中选择 Create shapes from vector layer 添加你想要的任何动画，这一部分是你主要工作的步骤 使用 Bodymovin 导出为 json菜单中选择 Window &gt; Extensions &gt; Bodymovin 测试动画。确保动画中没有不支持的特性，然后可以拖拽到 lottieFiles 中查看效果。当然也可以上传到 lottieFiles 里，然后使用 lottie preview app 扫码查看。这时你就可以将动画交付给开发同学啦！ 更多细节可查看官方文档 Sketch/SVG/Illustrator to Lottie workflow 注意事项&amp;优化建议*AE 特性大部分已经支持，具体可以查看 Supported Features（支持列表），设计师应该避免使用\b不支持 AE 的特性。 目前开看，支持较好的属性有： Shapes Fills Strokes Transforms Interpolation 不完全支持的属性分类有： Masks Mattes Merge Paths Layer Effects Text *设计过程中的优化建议和注意事项 \bGeneral tips &amp; guidelines 尽量保持简单小巧在相同的图层上复制相同的关键帧会增加额外的代码，只有在必要时才使用路径关键帧动画。 导出 1x 图 No expressions or effectsLottie \b还不支持 expressions 或 effects 菜单中的任何 effects Matte and mask 尺寸问题使用半透明遮罩会影响性能。如果必须使用遮罩，请覆盖最小的区域。 不支持 Blending modes 或 Luma mattes 不支持图层样式图层效果不支持drop shadow, color overlay 或 stroke 全屏动画，导出比最大屏幕宽度更宽一点的图像，在 Android 和 iOS 上可以分别裁切 开发者视角使用首先当然是看开发文档。这里我简单说说其中\b lottie-web 的使用。 可以通过 script 标签 1&lt;script src=\"https://cdnjs.com/libraries/bodymovin\" type=\"text/javascript\"&gt;&lt;/script&gt; 或 npm 包 lottie-web 引用 1npm i -S lottie-web 1import lottie from 'lottie-web' 调用 loadAnimation() 12345678const myLottie = lottie.loadAnimation(&#123; container: document.querySelector('.img-area'), renderer: 'svg', name: 'myLottieAnim', loop: true, autoplay: true, path: './assets/cycle_animation.json',&#125;) 参数/api/事件loadAnimation 的参数 名称 描述 container 用于渲染的容器，一般使用一个 div 即可 renderer 渲染器，可以选择 ‘svg’ / ‘canvas’ / ‘html’，个人测试发现 svg 效果和兼容性最好 name 动画名称，用于 reference loop 循环 autoplay 自动播放 path json 路径，页面会通过一个 http 请求获取 json animationData json 动画数据，与 path 互斥，建议使用 path，因为 animationData 会将数据打包进来，会使得 js bundle 过大 获取到 lottie 实例后，可以调用 api 控制动画，例如上述代码中可以使用 1myLottie.pause() 相关 api 名称 参数 描述 stop 无 停止动画 play 无 播放动画 pause 无 暂停 setSpeed Number 设置播放速度，1 表示1倍速度，0.5 表示 0.5倍速度 setDirection Number 正反向播放，1 表示 正向，-1 表示反向 goToAndStop Number, [Boolean] 跳到某一帧或某一秒停止，第二个参数 iFrame 为是否基于帧模式还是时间，默认为 false goToAndPlay Number, [Boolean] 跳到某一帧或某一秒开始，第二个参数 iFrame 为是否基于帧模式还是时间，默认为 false playSegments Array, [Boolean] 播放片段，参数1为数组，两个元素为开始帧和结束帧；参数2为，是否立即播放片段，还是等之前的动画播放完成 destroy 无 销毁 事件 onComplete onLoopComplete onEnterFrame onSegmentStart 也可以使用 addEventListener 监听以下事件 complete loopComplete enterFrame segmentStart config_ready (when initial config is done) data_ready (when all parts of the animation have been loaded) data_failed (when part of the animation can not be loaded) loaded_images (when all image loads have either succeeded or errored) DOMLoaded (when elements have been added to the DOM) destroy 具体也可以查看组件文档 优化建议\b 使用压缩混淆过的 js，毕竟目前 lottie-web 还是有点大，gzip 后大概 57k 尽量使用简单小巧的 json，其实也是需要在 AE 中做一些优化，这需要前端和设计一起配合完成，例如 避免使用很大的形状，但是用很小的 mask 切\b出来 太多的节点也会影响性能 weex/rax 中使用 lottieweex/rax 已经提供了 lottie 组件，由于是内部文档，暂不放链接。 api 支持没有 airbnb 官方完整，投入生产环境时还需要严格测试一下 vue-weex demo 使用@ali/rax-lottie 的 rax demo 如下 小结在我看来，追求更精细完美\b的动画体验一直是设计师和前端开发的使命。lottie 的出现可以替代传统的 gif，并且提供的 api 可以更好的控制动画。lottie 可能不适合用于过于复杂的大场景动画，但是局部的小动画，再适合不过了。 lottie 应该是一个发展趋势，甚至未来浏览器说不定就原生直接支持了这种 json 动画，设计和开发之间的壁垒也会越来越小。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"动画 CSS airbnb lottie JavaScript","slug":"动画-CSS-airbnb-lottie-JavaScript","permalink":"https://qccs.github.io/tags/动画-CSS-airbnb-lottie-JavaScript/"}],"author":"HyG"},{"title":"使用 JavaScript 创建并下载文件","slug":"z/2016-11-22-js-create-file-and-download","date":"2019-04-14T09:29:00.592Z","updated":"2019-04-14T09:29:00.593Z","comments":true,"path":"2019/04/14/z/2016-11-22-js-create-file-and-download/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-11-22-js-create-file-and-download/","excerpt":"content{:toc} 本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。 先上代码12345678910111213/** * 创建并下载文件 * @param &#123;String&#125; fileName 文件名 * @param &#123;String&#125; content 文件内容 */function createAndDownloadFile(fileName, content) &#123; var aTag = document.createElement('a'); var blob = new Blob([content]); aTag.download = fileName; aTag.href = URL.createObjectURL(blob); aTag.click(); URL.revokeObjectURL(blob);&#125; 很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。","text":"content{:toc} 本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。 先上代码12345678910111213/** * 创建并下载文件 * @param &#123;String&#125; fileName 文件名 * @param &#123;String&#125; content 文件内容 */function createAndDownloadFile(fileName, content) &#123; var aTag = document.createElement('a'); var blob = new Blob([content]); aTag.download = fileName; aTag.href = URL.createObjectURL(blob); aTag.click(); URL.revokeObjectURL(blob);&#125; 很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。 Blob 对象Blob 对象是一个字节序列。拥有 size 和 type 等属性。 拥有 2 个只读状态 OPEND 和 CLOSED。 Blob 对象属于 JavaScript Web APIs 中的 File API 规定的部分，可以参考 W3C 文档中的 The Blob Interface and Binary Data 再回来看看我们的代码里是这么写的，使用了 Blob 的构造函数： 1var blob = new Blob([content]); 使用方括号的原因是，其构造函数的参数为以下4中： ArrayBuffer [TypedArrays] elements. ArrayBufferView [TypedArrays] elements. Blob elements. DOMString [WebIDL] elements. 所谓 ArrayBuffer 是一种用于呈现通用、固定长度的二进制数据的类型。详情可以参考 ArrayBuffer -MDN 以及 ECMAScript2015 标准中的 ArrayBuffer。 Blob URLsBlob URLs 被创建或注销是使用 URL 对象上的方法。这个 URL 对象被挂在 Window (HTML) 对象下，或者 WorkerGlobalScope (Web Workers)对象下。 拥有以下静态方法 createObjectURL 和 revokeObjectURL，用于创建一个 blob 对象的 url 和注销这个 blob url。 详情可查看 关于创建和注销 Blob URL 的 W3C 标准文档 模拟 click1element.click(); 在 W3C 中很早就有这个规范，不需要写繁琐的模拟事件触发的代码。 参考 在浏览器端用JS创建和下载文件 -alloyteam","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"文件 下载 JavaScript","slug":"文件-下载-JavaScript","permalink":"https://qccs.github.io/tags/文件-下载-JavaScript/"}],"author":"HyG"},{"title":"JavaScript 语言精粹笔记3-方法、毒瘤等","slug":"z/2016-06-10-JavaScript-good-parts-note3","date":"2019-04-14T09:29:00.575Z","updated":"2019-04-14T09:29:00.575Z","comments":true,"path":"2019/04/14/z/2016-06-10-JavaScript-good-parts-note3/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-06-10-JavaScript-good-parts-note3/","excerpt":"content{:toc} 记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。","text":"content{:toc} 记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。 方法这一章主要介绍了一些方法集。这里写几个我不太熟悉的方法和要点吧。 array.join() 对于IE6/7，使用array.join()连接大量字符串的效率确实优于使用+元素运算符。但是目前主流的浏览器，包括IE8以后的版本，都对+元素运算符连接字符串做了特别优化，性能已经显著高于array.join()。 number.toExponential(fractionDigits) 把这个number转换成一个指数形式的字符串。 number.toFixed(fractionDigits) 将这个number转换成一个十进制形式的字符串。 毒瘤 注意全局变量的引入。 JavaScript 中 Unicode 是16位的。包含65536个字符（基本多文种平面 Basic Multilingual Plane）。剩下的百万字符中的每一个都可以用一对字符来表示。Unicode 把一对字符视为一个单一的字符，而 JavaScript 认为一对字符是两个不同的字符。 检测null的方式。 1234567console.log(typeof null) //objectmyValue === null //检测 nullif (myValue &amp;&amp; typeof myValue === 'object') &#123; // myValue 是一个对象或数组！&#125; parseInt 把字符串转化为整数的函数。它遇到非数字时会停止解析，所以parseInt(&#39;16&#39;)和parseInt(&#39;16ton&#39;)产生相同的结果。 如果该字符串第一个字符是0，那么该字符串会基于八进制而不是十进制来求职。在八进制中，8和9不是数字，所以parseInt(&#39;08&#39;)和parseInt(&#39;09&#39;)都产生0作为结果。但parseInt()可以接受基数，因此parseInt(&#39;08&#39;,10)结果为8，建议总是加上这个基数参数。 JavaScript 的对象永远不会是真的空对象，因为它们可以送原型链中取得成员属性。 糟粕 避免使用with语句。 避免使用eval语句。 continue可能会降低运算性能。 位运算符在 JavaScript 会非常慢。 Java 里，位运算符处理的是整数。JavaScript 没有整数类型，它只有双精度的浮点数，因此，位运算符把它们的数字运算数先转换为整数，执行运算，在转换回去。JavaScript 的执行环境一般接触不到硬件，所以非常慢。 避免使用包装对象。new Object和new Array等。 避免使用void。 本系列结束。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"函数 JavaScript","slug":"函数-JavaScript","permalink":"https://qccs.github.io/tags/函数-JavaScript/"}]},{"title":"Fisher–Yates shuffle 洗牌算法","slug":"z/2016-10-16-shuffle-algorithm","date":"2019-04-14T09:29:00.568Z","updated":"2019-04-14T09:29:00.568Z","comments":true,"path":"2019/04/14/z/2016-10-16-shuffle-algorithm/","link":"","permalink":"https://qccs.github.io/2019/04/14/z/2016-10-16-shuffle-algorithm/","excerpt":"content{:toc} 简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。 本文主要介绍这个算法的来源、演变、原理。并举出一个例子为大家清晰的描述每次迭代过程。最后使用 JavaScript 代码将算法实现。","text":"content{:toc} 简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。 本文主要介绍这个算法的来源、演变、原理。并举出一个例子为大家清晰的描述每次迭代过程。最后使用 JavaScript 代码将算法实现。 Fisher and Yates 的原始版 Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher（上图） 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下： 写下从 1 到 N 的数字 取一个从 1 到剩下的数字（包括这个数字）的随机数 k 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位 重复第 2 步，直到所有的数字都被取出 第 3 步写出的这个序列，现在就是原始数字的随机排列 已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。 现代方法Fisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。 现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后。这样就将时间复杂度从 O(n^2) 减小到了 O(n)。算法的伪代码如下： 1234-- To shuffle an array a of n elements (indices 0..n-1):for i from n−1 downto 1 do j ← random integer such that 0 ≤ j ≤ i exchange a[j] and a[i] 例子迭代步骤演示根据每次迭代次数可以用下面的表格，描述这个算法的执行过程 随机数取值范围 随机数 原始数据 结果 1 2 3 4 5 6 7 8 1-8 6 1 2 3 4 5 7 8 6 1-7 2 1 7 3 4 5 8 2 6 1–6 6 1 7 3 4 5 8 2 6 1–5 1 5 7 3 4 1 8 2 6 1–4 3 5 7 4 3 1 8 2 6 1–3 3 5 7 4 3 1 8 2 6 1–2 1 7 5 4 3 1 8 2 6 动画演示下面这个动画就是整个数组 0-19 的随机排序过程 See the Pen Fisher–Yates shuffle by Chuan shi (@haoyang) on CodePen. JavaScript 代码实现12345678910111213141516/** * Fisher–Yates shuffle */Array.prototype.shuffle = function() &#123; var input = this; for (var i = input.length-1; i &gt;=0; i--) &#123; var randomIndex = Math.floor(Math.random()*(i+1)); var itemAtIndex = input[randomIndex]; input[randomIndex] = input[i]; input[i] = itemAtIndex; &#125; return input;&#125; 使用方式也很简单，直接用数组调用这个方法即可 123[1,2,3,4,5,6,7,8].shuffle()//[4, 6, 3, 2, 5, 1, 7, 8] // 每次结果都是随机的 总结总之，Fisher–Yates shuffle 算法是一个非常高效又公平的随机排序算法，如果有随机排序数组的需求，用这个就对了！ 参考 Fisher–Yates shuffle From Wikipedia","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"算法 shuffle 乱序 洗牌","slug":"算法-shuffle-乱序-洗牌","permalink":"https://qccs.github.io/tags/算法-shuffle-乱序-洗牌/"}],"author":"HyG"},{"title":"","slug":"专题系列文章/JavaScript专题之jQuery通用遍历方法each的实现","date":"2019-04-14T09:21:22.761Z","updated":"2019-04-14T09:21:22.761Z","comments":true,"path":"2019/04/14/专题系列文章/JavaScript专题之jQuery通用遍历方法each的实现/","link":"","permalink":"https://qccs.github.io/2019/04/14/专题系列文章/JavaScript专题之jQuery通用遍历方法each的实现/","excerpt":"JavaScript专题之jQuery通用遍历方法each的实现each介绍jQuery 的 each 方法，作为一个通用遍历方法，可用于遍历对象和数组。 语法为： 1jQuery.each(object, [callback])","text":"JavaScript专题之jQuery通用遍历方法each的实现each介绍jQuery 的 each 方法，作为一个通用遍历方法，可用于遍历对象和数组。 语法为： 1jQuery.each(object, [callback]) 回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。 12345678// 遍历数组$.each( [0,1,2], function(i, n)&#123; console.log( \"Item #\" + i + \": \" + n );&#125;);// Item #0: 0// Item #1: 1// Item #2: 2 123456// 遍历对象$.each(&#123; name: \"John\", lang: \"JS\" &#125;, function(i, n) &#123; console.log(\"Name: \" + i + \", Value: \" + n);&#125;);// Name: name, Value: John// Name: lang, Value: JS 退出循环尽管 ES5 提供了 forEach 方法，但是 forEach 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。但是对于 jQuery 的 each 函数，如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。 12345678$.each( [0, 1, 2, 3, 4, 5], function(i, n)&#123; if (i &gt; 2) return false; console.log( \"Item #\" + i + \": \" + n );&#125;);// Item #0: 0// Item #1: 1// Item #2: 2 第一版那么我们该怎么实现这样一个 each 方法呢？ 首先，我们肯定要根据参数的类型进行判断，如果是数组，就调用 for 循环，如果是对象，就使用 for in 循环，有一个例外是类数组对象，对于类数组对象，我们依然可以使用 for 循环。 更多关于类数组对象的知识，我们可以查看《JavaScript专题之类数组对象与arguments》 那么又该如何判断类数组对象和数组呢？实际上，我们在《JavaScript专题之类型判断(下)》就讲过jQuery 数组和类数组对象判断函数 isArrayLike 的实现。 所以，我们可以轻松写出第一版： 1234567891011121314151617// 第一版function each(obj, callback) &#123; var length, i = 0; if ( isArrayLike(obj) ) &#123; length = obj.length; for ( ; i &lt; length; i++ ) &#123; callback(i, obj[i]) &#125; &#125; else &#123; for ( i in obj ) &#123; callback(i, obj[i]) &#125; &#125; return obj;&#125; 中止循环现在已经可以遍历对象和数组了，但是依然有一个效果没有实现，就是中止循环，按照 jQuery each 的实现，当回调函数返回 false 的时候，我们就中止循环。这个实现起来也很简单： 我们只用把： 1callback(i, obj[i]) 替换成： 123if (callback(i, obj[i]) === false) &#123; break;&#125; 轻松实现中止循环的功能。 this我们在实际的开发中，我们有时会在 callback 函数中用到 this，先举个不怎么恰当的例子： 12345678910// 我们给每个人添加一个 age 属性，age 的值为 18 + indexvar person = [ &#123;name: 'kevin'&#125;, &#123;name: 'daisy'&#125;]$.each(person, function(index, item)&#123; this.age = 18 + index;&#125;)console.log(person) 这个时候，我们就希望 this 能指向当前遍历的元素，然后给每个元素添加 age 属性。 指定 this，我们可以使用 call 或者 apply，其实也很简单： 我们把： 123if (callback(i, obj[i]) === false) &#123; break;&#125; 替换成： 123if (callback.call(obj[i], i, obj[i]) === false) &#123; break;&#125; 关于 this，我们再举个常用的例子： 123$.each($(\"p\"), function()&#123; $(this).hover(function()&#123; ... &#125;);&#125;) 虽然我们经常会这样写： 123$(\"p\").each(function()&#123; $(this).hover(function()&#123; ... &#125;);&#125;) 但是因为 $(“p”).each() 方法是定义在 jQuery 函数的 prototype 对象上面的，而 $.data()方法是定义 jQuery 函数上面的，调用的时候不从复杂的 jQuery 对象上调用，速度快得多。所以我们推荐使用第一种写法。 回到第一种写法上，就是因为将 this 指向了当前 DOM 元素，我们才能使用 $(this)将当前 DOM 元素包装成 jQuery 对象，优雅的使用 hover 方法。 所以最终的 each 源码为： 1234567891011121314151617181920function each(obj, callback) &#123; var length, i = 0; if (isArrayLike(obj)) &#123; length = obj.length; for (; i &lt; length; i++) &#123; if (callback.call(obj[i], i, obj[i]) === false) &#123; break; &#125; &#125; &#125; else &#123; for (i in obj) &#123; if (callback.call(obj[i], i, obj[i]) === false) &#123; break; &#125; &#125; &#125; return obj;&#125; 性能比较我们在性能上比较下 for 循环和 each 函数： 12345678910111213141516var arr = Array.from(&#123;length: 1000000&#125;, (v, i) =&gt; i);console.time('for')var i = 0;for (; i &lt; arr.length; i++) &#123; i += arr[i];&#125;console.timeEnd('for')console.time('each')var j = 0;$.each(arr, function(index, item)&#123; j += item;&#125;)console.timeEnd('each') 这里显示一次运算的结果： 从上图可以看出，for 循环的性能是明显好于 each 函数的，each 函数本质上也是用的 for 循环，到底是慢在了哪里呢？ 我们再看一个例子： 1234567891011121314151617181920212223242526272829303132function each(obj, callback) &#123; var i = 0; var length = obj.length for (; i &lt; length; i++) &#123; value = callback(i, obj[i]); &#125;&#125;function eachWithCall(obj, callback) &#123; var i = 0; var length = obj.length for (; i &lt; length; i++) &#123; value = callback.call(obj[i], i, obj[i]); &#125;&#125;var arr = Array.from(&#123;length: 1000000&#125;, (v, i) =&gt; i);console.time('each')var i = 0;each(arr, function(index, item)&#123; i += item;&#125;)console.timeEnd('each')console.time('eachWithCall')var j = 0;eachWithCall(arr, function(index, item)&#123; j += item;&#125;)console.timeEnd('eachWithCall') 这里显示一次运算的结果： each 函数和 eachWithCall 函数唯一的区别就是 eachWithCall 调用了 call，从结果我们可以推测出，call 会导致性能损失，但也正是 call 的存在，我们才能将 this 指向循环中当前的元素。 有舍有得吧。 或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2015-02-26-components-in-webapp","date":"2019-04-14T09:15:10.738Z","updated":"2019-04-14T09:15:10.743Z","comments":true,"path":"2019/04/14/杂谈/2015-02-26-components-in-webapp/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2015-02-26-components-in-webapp/","excerpt":"2015前端组件化框架之路1. 为什么组件化这么难做Web应用的组件化是一个很复杂的话题。 在大型软件中，组件化是一种共识，它一方面提高了开发效率，另一方面降低了维护成本。但是在Web前端这个领域，并没有很通用的组件模式，因为缺少一个大家都能认同的实现方式，所以很多框架/库都实现了自己的组件化方式。 前端圈最热衷于造轮子了，没有哪个别的领域能出现这么混乱而欣欣向荣的景象。这一方面说明前端领域的创造力很旺盛，另一方面却说明了基础设施是不完善的。","text":"2015前端组件化框架之路1. 为什么组件化这么难做Web应用的组件化是一个很复杂的话题。 在大型软件中，组件化是一种共识，它一方面提高了开发效率，另一方面降低了维护成本。但是在Web前端这个领域，并没有很通用的组件模式，因为缺少一个大家都能认同的实现方式，所以很多框架/库都实现了自己的组件化方式。 前端圈最热衷于造轮子了，没有哪个别的领域能出现这么混乱而欣欣向荣的景象。这一方面说明前端领域的创造力很旺盛，另一方面却说明了基础设施是不完善的。我曾经有过这么一个类比，说明某种编程技术及其生态发展的几个阶段： 最初的时候人们忙着补全各种API，代表着他们拥有的东西还很匮乏，需要在语言跟基础设施上继续完善 然后就开始各种模式，标志他们做的东西逐渐变大变复杂，需要更好的组织了 然后就是各类分层MVC，MVP，MVVM之类，可视化开发，自动化测试，团队协同系统等等，说明重视生产效率了，也就是所谓工程化 那么，对比这三个阶段，看看关注这三种东西的人数，觉得Web发展到哪一步了？ 细节来说，大概是模块化和组件化标准即将大规模落地（好坏先不论），各类API也大致齐备了，终于看到起飞的希望了，各种框架几年内会有非常强力的洗牌，如果不考虑老旧浏览器的拖累，这个洗牌过程将大大加速，然后才能释放Web前端的产能。 但是我们必须注意到，现在这些即将普及的标准，很多都会给之前的工作带来改变。用工业体系的发展史来对比，前端领域目前正处于蒸汽机发明之前，早期机械（比如《木兰辞》里面的机杼，主要是动力与材料比较原始）已经普及的这么一个阶段。 所以，从这个角度看，很多框架/库是会消亡的（专门做模块化的AMD和CMD相关库，专注于标准化DOM选择器铺垫的某些库），一些则必须进行革新，还有一些受的影响会比较小（数据可视化等相关方向），可以有机会沿着自己的方向继续演进。 2. 标准的变革对于这类东西来说，能获得广泛群众基础的关键在于：对将来的标准有怎样的迎合程度。对前端编程方式可能造成重大影响的标准有这些： module Web Components class observe promise module的问题很好理解，JavaScript第一次有了语言上的模块机制，而Web Components则是约定了基于泛HTML体系构建组件库的方式，class增强了编程体验，observe提供了数据和展现分离的一种优秀方式，promise则是目前前端最流行的异步编程方式。 这里面只有两个东西是绕不过去的，一是module，一是Web Components。前者是模块化基础，后者是组件化的基础。 module的标准化，主要影响的是一些AMD/CMD的加载和相关管理系统，从这个角度来看，正如seajs团队的@afc163 所说，不管是AMD还是CMD，都过时了。 模块化相对来说，迁移还比较容易，基本只是纯逻辑的包装，跟AMD或者CMD相比，包装形式有所变化，但组件化就是个比较棘手的问题了。 Web Components提供了一种组件化的推荐方式，具体来说，就是： 通过shadow DOM封装组件的内部结构 通过Custom Element对外提供组件的标签 通过Template Element定义组件的HTML模板 通过HTML imports控制组件的依赖加载 这几种东西，会对现有的各种前端框架/库产生很巨大的影响： 由于shadow DOM的出现，组件的内部实现隐藏性更好了，每个组件更加独立，但是这使得CSS变得很破碎，LESS和SASS这样的样式框架面临重大挑战。 因为组件的隔离，每个组件内部的DOM复杂度降低了，所以选择器大多数情况下可以限制在组件内部了，常规选择器的复杂度降低，这会导致人们对jQuery的依赖下降。 又因为组件的隔离性加强，致力于建立前端组件化开发方式的各种框架/库（除Polymer外），在自己的组件实现方式与标准Web Components的结合，组件之间数据模型的同步等问题上，都遇到了不同寻常的挑战。 HTML imports和新的组件封装方式的使用，会导致之前常用的以JavaScript为主体的各类组件定义方式处境尴尬，它们的依赖、加载，都面临了新的挑战，而由于全局作用域的弱化，请求的合并变得困难得多。 3. 当下最时髦的前端组件化框架/库在2015年初这个时间点看，前端领域有三个框架/库引领时尚，那就是Angular，Polymer，React（排名按照首字母），在知乎的这篇2014 年末有哪些比较火的 Web 开发技术？里，我大致回答过一些点，其他几位朋友的答案也很值得看。关于这三者的细节分析，侯振宇的这篇讲得很好：2015前端框架何去何从 我们可以看到，Polymer这个东西在这方面是有先天优势的，因为它的核心理念就是基于Web Components的，也就是说，它基本没有考虑如何解决当前的问题，直接以未来为发展方向了。 React的编程模式其实不必特别考虑Web标准，它的迁移成本并不算高，甚至由于其实现机制，屏蔽了UI层实现方式，所以大家能看到在native上的使用，canvas上的使用，这都是与基于DOM的编程方式大为不同的，所以对它来说，处理Web Components的兼容问题要在封装标签的时候解决，反正之前也是要封装。 Angular 1.x的版本，可以说是跟同时代的多数框架/库一样，对未来标准的兼容基本没有考虑，但是重新规划之后的2.0版本对此有了很多权衡，变成了激进变更，突然就变成一个未来的东西了。 这三个东西各有千秋，在可以预见的几年内将会鼎足三分，也许还会有新的框架出现，能不能比这几个流行就难说了。 此外，原Angular 2.0的成员Rob Eisenberg创建了自己的新一代框架aurelia，该框架将成为Angular 2.0强有力的竞争者。 4. 前端组件的复用性看过了已有的一些东西之后，我们可以大致来讨论一下前端组件化的一些理念。假设我们有了某种底层的组件机制，先不管它是浏览器原生的，或者是某种框架/库实现的约定，现在打算用它来做一个大型的Web应用，应该怎么做呢？ 所谓组件化，核心意义莫过于提取真正有复用价值的东西。那怎样的东西有复用价值呢？ 控件 基础逻辑功能 公共样式 稳定的业务逻辑 对于控件的可复用性，基本上是没有争议的，因为这是实实在在的通用功能，并且比较独立。 基础逻辑功能主要指的是一些与界面无关的东西，比如underscore这样的辅助库，或者一些校验等等纯逻辑功能。 公共样式的复用性也是比较容易认可的，因此也会有bootstrap，foundation，semantic这些东西的流行，不过它们也不是纯粹的样式库了，也带有一些小的逻辑封装。 最后一块，也就是业务逻辑。这一块的复用是存在很多争议的，一方面是，很多人不认同业务逻辑也需要组件化，另一方面，这块东西究竟怎样去组件化，也很需要思考。 除了上面列出的这些之外，还有大量的业务界面，这块东西很显然复用价值很低，基本不存在复用性，但仍然有很多方案中把它们“组件化”了，使得它们成为了“不具有复用性的组件”。为什么会出现这种情况呢？ 组件化的本质目的并不一定是要为了可复用，而是提升可维护性。这一点正如面向对象语言，Java要比C++纯粹，因为它不允许例外情况的出现，连main函数都必须写到某个类里，所以Java是纯面向对象语言，而C++不是。 在我们这种情况下，也可以把组件化分为：全组件化，局部组件化。怎么理解这两个东西的区别呢，有人问过js框架和库的区别是什么，一般来说，有某种较强约定的东西，称为框架，而约定比较松散的，称为库。框架很多都是有全组件化理念的，比如说，很多年前就出现的ExtJS，它是全组件化框架，而jQuery和它的插件体系，则是局部组件化。所以用ExtJS写东西，不管写什么都是差不多一样的写法，而用jQuery的时候，大部分地方是原始HTML，哪里需要有些不一样的东西，就只在那个地方调用插件做一下特殊化。 对于一个有一定规模的Web应用来说，把所有东西都“组件化”，在管理上会有较大的便利性。我举个例子，同样是编写代码，短代码明显比长代码的可读性更高，所以很多语言里会建议“一个方法一般不要超过多少行，一个类最好不要超过多少行”之类。在Web前端这个体系里，JavaScript这块是做得相对较好的，现在入门水平的人，也已经很少会有把一堆js都写在一起的了。CSS这块，最近在SASS，LESS等框架的引领下，也逐步往模块化方面发展，否则直接编写bootstrap那种css，会非常痛苦。 这个时候我们再看HTML的部分，如果不考虑模板等技术的使用，某些界面光布局代码写起来就非常多了，像一些表单，都需要一层套一层，很多简单的表单元素都需要套个三层左右，更不必说一些有复杂布局的东西了。尤其是整个系统单页化之后，界面的header，footer，各种nav或者aside，很可能都有一定复杂性。如果这些东西的代码不作切分，那么主界面的HTML一定比较难看。 我们先不管用什么方式切分了，比如用某种模板，用类似Angular中的include，或者Polymer，React中的标签，或者直接使用原生Web Components，总之是把一块一块都拆开了，然后包含进来。从这个角度看，这些拆出去的东西都像组件，但如果从复用性的角度看，很可能多数东西，每一块都只有一个地方用，压根没有复用度。这个拆出去，纯粹是为了使得整个工程易于管理，易于维护。 这时候我们再来关注不同框架/库对UI层组件化的处理方式，发现有两个类型，模板和函数。 模板是一种很常见的东西，它用HTML字符串的方式表达界面的原始结构，然后通过代入数据的方式生成真正的界面，有的是生成目标HTML，有的还生成各种事件的自动绑定。前者是静态模板，后者是动态模板。 另外有一些框架/库偏爱用函数逻辑来生成界面，早期的ExtJS，现在的React（它内部还是可能使用模板，而且对外提供的是组件创建接口的进一步封装——jsx）等，这种实现技术的优势是不同平台上编程体验一致，甚至可以给每种平台封装相同的组件，调用方轻松写一份代码，在Web和不同Native平台上可用。但这种方式也有比较麻烦的地方，那就是界面调整比较繁琐。 本文前面部分引用侯振宇的那篇文章里，他提出这些问题： 如何能把组件变得更易重用? 具体一点: 我在用某个组件时需要重新调整一下组件里面元素的顺序怎么办? 我想要去掉组件里面某一个元素怎么办?如何把组件变得更易扩展? 具体一点: 业务方不断要求给组件加功能怎么办? 为此，还提出了“模板复写”方案，在这一点上我有不同意见。 我们来看看如何把一个业务界面切割成组件。 有这么一个简单场景：一个雇员列表界面包括两个部分，雇员表格和用于填写雇员信息的表单。在这个场景下，存在哪些组件？ 对于这个问题，主要存在两种倾向，一种是仅仅把“控件”和比较有通用性的东西封装成组件，另外一种是整个应用都组件化。 对前一种方式来说，这里面只存在数据表格这么一个组件。对后一种方式来说，这里面有可能存在：数据表格，雇员表单，甚至还包括雇员列表界面这么一个更大的组件。 这两种方式，就是我们之前所说的“局部组件化”，“全组件化”。 我们前面提到，全组件化在管理上是存在优势的，它可以把不同层面的东西都搞成类似结构，比如刚才的这个业务场景，很可能最后写起来是这个样子： 1234&lt;Employee-Panel&gt; &lt;Employee-List&gt;&lt;/Employee-List&gt; &lt;Employee-Form&gt;&lt;/Employee-Form&gt;&lt;/Employee-Panel&gt; 对于UI层，最好的组件化方式是标签化，比如上面代码中就是三个标签表达了整个界面。但我个人坚决反对滥用标签，并不是把各种东西都尽量封装就一定好。 全标签化的问题主要有这些： 第一，语义化代价太大。只要用了标签，就一定需要给它合适的语义，也就是命名。但实际用的时候，很可能只是为了把一堆html简化一下而已，到底简化出来的那东西应当叫什么名字，光是起名也费不知多少脑细胞。比如你说雇员管理的表单，这个表单有heading吗，有footer吗，能折叠吗，等等，很难起一个让别人一看就知道的名字，要么就是特别长。这还算简单的，因为我们是全组件化，所以很可能会有组合了多种东西的一个较复杂的界面，你想来想去也没法给它起个名字，于是写了个： 12&lt;Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right&gt;&lt;/Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right&gt; 这尼玛……可能我夸张了点，但很多时候项目规模够大，你不起这么复杂的名字，最后很可能没法跟功能类似的一个组件区分开，因为这些该死的组件都存在于同一个命名空间中。如果仅仅是当作一个界面片段来include，就不存在这种心理负担了。 比如Angular里面的这种： 1&lt;div ng-include=\"'aaa/bbb/ccc.html'\"&gt;&lt;/div&gt; 就不给它什么名字，直接include进来，用文件路径来区分。这个片段的作用可以用其目录结构描述，也就是通过物理名而非逻辑名来标识，目录层次充当了一个很好的命名空间。 现在的一些主流MVVM框架，比如knockout，angular，avalon，vue等等，都有一种“界面模板”，但这种模板并不仅仅是模板，而是可以视为一种配置文件。某一块界面模板描述了自身与数据模型的关系，当它被解析之后，按照其中的各种设置，与数据建立关联，并且反过来再更新自身所对应的视图。 不含业务逻辑的UI（或者是业务逻辑已分离的UI）基本不适合作为组件来看待，因为即使在逻辑不变的情况下，界面改版的可能性也太多了。比如即使是换了新的CSS实现方式，从float布局改成flex布局，都有可能把DOM结构少套几层div，因此，在使用模板的方案中，只能把界面层视为配置文件，不能看成组件，如果这么做，就会轻松很多。 部队行军的时候讲究“逢山开路，遇水搭桥”，这句话的重点在于只有到某些地形才开路搭桥，使用MVVM这类模式解决的业务场景，多数时候是一马平川，横着走都可以，不必硬要造路。所以从整个方案看的话，UI层实现应该是模板与控件并存，大部分地方是模板，少数地方是需要单独花时间搞的路和桥。 第二，配置过于复杂。有很多东西其实不太适合封装，不但封装的代价大，使用的代价也会很大。有时候会发现，调用代码的绝大部分都是在写各种配置。 就像刚才的雇员表单，既然你不从标签的命名上去区分，那一定会在组件上加配置。比如你原来想这样： 1&lt;EmployeeForm heading=\"雇员表单\"&gt;&lt;/EmployeeForm&gt; 然后在组件内部，判断有没有设置heading，如果没有就不显示，如果有，就显示。过了两天，产品问能不能把heading里面的某几个字加粗或者换色，然后码农开始允许这个heading属性传入html。没多久之后，你会惊奇地发现有人用你的组件，没跟你说，就在heading里面传入了折叠按钮的html，并且用选择器给折叠按钮加了事件，点一下之后还能折叠这个表单了…… 然后你一想，这个不行，我得给他再加个配置，让他能很简单地控制折叠按钮的显示，但是现在这么写太不直观，于是采用对象结构的配置： 1234567&lt;EmployeeForm&gt; &lt;Option collapsible=\"true\"&gt; &lt;Heading&gt; &lt;h4&gt;&lt;strong&gt;雇员&lt;/strong&gt;表单&lt;/h4&gt; &lt;/Heading&gt; &lt;/Option&gt;&lt;/EmployeeForm&gt; 然后又有一天，发现有很多面板都可以折叠，然后特意创建了一个可折叠面板组件，又创建了一种继承机制，其他普通业务面板从它继承，从此一发不可收拾。 我举这例子的意思是为了说明什么呢，我想说，在规模较大的项目中，企图用全标签化加配置的方式来描述所有的普通业务界面，是一定事倍功半的，并且这个规模越大就越坑，这也正是ExtJS这类对UI层封装过度的体系存在的最大问题。 这个问题讨论完了，我们来看看另外一个问题：如果UI组件有业务逻辑，应该如何处理。 比如说，性别选择的下拉框，它是一个非常通用化的功能，照理说是很适合被当做组件来提供的。但是究竟如何封装它，我们就有些犯难了。这个组件里除了界面，还有数据，这些数据应当内置在组件里吗？理论上从组件的封装性来说，是都应当在里面的，于是就这么造了一个组件： 1&lt;GenderSelect&gt;&lt;/GenderSelect&gt; 这个组件非常美好，只需直接放在任意的界面中，就能显示带有性别数据的下拉框了。性别的数据很自然地是放在组件的实现内部，一个写死的数组中。这个太简单了，我们改一下，改成商品销售的国家下拉框。 表面上看，这个没什么区别，但我们有个要求，本公司商品销售的国家的信息是统一配置的，也就是说，这个数据来源于服务端。这时候，你是不是想把一个http请求封装到这组件里？ 这样做也不是不可以，但存在至少两个问题： 如果这类组件在同一个界面中出现多次，就可能存在请求的浪费，因为有一个组件实例就会产生一个请求。 如果国家信息的配置界面与这个组件同时存在，当我们在配置界面中新增一个国家了，下拉框组件中的数据并不会实时刷新。 第一个问题只是资源的浪费，第二个就是数据的不一致了。曾经在很多系统中，大家都是手动刷新当前页面来解决这问题的，但到了这个时代，人们都是追求体验的，在一个全组件化的解决方案中，不应再出现此类问题。 如何解决这样的问题呢？那就是引入一层Store的概念，每个组件不直接去到服务端请求数据，而是到对应的前端数据缓存中去获取数据，让这个缓存自己去跟服务端保持同步。 所以，在实际做方案的过程中，不管是基于Angular，React，Polymer，最后肯定都做出一层Store了，不然会有很多问题。 5. 为什么MVVM是一种很好的选择我们回顾一下刚才那个下拉框的组件，发现存在几个问题： 界面不好调整。刚才的那个例子相对简单，如果我们是一个省市县三级联动的组件，就比较麻烦了。比如说，我们想要把水平布局改成垂直的，又或者，想要把中间的label的字改改，都会非常麻烦。按照传统的做组件的方式，就要加若干配置项，然后组件里面去分别判断，修改DOM结构。 如果数据的来源不是静态json，而是某个动态的服务接口，那用起来就很麻烦。 我们更多地需要业务逻辑的复用和纯“控件”的复用，至于那些绑定业务的界面组件，复用性其实很弱。 所以，从这些角度，会尽量期望在HTML界面层与JavaScript业务逻辑之间，存在一种分离。 这时候，再看看绝大多数界面组件存在什么问题： 有时候我们考虑一下DOM操作的类型，会发现其实是很容易枚举的： 创建并插入节点 移除节点 节点的交换 属性的设置 多数界面组件封装的绝大部分内容不过是这些东西的重复。这些东西，其实是可以通过某些配置描述出来的，比如说，某个数组以什么形式渲染成一个select或者无序列表之类，当数组变动，这些东西也跟着变动，这些都应当被自动处理，如果某个方案在现在这个时代还手动操作这些，那真的是一种落伍。 所以我们可以看到，以Angular，Knockout，Vue，Avalon为代表的框架们在这方面做了很多事，尽管理念有所差异，但大方向都非常一致，也就是把大多数命令式的DOM操作过程简化为一些配置。 有了这种方式之后，我们可以追求不同层级的复用： 业务模型因为是纯逻辑，所以非常容易复用 视图模型基本上也是纯逻辑，界面层多数是纯字符串模板，同一个视图模型搭配不同的界面模板，可以实现视图模型的复用 同一个界面模板与不同的视图模型组合，也能直接组合出完全不同的东西 所以这么一来，我们的复用粒度就非常灵活了。正因为这样，我一直认为Angular这样的框架战略方向是很正确的，虽然有很多战术失误。我们在很多场景下，都是需要这样的高效生产手段的。 6. 组件的长期积累我们做组件化这件事，一定是一种长期打算，为了使得当前的很多东西可以作为一种积累，在将来还能继续使用，或者仅仅作较小的修改就能使用，所以必须考虑对未来标准的兼容。主要需要考虑的方面有这几点： 尽可能中立于语言和框架，使用浏览器的原生特性 逻辑层的模块化（ECMAScript module） 界面层的元素化（Web Components） 之前有很多人对Angular 2.0的激进变更很不认同，但它的变更很大程度上是对标准的全面迎合。这不仅仅是它的问题，其实是所有前端框架的问题。不面对这些问题，不管现在多么好，将来都是死路一条。这个问题的根源是，这几个已有的规范约束了模块化和元素化的推荐方式，并且，如果要对当前和未来两边做适配的话，基本就没法干了，导致以前的都不得不做一定的迁移。 模块化的迁移成本还比较小，无论是之前AMD还是CMD的，都可以根据一些规则转换过来，但组件化的迁移成本太大了，几乎每种框架都会提出自己的理念，然后有不同的组件化理念。 还是从三个典型的东西来说：Polymer，React，Angular。 Polymer中的组件化，其实就是标签化。这里的标签，并不只是界面元素，甚至逻辑组件也可以这样，比如这个代码： 123&lt;my-panel&gt; &lt;core-ajax id=\"ajax\" url=\"http://url\" params=\"&#123;&#123;formdata&#125;&#125;\" method=\"post\"&gt;&lt;/core-ajax&gt;&lt;/my-panel&gt; 注意到这里的core-ajax标签，很明显这已经是纯逻辑的了，在大多数前端框架或者库中，调用ajax肯定不是这样的，但在浏览器端这么干也不是它独创，比如flash里面的WebService，比如早期IE中基于htc实现的webservice.htc等等，都是这么干的。在Polymer中，这类东西称为非可见元素（non-visual-element）。 React的组件化，跟Polymer略有不同，它的界面部分是标签化，但如果有单纯的逻辑，还是纯JavaScript模块。 既然大家的实现方式都那么不一致，那我们怎么搞出尽量可复用的组件呢？问题到最后还是要绕到Web Components上。 在Web Components与前端组件化框架的关系上，我觉得是这么个样子： 各种前端组件化框架应当尽可能以Web Components为基石，它致力于组织这些Components与数据模型之间的关系，而不去关注某个具体Component的内部实现，比如说，一个列表组件，它究竟内部使用什么实现，组件化框架其实是不必关心的，它只应当关注这个组件的数据存取接口。 然后，这些组件化框架再去根据自己的理念，进一步对这些标准Web Components进行封装。换句话说，业务开发人员使用某个组件的时候，他是应当感知不到这个组件内部究竟使用了Web Components，还是直接使用传统方式。（这一点有些理想化，可能并不是那么容易做到，因为我们还要管理像import之类的事情）。 7. 我们需要关注什么目前来看，前端框架/库仍然处于混战期，可比中国历史上的春秋战国，百家齐放，作为跟随者来说，这是很痛苦的，因为无所适从，很可能你作为一个企业的前端架构师或者技术经理，需要做一些选型工作，但选哪个能保证几年后不被淘汰呢？基本没有。 虽然我们不知道将来什么框架会流行，但我们可以从一些细节方面去关注，某个具体的方面，将来会有什么，也可以了解一下在某个具体领域存在什么样的方案。一个完整的框架方案，无非是以下多个方面的综合。 7.1 模块化这块还是不讲了，支付宝seajs还有百度ecomfe这两个团队的人应该都能比我讲得好得多。 7.2 Web Components本文前面讨论过一些，也不深入了。 7.3 变更检测我们知道，现代框架的一个特点是自动化，也就是把原有的一些手动操作提取。在前端编程中，最常见的代码是在干什么呢？读写数据和操作DOM。不少现代的框架/库都对这方面作了处理，比如说通过某种配置的方式，由框架自动添加一些关联，当数据变更的时候，把DOM进行相应修改，又比如，当DOM发生变动的时候，也更新对应的数据。 这个关联过程可能会用到几种技术。首先我们看怎么知道数据在变化，这里面有三种途径： 一、存取器的封装。这个的意思也就是对数据进行一层包装，比如： 123456789var data = &#123; name: \"aaa\", getName: function() &#123; return this.name; &#125;, setName: function(value) &#123; this.name = value; &#125;&#125; 这样，不允许用户直接调用data.name，而是调用对应的两个函数。Backbone就是通过这样的机制实现数据变动观测的，这种方式适用于几乎所有浏览器，缺点就是比较麻烦，要对每个数据进行包装。 这个机制在稍微新一点的浏览器中，也有另外一种实现方式，那就是defineProperty相关的一些方法，使用更优雅的存取器，这样外界可以不用调用函数，而是直接用data.name这样进行属性的读写。 国产框架avalon使用了这个机制，低版本IE中没有defineProperty，但在低版本IE中不止有JavaScript，还存在VBScript，那里面有存取器，所以他巧妙地使用了VBS做了这么一个兼容封装。 基于存取器的机制还有个麻烦，就是每次动态添加属性，都必须再添加对应的存取器，否则这个属性的变更就无法获取。 二、脏检测。 以Angular 1.x为代表的框架使用了脏检测来获知数据变更，这个机制的大致原理是： 保存数据的新旧值，每当有一些DOM或者网络、定时器之类的事件产生，用这个事件之后的数据去跟之前保存的数据进行比对，如果相同，就不触发界面刷新，否则就刷新。 这个方式的理念是，控制所有可能导致数据变更的来源（也就是各种事件），在他们可能对数据进行操作之后，判断新旧数据是否有变化，忽略所有中间变更，也就是说，如果你在同一个事件中，把某个数据任意修改了很多次，但最后改回来了，框架会认为你什么都没干，也就不会通知界面去刷新了。 不可否认的是，脏检测的效率是比较低的，主要是不能精确获知数据变更的影响，所以当数据量更大的情况下，浪费更严重，需要手动作一些优化。比如说一个很大的数组，生成了一个界面上的列表，当某个项选中的时候，改变颜色。在这种机制下，每次改变这个项的数据状态，就需要把所有的项都跟原来比较一遍，然后，还要再全部比较一次发现没有关联引起的变化了，才能对应刷新界面。 三、观察机制。 在ES7里面，引入了Object的observe方法，可以用于监控对象或数组的变动。 这是目前为止最合理的观测方案。这个机制很精确高效，比如说，连长跟士兵说，你去观察对面那个碉堡里面的动静。这个含义很复杂，包括什么呢？ 是不是加人了 是不是有人离开了 谁跟谁换岗了 上面的旗子从太阳旗换成青天白日了 所谓观察机制，也就是观测对象属性的变更，数组元素的新增，移除，位置变更等等。我们先思考一下界面和数据的绑定，这本来就应当是一个外部的观察，你是数据，我是界面，你点头我微笑，你伸手我打人。这种绑定本来就应当是个松散关系，不应当因为要绑定，需要破坏原有的一些东西，所以很明显更合理。 除了数据的变动可以被观察，DOM也是可以的。但是目前绝大多数双向同步框架都是通过事件的方式把DOM变更同步到数据上。比如说，某个文本框绑定了一个对象的属性，那很可能，框架内部是监控了这个文本框的键盘输入、粘贴等相关事件，然后取值去往对象里写。 这么做可以解决大部分问题，但是如果你直接myInput.value=”111”，这个变更就没法获取了。这个不算大问题，因为在一个双向绑定框架中，一个既被监控，又手工赋值的东西，本身也比较怪，不过也有一些框架会尝试从HTMLInputELement的原型上去覆盖value赋值，尝试把这种东西也纳入框架管辖范围。 另外一个问题，那就是我们只考虑了特定元素的特定属性，可以通过事件获取变更，如何获得更广泛意义上的DOM变更？比如说，一般属性的变更，或者甚至子节点的增删？ DOM4引入了MutationObserver，用于实现这种变更的观测。在DOM和数据之间，是否需要这么复杂的观测与同步机制，目前尚无定论，但在整个前端开发逐步自动化的大趋势下，这也是一种值得尝试的东西。 复杂的关联监控容易导致预期之外的结果： 慕容复要复国，每天读书练武，各种谋划 王语嫣观察到了这种现象，认为表哥不爱自己了 段誉看到神仙姐姐闷闷不乐，每天也茶饭不思 镇南王妃心疼爱子，到处调查这件事的原委，意外发现段正淳还跟旧爱有联系 …… 总之这么下来，最后影响到哪里了都不知道，谁让丘处机路过牛家村呢？ 所以，变更的关联监控是很复杂的一个体系，尤其是其中产生了闭环的时候。搭建整个这么一套东西，需要极其精密的设计，否则熟悉整套机制的人只要用特定场景轻轻一推就倒了。灵智上人虽然武功过人，接连碰到欧阳锋，周伯通，黄药师，全部都是上来就直接被抓了后颈要害，大致就是这意思。 polymer实现了一个observe-js，用于观测数组、对象和路径的变更，有兴趣的可以关注。 在有些框架，比如aurelia中，是混合使用了存取器和观察模式，把存取器作为观察模式的降级方案，在浏览器不支持observe的情况下使用。值得一提的是，在脏检测方式中，变更是合并后批量提交的，这一点常常被另外两种方案的使用者忽视。其实，即使用另外两种方式，也还是需要一个合并与批量提交过程。 怎么理解这个事情呢？数据的绑定，最终都是要体现到界面上的，对于界面来说，其实只关注你每一次操作所带来的数据变更的始终，并不需要关心中间过程。比如说，你写了这么一个循环，放在某个按钮的点击中： 123for (var i=0; i&lt;10000; i++) &#123; obj.a += 1;&#125; 界面有一个东西绑定到这个a，对框架来说，绝对不应当把中间过程直接应用到界面上，以刚才这个例子来说，合理的情况只应当存在一次对界面DOM的赋值，这个值就是对obj.a进行了10000次赋值之后的值。尽管用存取器或者观察模式，发现了对obj上a属性的这10000次赋值过程，这些赋值还是都必须被舍弃，否则就是很可怕的浪费。 React使用虚拟DOM来减少中间的DOM操作浪费，本质跟这个是一样的，界面只应当响应逻辑变更的结束状态，不应当响应中间状态。这样，如果有一个ul，其中的li绑定到一个1000元素的数组，当首次把这个数组绑定到这个ul上的时候，框架内部也是可以优化成一次DOM写入的，类似之前常用的那种DocumentFragment，或者是innerHTML一次写入整个字符串。在这个方面，所有优化良好的框架，内部实现机制都应当类似，在这种方案下，是否使用虚拟DOM，对性能的影响都是很小的。 7.4 Immutable DataImmutable Data是函数式编程中的一个概念，在前端组件化框架中能起到一些很独特的作用。 它的大致理念是，任何一种赋值，都应当被转化成复制，不存在指向同一个地方的引用。比如说： 12345var a = 1;var b = a;b = 2;console.log(a==b); 这个我们都知道，b跟a的内存地址是不一致的，简单类型的赋值会进行复制，所以a跟b不相等。但是： 1234567var a = &#123; counter : 1&#125;;var b = a;b.counter++;console.log(a.counter==b.counter); 这时候因为a和b指向相同的内存地址，所以只要修改了b的counter，a里面的counter也会跟着变。 Immutable Data的理念是，我能不能在这种赋值情况下，直接把原来的a完全复制一份给b，然后以后大家各自变各自的，互相不影响。光凭这么一句话，看不出它的用处，看例子： 对于全组件化的体系，不可避免会出现很多嵌套的组件。嵌套组件是一个很棘手的问题，在很多时候，是不太好处理的。嵌套组件所存在的问题主要在于生命周期的管理和数据的共享，很多已有方案的上下级组件之间都是存在数据共享的，但如果内外层存在共享数据，那么就会破坏组件的独立性，比如下面的一个列表控件： 12345&lt;my-list list-data=\"&#123;arr&#125;\"&gt; &lt;my-listitem&gt;&lt;/my-listitem&gt; &lt;my-listitem&gt;&lt;/my-listitem&gt; &lt;my-listitem&gt;&lt;/my-listitem&gt;&lt;/my-list&gt; 我们在赋值的时候，一般是在外层整体赋值一个类似数组的数据，而不是自己挨个在每个列表项上赋值，不然就很麻烦。但是如果内外层持有相同的引用，对组件的封装性很不利。 比如在刚才这个例子里，假设数据源如下： 12345var arr = [ &#123;name: \"Item1\"&#125;, &#123;name: \"Item2\"&#125;, &#123;name: \"Item3\"&#125;]; 通过类似这样的方式赋值给界面组件，并且由它在内部给每个子组件分别进行数据项的赋值： 1list.data = arr; 赋值之后会有怎样的结果呢？ 1234console.log(list.data == arr);console.log(listitem0.data == arr[0]);console.log(listitem1.data == arr[1]);console.log(listitem2.data == arr[2]); 这种方案里面，后面那几个log输出的结果都会是true，意思就是内层组件与外层共享数据，一旦内层组件对数据进行改变，外层中的也就改变了，这明显是违背组件的封装性的。 所以，有一些方案会引入Immutable Data的概念。在这些方案里，内外层组件的数据是不共享的，它们的引用不同，每个组件实际上是持有了自己的数据，然后引入了自动的赋值机制。 这时候再看看刚才那个例子，就会发现两层的职责很清晰： 外层持有一个类似数组的东西arr，用于形成整个列表，但并不关注每条记录的细节 内层持有某条记录，用于渲染列表项的界面 在整个列表的形成过程中，list组件根据arr的数据长度，实例化若干个listitem，并且把arr中的各条数据赋值给对应的listitem，而这个赋值，就是immutable data起作用的地方，其实是把这条数据复制了一份给里面，而不是把外层这条记录的引用赋值进去。内层组件发现自己的数据改变之后，就去进行对应的渲染 如果arr的条数变更了，外层监控这个数据，并且根据变更类型，添加或者删除某个列表项 如果从外界改变了arr中某一条记录的内容，外层组件并不直接处理，而是给对应的内层进行了一次赋值 如果列表项中的某个操作，改变了自身的值，它首先是把自己持有的数据进行改变，然后，再通过immutable data把数据往外同步一份，这样，外层组件中的数据也就更新了。 所以我们再看这个过程，真是非常清晰明了，而且内外层各司其职，互不干涉。这是非常有利于我们打造一个全组件化的大型Web应用的。各级组件之间存在比较松散的联系，而每个组件的内部则是封闭的，这正是我们所需要的结果。 说到这里，需要再提一个容易混淆的东西，比如下面这个例子： 123&lt;outer-component&gt; &lt;inner-component&gt;&lt;/inner-component&gt;&lt;/outer-component&gt; 如果我们为了给inner-component做一些样式定位之类的事情，很可能在内外层组件之间再加一些额外的布局元素，比如变成这样： 12345&lt;outer-component&gt; &lt;div&gt; &lt;inner-component&gt;&lt;/inner-component&gt; &lt;/div&gt;&lt;/outer-component&gt; 这里中间多了一级div，也可能是若干级元素。如果有用过Angular 1.x的，可能会知道，假如这里面硬造一级作用域，搞个ng-if之类，就可能存在多级作用域的赋值问题。在上面这个例子里，如果在最外层赋值，数据就会是outer -&gt; div -&gt; inner这样，那么，从框架设计的角度，这两次赋值都应当是immutable的吗？ 不是，第一次赋值是非immutable，第二次才需要是，immutable赋值应当仅存在于组件边界上，在组件内部不是特别有必要使用。刚才的例子里，依附于div的那层变量应当还是跟outer组件在同一层面，都属于outer组件的人民内部矛盾。 这里是facebook实现的immutable-js库 7.5 Promise与异步前端一般都习惯于用事件的方式处理异步，但很多时候纯逻辑的“串行化”场景下，这种方式会让逻辑很难阅读。在新的ES规范里，也有yield为代表的各种原生异步处理方案，但是这些方案仍然有很大的理解障碍，流行度有限，很大程度上会一直停留在基础较好的开发人员手中。尤其是在浏览器端，它的受众应该会比node里面还要狭窄。 前端里面，处理连续异步消息的最能被广泛接受的方案是promise，我这里并不讨论它的原理，也不讨论它在业务中的使用，而是要提一下它在组件化框架内部所能起到的作用。 现在已经没有哪个前端组件化框架可以不考虑异步加载问题了，因为，在前端这个领域，加载就是一个绕不过去的坎，必须有了加载，才能有执行过程。每个组件化框架都不能阻止自己的使用者规模膨胀，因此也应当在框架层面提出解决方案。 我们可能会动态配置路由，也可能在动态加载的路由中又引入新的组件，如何控制这些东西的生命周期，值得仔细斟酌，如果在框架层面全异步化，对于编程体验的一致性是有好处的。将各类接口都promise化，能够在可维护性和可扩展性上提供较多便利。 我们之前可能熟知XMLHTTP这样的通信接口，这个东西虽然被广为使用，但是在优雅性等方面，存在一些问题，所以最近出来了替代方案，那就是fetch。 细节可以参见月影翻译的这篇【翻译】这个API很“迷人”——(新的Fetch API) 在不支持的浏览器上，也有github实现的一个polyfill，虽然不全，但可以凑合用window.fetch polyfill 大家可以看到，fetch的接口就是基于promise的，这应当是前端开发人员最容易接受的方案了。 7.6 Isomorphic JavaScript这个东西的意思是前后端同构的JavaScript，也就是说，比如一块界面，可以选择在前端渲染，也可以选择在后端渲染，值得关注，可以解决像seo之类的问题，但现在还不能处理很复杂的状况，持续关注吧。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-10-01-From HTC to Web Components","date":"2019-04-14T09:15:10.731Z","updated":"2019-04-14T09:15:10.732Z","comments":true,"path":"2019/04/14/杂谈/2014-10-01-From HTC to Web Components/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2014-10-01-From HTC to Web Components/","excerpt":"从HTML Components的衰落看Web Components的危机搞前端时间比较长的同学都会知道一个东西，那就是HTC（HTML Components），这个东西名字很现在流行的Web Components很像，但却是不同的两个东西，它们的思路有很多相似点，但是前者已是昨日黄花，后者方兴未艾，是什么造成了它们的这种差距呢？ HTML Components的一些特性因为主流浏览器里面只有IE支持过HTC，所以很多人潜意识都认为它不标准，但其实它也是有标准文档的，而且到现在还有链接，注意它的时间！ http://www.w3.org/TR/NOTE-HTMLComponents 我们来看看它主要能做什么呢？ 它可以以两种方式被引入到HTML页面中，一种是作为“行为”被附加到元素，使用CSS引入，一种是作为“组件”，扩展HTML的标签体系。","text":"从HTML Components的衰落看Web Components的危机搞前端时间比较长的同学都会知道一个东西，那就是HTC（HTML Components），这个东西名字很现在流行的Web Components很像，但却是不同的两个东西，它们的思路有很多相似点，但是前者已是昨日黄花，后者方兴未艾，是什么造成了它们的这种差距呢？ HTML Components的一些特性因为主流浏览器里面只有IE支持过HTC，所以很多人潜意识都认为它不标准，但其实它也是有标准文档的，而且到现在还有链接，注意它的时间！ http://www.w3.org/TR/NOTE-HTMLComponents 我们来看看它主要能做什么呢？ 它可以以两种方式被引入到HTML页面中，一种是作为“行为”被附加到元素，使用CSS引入，一种是作为“组件”，扩展HTML的标签体系。 行为行为（Behavior）是在IE5中引入的一个概念，主要是为了做文档结构和行为的分离，把行为通过类似样式的方式隔离出去，详细介绍在这里可以看： http://msdn.microsoft.com/en-us/library/ms531079(v=vs.85).aspx.aspx) 行为里可以引入HTC文件，刚才的HTC规范里就有，我们把它摘录出来，能看得清楚一些： engine.htc12345678910111213&lt;HTML xmlns:PUBLIC=\"urn:HTMLComponent\"&gt;&lt;PUBLIC:EVENT NAME=\"onResultChange\" ID=\"eventOnResultChange\" /&gt;&lt;SCRIPT LANGUAGE=\"JScript\"&gt;function doCalc()&#123; : oEvent = createEventObject(); oEvent.result = sResult; eventOnResultChange.fire (oEvent);&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;HTML xmlns:LK=\"urn:com.microsoft.htc.samples.calc\"&gt;&lt;HEAD&gt;&lt;STYLE&gt; LK\\:CALC &#123; behavior:url(engine.htc); &#125; &lt;/STYLE&gt;&lt;/HEAD&gt;&lt;LK:CALC ID=\"myCalc\" onResultChange=\"resultWindow.innerText=window.event.result\"&gt;&lt;TABLE&gt;&lt;TR&gt;&lt;DIV ID=\"resultWindow\" STYLE=\"border: '.025cm solid gray'\" ALIGN=RIGHT&gt;0.&lt;/DIV&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 7 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 8 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 9 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" / \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" C \"&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 4 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 5 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 6 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" * \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" % \" DISABLED&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 1 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 2 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 3 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" - \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\"1/x\" DISABLED&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" 0 \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\"+/-\"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" . \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" + \"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=\" = \"&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/LK:CALC&gt;&lt;/HTML&gt; 这是一个计算器的例子，我们先大致看一下代码结构，是不是很清晰？再看看现在用jQuery，我们是怎么实现这种东西的：是用选择器选择这些按钮，然后添加事件处理函数。注意你多了一步选择的过程，而且，整个过程混杂了声明式和命令式两种代码风格。如果按照它这样，你所有的JS基本都丢在了隔离的不相关的文件中，整个是一个配置的过程，分离得很干净。 除了这种计算器，还有规范文档中举例的改变界面展示，或者添加动画之类，注意它们的切入点，都是相当于附加在特定选中元素上的行为，即使DOM不给JS暴露任何选择器，也毫无影响，因为它们直接就通过CSS的选择器挂到元素上了。 这种在现在看来，意义不算明显，现在广为使用的先选择元素再添加事件，也是不错的展现和行为分离方式。 但另外一种使用方式就不同了。 组件狭义的HTML5给我们带来了什么？是很多新增的元素标签，比如section，nav，acticle，那这些东西跟原先直接用div实现的，好处在哪里呢？在于语义化。 所谓语义化，就是一个元素能清晰表达自己是干什么的，不会让人有歧义，像div那种，可以类比成是一个Object，它不具体表示什么东西，但可以当成各种东西来用。而nav一写，就知道，它是导航，它就像有class定义的一个实体类，能表达具体含义。 那么，原有的HTML元素显然是不够的，因为实际开发过程中要表达的东西显然远远超出这些元素，比如日历，这种东西就没有一个元素用来描述它，更不用说在一些企业应用中可能会出现的树之类复杂控件了。 不提供原生元素，对开发造成的困扰是代码写起来麻烦，具体可以看之前我在知乎的一个回复，第三点： http://www.zhihu.com/question/22426434/answer/21433867 所以，大家都想办法去提供自己的扩充元素的方式，现在我们是知道典型的有angularjs，polymer，但很早的时候也不是没有啊： http://msdn.microsoft.com/en-us/library/ms531076(v=vs.85).aspx.aspx) 看，这就是HTC的添加自定义元素的方式，每个元素可以定义自己对外提供的属性、方法，还有事件，自己内部可以像写一个新页面一样，专注于实现功能。而且你发现没有，它考虑得很长远，提供了命名空间，防止你在一个页面引入两个不同组织提供的同名自定义元素。 这个东西就可以称为组件了，它跟外界是完全隔离的，外界只要把它拿来就可以用，就像用原生元素一样，用选择器选择，设置属性，调用方法，添加事件处理等等，而且，注意到没有，它的属性是带get和set的，这是多么梦寐以求的东西！ 正是因为它这么好用，所以在那个时代，我们用它干了很多东西，封装了各种基础控件，比如树，数据表格，日期选择，等等，甚至当时也有人嫌弃浏览器原生select和radio不好看，用这么个东西，里面封装了图片来模拟功能，替换原生的来用。 当时也有人，比如我在04年就想过，能不能把这些扩大化，扩展到除了基础控件之外的地方，把业务的组件也这么搞一下，一切皆组件，多好？ 但有些事情我直到后来很久以后才想明白，基于业务的端到端组件虽然写起来很方便，却是有致命缺陷的。 到这里为止，对HTML Components的回顾告一段落，也不讨论它为什么就没了之类，这里面争议太大，我只想谈谈从这里面，能看到Web Components这么个大家寄予厚望的新标准需要面对一些什么问题。 Web Components的挑战以下逐条列出，挨个说明，有的已经有了，有的差一些，有的没有，不管这么多，总之谈谈我心目中的这个东西应当是怎样的。 自定义元素标签支持命名空间原因我前面已经说了，可能会有不同组织实现同类功能的组件，存在于同一个页面内，引起命名歧义，所以我想了很久，还是觉得有前缀比较好： 12&lt;yours:ComponentA&gt;&lt;/yours:ComponentA&gt;&lt;his:ComponentA&gt;&lt;/his:ComponentA&gt; 甚至，这里的前缀还可以是个简称别名，比如yours=com.aaa.productA，这可能只有复杂到一定程度才会出现，大家不要以为这太夸张，但总有一天Web体系能构建超大型软件，到那时候你就知道是不是可能了。 样式的局部作用域这个前一段时间有的浏览器实现过，在组件内部，style上加一个scoped属性，这是正确的方向。为什么要这么干呢，所谓组件，引入成本越小越好，在无约定的情况下都能引入，不造成问题，那是最佳的结果。 如果你一个组件的样式不是局部的，很可能就跟主界面的冲突了，就算你不跟主界面的冲突，怎么保证不跟主界面中包含的其他组件的样式冲突？靠命名约定是不现实的，看长远一些，等你的系统够大，这就是大问题了。 跟主文档的通讯一个自定义组件，应当能够跟主文档进行通讯，这个过程包括两个方向，分别可以有多种不同的方式。 从内向外除了事件，真没有什么好办法可以做这个方向的通讯，但事件也可以有两种定义方式，一种是类似onclick那种，主文档应当能够在它上面直接添加对应的事件监听函数，就像对原生元素那样，每个事件都能单独使用。另一种是像postMessage那样，只提供一个通道，具体怎么处理，自己去定义消息格式和处理方式。 这两种实现方式都可行，后者比较偷懒，但也够用了，前者也没有明显优势。 从外向内这个也可以有两种方式，一种是组件对外暴露属性或者方法，让主文档调用，一种是外部也通过postMessage往里传。前者用起来会比较方便，后者也能凑合用用。 所以，如果特别偷懒，这个组件就变得像一个iframe那样，跟外部基本都通过postMessage交互。 JavaScript写到这里我是很纠结的，因为终于来到争议最大的地方了。按照很多人的思路，我这里应该也写隔离成局部作用域的JavaScript才对，但真不行，我们可以先假设组件内部的所有JavaScript都跑在局部作用域，它不能访问主文档中的对象。 我这里解释一下之前那个坑，为什么端到端组件是有缺陷的。 先解释什么叫端到端组件。比如说，我有这么一个组件，它封装了对后端某接口的调用，还有自身的一些展示处理，跟外界通过事件通信。它整个是不需要依赖别人的，初始加载数据都是自己内部做，别人要用它也很简单，直接拿来放在页面里就可以了。 照理说，这东西应当非常好才对，使用起来这么方便，到底哪里不对？我来举个场景。 在页面上同时存在这个组件的多个实例，每个组件都去加载了初始数据，假设它们是不带参数的，每个组件加载的数据都一样，这里是不是就有浪费的请求了？有人可能觉得一点点浪费不算问题，那么继续。 假设这个组件就是一个很普通的下拉列表，用于选取人员的职业，初始可能有医生，教师，警察等等，我把这个组件直接放在界面上，它一出现，就自己去加载了所需的列表信息并且展示了。有另外一个配置界面，用于配置这些职业信息，这时候我在里面添加了一个护士，并且提交了。假设为了数据一致性，我们把这个变更推回到页面，麻烦就出现了。 界面只有一个职业下拉列表的时候可能还好办，有多个的时候，这个更新的策略就有问题了。 如果在组件的内部做这个推送的对接，就会出现要推送多份一致的数据给组件的不同实例的问题。如果把这个放在外面，那我们也有两种方式： 订阅发布模式，组件订阅某个数据源，数据源跟服务端对接，当数据变更的时候，发给每个订阅者 观察者模式，组件观察某个数据源，当数据变更的时候，去取回来 这两种很类似，不管哪种，都面临一个问题： 数据源放在哪？ 很明显不能放在组件内部了，只能放在某个“全局”的地方，但刚才我们假设的是，组件内部的JavaScript代码不能访问外界的对象，所以…… 但要是让它能访问，组件的隔离机制等于白搭。最好的方式，也许是两种都支持，默认是局部作用域，另外专门有一个作用域放给JS框架之类的东西用，但浏览器实现的难度可能就大了不少。 可能有人会说，你怎么把问题搞这么复杂，用这么BT的场景来给我们美好的未来出难题。我觉得问题总是要面对的，能在做出来之前就面对问题，结果应该会好一些。 我注意观察了很多朋友对Web Components的态度，大部分都是完全叫好，但其中有一部分，主要是搞前端MV*的同学对它的态度很保守，主要原因应该是我说的这几点。因为这个群体主要都在做单页型的应用，这个里面会遇到的问题是跟传统前端不同的。 那么，比如Angular，或者React，它们跟Web Components的协作点在哪里呢？我个人觉得是把引擎保留下来，上层部分逐步跟Web Components融合，所以它们不是谁吃掉谁的问题，而是怎样去融合。最终就是在前端有两层，一层是数据和业务逻辑层，一层是偏UI的，在那个层里面，可以存在像Web Components那样的垂直切分，这样会很适宜。 最后说说自己对Polymer的意见，我的看法没有@司徒正美 那么粗暴，但我是认同他的观点的，因为Polymer的根本理念就是在做端到端组件，它会面临很多的挑战。虽然它是一个组件化框架，组件化最适宜于解决大规模协作问题，但是如果是以走向大型单页应用这条路来看，它比Angular和React离目标的距离还远很多。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-10-04-to-be-a-fe","date":"2019-04-14T09:15:10.725Z","updated":"2019-04-14T09:15:10.726Z","comments":true,"path":"2019/04/14/杂谈/2014-10-04-to-be-a-fe/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2014-10-04-to-be-a-fe/","excerpt":"给一位打算从事前端，但是又有疑惑的在校大学生的回信抱歉这么晚才回复这个邮件，主要是觉得你的问题有典型性，想要详细一点给出答复。 所谓的前端，在不同的公司，定义是不同的，工作内容也会有差异，有的还很大。比如有很多公司，没有专门的前端分类，所有的都属于开发人员，一些比较传统的公司，还有一些人数较少的小公司会是这样。又比如有些公司，前端人员的职责仅限于静态页面和交互效果，然后把这些东西交给业务开发人员去编写业务的JS代码。还有一些公司，前端除了PC和移动端的Web，还包括各种移动终端的开发。","text":"给一位打算从事前端，但是又有疑惑的在校大学生的回信抱歉这么晚才回复这个邮件，主要是觉得你的问题有典型性，想要详细一点给出答复。 所谓的前端，在不同的公司，定义是不同的，工作内容也会有差异，有的还很大。比如有很多公司，没有专门的前端分类，所有的都属于开发人员，一些比较传统的公司，还有一些人数较少的小公司会是这样。又比如有些公司，前端人员的职责仅限于静态页面和交互效果，然后把这些东西交给业务开发人员去编写业务的JS代码。还有一些公司，前端除了PC和移动端的Web，还包括各种移动终端的开发。这些种种不同，都是各公司自身的业务特点决定的，大体上比较适合各自的业务场景，越大的公司，内部的分工可能越明确，所以也就有了你看到的，有比较偏向JS的，有比较偏向CSS的。 个人选择什么方向，我觉得需要问自己两个问题： 你是一个怎样的人 这个的意思是，你觉得自己学js和css的时候，哪种觉得更轻松愉快，容易领悟。一个人选择自己最容易领悟的方面去学习，会事半功倍。 你希望成为一个怎样的人 人的一生，实际上很大程度是职业细分的过程，每个人在他工作的前10年，都可能会逐步深入到某些领域，他的知识广度可能会逐步增加，但能够深入的，往往在一两个分支上。 从大的方面看，最初的软件体系基本都是以服务端为主，客户端通过字符界面去进行操作，后来桌面程序迅速发展，再后来Web兴起，最近各种终端的流行，更加促使广义的“前端”这个领域有更多的发挥空间。整体来说，后端的发展趋势是服务化，前端的发展趋势是多样化。因为消费者的促进，前端的需求和发展会是非常乐观的，无论在其中选择哪个细分方向，只要努力下去，成为这个领域的专家，肯定都会有所成就。 目前，在很多公司，搞CSS一般还没有独立职位，或者即使有，暂时比搞JS的还是稍微弱势一些，正如前端部门一般比后端部门弱势，但这种状况会好转的，每个领域都会得到适合自己的发挥。 关于原生JS和某些库的学习，我的观点是这样，除了一些很特别很怪异的点，对于语言本身的常规用法是需要都掌握的，其实也不多，常用到的就那么些。一般说的原生JS，是包括JS语言本身，还有它对DOM和BOM的操作，比如元素的创建移除，事件的添加等等，这些应该都需要懂。至于说对于某个库的学习，更重要的是学习它的思维方式，每看一个例子，就先想一想如果自己写，会把代码写成怎样，再与真实的例子进行对照，举一反三，这样的学习会是很快的过程。 现在这个时代，各种浏览器还在混战，但低版本IE的淘汰已经成为了必然，如果是现在开始学习，一定要着眼于将来，多看看CSS3各子集的规范，了解ES新版本的特性，因为世界迟早是它们的。对于低版本浏览器的兼容，一般都会有成熟的解决方案，当遇到具体问题的时候再去看也可以。 很多人看待前端，是把它当作一个很浅的层面来看的，其实前端的人多了解一些别的领域也是有好处的，从中能得到很多领悟，比如软件工程，设计模式，它们对不管什么方面的开发人员而言，都是很好的指导。 一个成熟的前端开发人员，他应当有比较宽的知识面，同时至少在某一两个细分领域有专注的研究和见解。平时在日常生活中，也可以多注意观察一些产品，对自己正在做的整个产品有深刻认识，对生活常识有充分了解，有时候也会有助于减少开发过程中走的弯路。 能够对自己的未来有所预期，并且主动寻找学习的途径，这说明你有很好的开始，在前端这条道路上认真走下去，相信会有美好的未来。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-05-20-前端架构那些事儿","date":"2019-04-14T09:15:10.718Z","updated":"2019-04-14T09:15:10.718Z","comments":true,"path":"2019/04/14/杂谈/2014-05-20-前端架构那些事儿/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2014-05-20-前端架构那些事儿/","excerpt":"前端架构那些事儿在谈前端架构之前，需要先探讨一下不同人群对前端产生的困惑。前端这个职业最近几年才逐渐被认可，之前一直是低端的代名词，所以多数高手很不屑搞这个。之前的很多项目，人们对前端这块的要求也只是能用就行，所以很少会在上面去细致、深入地建立一套完善体系。而多数产品的技术经理也会是后端出身的，往往对前端的认识还停留在Java Struts那个原始的MVC模型上，或者首先想到的就是GWT和JSF，这是从后端角度出发的一种视角。用这类思维方式做出来的产品，一般用户体验都不会很好。 另一方面，从界面层上手的人群，他对用户体验这方面会把控得比较好，但通常缺架构意识，或者说是软件工程的意识。在界面层比较复杂的情况下，很可能会有失控的趋势。对整个系统结构的认知程度通常不够深入，也缺乏设计模式等方面的知识。","text":"前端架构那些事儿在谈前端架构之前，需要先探讨一下不同人群对前端产生的困惑。前端这个职业最近几年才逐渐被认可，之前一直是低端的代名词，所以多数高手很不屑搞这个。之前的很多项目，人们对前端这块的要求也只是能用就行，所以很少会在上面去细致、深入地建立一套完善体系。而多数产品的技术经理也会是后端出身的，往往对前端的认识还停留在Java Struts那个原始的MVC模型上，或者首先想到的就是GWT和JSF，这是从后端角度出发的一种视角。用这类思维方式做出来的产品，一般用户体验都不会很好。 另一方面，从界面层上手的人群，他对用户体验这方面会把控得比较好，但通常缺架构意识，或者说是软件工程的意识。在界面层比较复杂的情况下，很可能会有失控的趋势。对整个系统结构的认知程度通常不够深入，也缺乏设计模式等方面的知识。开发人员会有一些困惑： 创建项目的时候，一般没有人作前端的技术选型 拿到项目之后，没有直接可复制的基础版本 习惯于引用第三方组件 赶功能，需要某个组件或者特效 上网搜到一个合适的，加进来 它还依赖一些别的库 文件大还是次要的 可能会产生冲突，样式也不一致 开发经理也会有一些困惑： 协作过程感觉有问题 前端人员写原始界面，包含静态界面和特效 开发人员接着改，加逻辑 发现有问题要返工了 在谁的代码基础上继续改？如何合并？ 2014年了，为什么还有这么多人工环节？ 能自动单元测试吗？ 能自动发布打包吗？ 用户会对这些事情感到烦恼： 长得丑 界面老土 风格不一致 速度慢 加载慢 渲染慢 执行慢 出错 架构的本质是什么？其实也是一种管理。通常我们所说的管理，都是指对于任务和人员的管理，而架构管的是机器和代码。比如说，机器的部署属于运维的物理架构，SOA属于服务架构，那么，前端的架构指什么呢？ 长期以来，前端所处的位置是比较偏应用层，而且是很薄的一层，而架构又要求深度和广度，所以之前在前端里面做架构，好比在小水塘里游泳，稍微扑腾两下就到处碰壁。但最近这几年来，前端的范围被大大拓展了，所以这一层逐渐变得大有可为。 怎样去理解架构呢？在早期的文字MUD游戏里，有这么一句话：“你感觉哪里不对，但是又说不上来。”在我们开发和使用软件系统的过程中，或多或少会遇到这样的感觉，有这种感觉就说明架构方面可能有些问题。 在狭义的前端领域，架构要处理的很重要的事情是组件的集成。由于JavaScript本身缺乏命名空间这样的机制，多数框架都倾向于自己搞一套，所以这方面的碎片化是很严重的。如果一个公司的实力不足以自研所有用到的组件，就会一直面临这方面的问题。 比如说，在做某个功能的过程中，发现需要一个组件，时间来不及做，就到网上搜了个，加到代码里面，先运行起来再说。一不小心，等功能做完的时候，已经引入了无数种组件了，有很多代码是重叠的，可能有的还有冲突，外观也不一致。 环顾四周的大型互联网公司，基本上都有自己的前端框架，比如阿里的Kissy和Arale，腾讯的JX，百度的Tangram，360的QWrap等，为什么？因为要整合别的框架，并且在此基础上发展适合自己的组件库，代价非常大，初期没办法的时候只能凑合，长期来说，所有代码都可控的意义非常重要。 那么，是不是一套框架可以包打天下呢，这个真的很难。对于不同的产品形态，如果想要用一套框架去适应，有的会偏轻，有的又偏重，有的要兼容低端浏览器，有的又不要，很难取舍。 常见的前端产品形态包括： 内容型Web站点 侧重渲染方面的优化，前端逻辑比重小 操作型B/S系统 以数据和逻辑为中心，界面较规整 内嵌Web的本地应用 要处理缓存和一些本地接口，包括PC客户端和移动端 另外有Web游戏，因为跟我们的企业形态关系不大，而且也比较独特，所以不包含在内。这三种产品的前端框架要处理的事情显然是不太一样的，所以可以细分成2-3种项目模板，整理出对应的种子项目，供同类产品初始化用。 最近我们经常在前端领域听说两个词：全端、全栈。 全端的意思是，原来的只做在浏览器中运行的Web程序不够，还要做各种终端，包括iOS，Android等本地应用，甚至PC桌面应用。 为什么广义的前端应当包含本地应用呢？因为现在的本地应用，基于很多考虑，都变成了混合应用，也就是说，开发这个应用的技术，既包含原生的代码，也包含了嵌入的HTML5代码。这么一来，就造成了开发本地应用的人技能要求较广，能够根据产品的场景，合理选择每个功能应当使用的技术。 现在有一些PC端的混合应用开发技术，比如node-webkit和hex，前者的典型应用是Intel® XDK，后者的典型应用是有道词典，此外，豌豆荚的PC客户端也是采用类似技术的，也有一些产品是用的qt-webkit。这类技术可以方便做跨平台，极大减少开发工作量。 所以，我们可以看到，在很多公司，开发安卓、iOS应用的人员跟Web前端的处于同一个团队中，这很大程度上就是考虑到这种情况。 全栈的意思是，除了只做在浏览器中运行的代码，还写一些服务端的代码，这个需求又是从哪里来的呢？ 这个需求其实来自优化。我们要优化一个系统的前端部分，有这么一些事情可以做： HTML结构的优化，减少DOM树的层次等等 CSS渲染性能的优化，批量写入DOM变更之类 资源文件的优化，比如小图片的合并，图像格式的处理，图标字体的使用等 JavaScript逻辑的优化，模块化，异步加载，性能优化 加载字节量的优化，主要是分摊的策略 HTTP请求的优化 这里面，除了前三条，其他都可能跟后端有些关系，尤其是最后一条。但是前端的人没法去优化后端的东西，这是不同的协作环节，所以就很麻烦。 那么，如果有了全栈，这个问题可以怎么解决呢？ 比如说，我们要做最原始的小文件合并，可以在服务器做一些配置，把多个合并成一个请求，比如天猫的某个url： http://g.tbcdn.cn/kissy/k/1.4.1/??dom/base-min.js,event-min.js,event/dom/base-min.js,event/base-min.js,event/dom/touch-min.js,event/dom/shake-min.js,event/dom/focusin-min.js,event/custom-min.js,cookie-min.js?t=1.js 这个就很明显是多个文件合并而成的，9个小文件的请求，合并成了一个64k的文件请求。 这种简单的事情可以在静态代理服务器上配置出来，更复杂的就比较难了，需要一定的服务端逻辑。比如说，我们有多个ajax请求，请求不同的服务，每个请求的数据量都非常少，但因为请求数很多，可能会影响加载性能，如果能把它们在服务端就合并成一个就好了。但这个优化是前端发起的，传统模式下，他的职责范围有限，优化不到服务端去，而这多个服务很可能是跨产品模块的，想要合并，放在哪个后端团队都很怪异。 这可真难办，就像老虎追猴子，猴子上了树，老虎只能在下面干瞪眼。但是如果我们能让老虎上树，这就不是个问题了。如果有这么一层NodeJS，这一层完全由前端程序员控制，他就可以在这个地方做这种合并，非常的合理。 除此之外，我们常常会用到HTML模板，但使用它的最佳位置是随着产品的场景而不同的，可能某个地方在前端更好，可能某个地方在后端好些。到底放在哪合适，只有前端开发人员才会知道，如果前端开发人员不能参与一部分后端代码的开发，优化工作也还是做不彻底。有NodeJS之后会怎样呢，因为不管前端模板还是后端模板，都是JavaScript的，可以使用同一套库，这样在做调整的时候不会有代码迁移的烦恼，直接把模板换地方即可。 现在，也有很多业务场景有实时通信的需求，目前来说最合适的方案是Socket.io，它默认使用NodeJS来当服务端，这也是NodeJS的一个重要使用场景。 这样，前端开发人员也部分参与了运行在服务端的代码，他的工作范围从原先客户端浏览器，向后拓展了一个薄层，所以就有了全栈的称呼。至于说这个称呼还继续扩展，一个前端开发人员从视觉到交互到静态HTML到JavaScript包办的情况，这个就有些过头了。 以上这些，主要解决的都是代码层面的事情。另外有一个方面，也是需要关注，但却常常不能引起重视的，那就是前端的工程化问题。 早期为什么没有这些问题？因为那时候前端很简单，复杂度不高，现在整个很复杂了，就带来了很多管理问题。比如说整个系统的前端都组件化了之后，HTML会拆分成各种模板，JavaScript会拆分成各种模块，而CSS也通过LESS或者SASS这种方式，变成了一种编译式的语言。 这时候，我们考虑一个所谓的组件，它就比较麻烦了。它可能是一个或者多个HTML模板，加上一个或者多个JavaScript模块，再包含CSS中的一部分构成的，而前两者都可能有依赖项，三个部分也都要避免与其他组件的冲突。 这些东西都需要管理，并且提供一种比较好的方案去维护。在JavaScript被模块化之后，也可以通过单元测试来控制它们的质量，并且把这个过程自动化，每次版本有变更之前，保证它们最基本的正确性。最终，需要有一种自动化的发布机制，把这几类代码提取，打包合并，压缩，发布。 这个主题展开可以讲很多，所以我们不在本次分享中涉及。在我之前的几篇文章中，也阐述过观点。 目前这方面研究最深入的是之前百度FIS团队的张云龙，他的几篇文章在这里，强烈推荐阅读。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-10-21-build-single-page-application","date":"2019-04-14T09:15:10.710Z","updated":"2019-04-14T09:15:10.710Z","comments":true,"path":"2019/04/14/杂谈/2014-10-21-build-single-page-application/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2014-10-21-build-single-page-application/","excerpt":"构建单页Web应用单页应用是什么？让我们先来看几个网站： coding teambition cloud9 注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。","text":"构建单页Web应用单页应用是什么？让我们先来看几个网站： coding teambition cloud9 注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。所谓单页应用，指的是在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。它是AJAX技术的进一步升华，把AJAX的无刷新机制发挥到极致，因此能造就与桌面程序媲美的流畅用户体验。 其实单页应用我们并不陌生，很多人写过ExtJS的项目，用它实现的系统，很天然的就已经是单页的了，也有人用jQuery或者其他框架实现过类似的东西。用各种JS框架，甚至不用框架，都是可以实现单页应用的，它只是一种理念。有些框架适用于开发这种系统，如果使用它们，可以得到很多便利。 开发框架ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成整个前端部分，甚至包括布局。随着功能逐渐增加，ExtJS的体积也逐渐增大，即使用于内部系统的开发，有时候也显得笨重了，更不用说开发以上这类运行在互联网上的系统。 jQuery由于偏重DOM操作，它的插件体系又比较松散，所以比ExtJS这个体系更适合开发在公网运行的单页系统，整个解决方案会相对比较轻量、灵活。 但由于jQuery主要面向上层操作，它对代码的组织是缺乏约束的。如何在代码急剧膨胀的情况下控制每个模块的内聚性，并且适当在模块之间产生数据传递与共享，就成为了一种有挑战的事情。 为了解决单页应用规模增大时候的代码逻辑问题，出现了不少MV*框架，他们的基本思路都是在JS层创建模块分层和通信机制。有的是MVC，有的是MVP，有的是MVVM，而且，它们几乎都在这些模式上产生了变异，以适应前端开发的特点。 这类框架包括Backbone，Knockout，AngularJS，Avalon等。 组件化这些在前端做分层的框架推动了代码的组件化，所谓组件化，在传统的Web产品中，更多的指UI组件，但其实组件是一个广泛概念，传统Web产品中UI组件占比高的原因是它的厚度不足，随着客户端代码比例的增加，相当一部分的业务逻辑也前端化，由此催生了很多非界面型组件的出现。 分层带来的一个优势是，每层的职责更专一了，由此，可以对其作单元测试的覆盖，以保证其质量。传统UI层测试最头疼的问题是UI层和逻辑混杂在一起，比如往往会在远程请求的回调中更改DOM，当引入分层之后，这些东西都可以分别被测试，然后再通过场景测试来保证整体流程。 代码隔离与开发传统页面型网站相比，实现单页应用的过程中，有一些比较值得特别关注的点。 从单页应用的特点来看，它比页面型网站更加依赖于JavaScript，而由于页面的单页化，各种子功能的JavaScript代码聚集到了同一个作用域，所以代码的隔离、模块化变得很重要。 在单页应用中，页面模板的使用是很普遍的。很多框架内置了特定的模板，也有的框架需要引入第三方的模板。这种模板是界面片段，我们可以把它们类比成JavaScript模块，它们是另一种类型的组件。 模板也一样有隔离的需要。不隔离模板，会造成什么问题呢？模板间的冲突主要存在于id属性上，如果一个模板中包含固定的id，当它被批量渲染的时候，会造成同一个页面的作用域中出现多个相同id的元素，产生不可预测的后果。因此，我们需要在模板中避免使用id，如果有对DOM的访问需求，应当通过其他选择器来完成。如果一个单页应用的组件化程度非常高，很可能整个应用中都没有元素id的使用。 代码合并与加载策略人们对于单页系统的加载时间容忍度与Web页面不同，如果说他们愿意为购物页面的加载等待3秒，有可能会愿意为单页应用的首次加载等待5-10秒，但在此之后，各种功能的使用应当都比较流畅，所有子功能页面尽量要在1-2秒时间内切换成功，否则他们就会感觉这个系统很慢。 从这些特点来看，我们可以把更多的公共功能放到首次加载，以减小每次加载的载入量，有一些站点甚至把所有的界面和逻辑全部放到首页加载，每次业务界面切换的时候，只产生数据请求，因此它的响应是非常迅速的，比如青云的控制台就是这么做的。 通常在单页应用中，无需像网站型产品一样，为了防止文件加载阻塞渲染，把js放到html后面加载，因为它的界面基本都是动态生成的。 当切换功能的时候，除了产生数据请求，还需要渲染界面，这个新渲染的界面部件一般是界面模板，它从哪里来呢？来源无非是两种，一种是即时请求，像请求数据那样通过AJAX获取过来，另一种是内置于主界面的某些位置，比如script标签或者不可见的textarea中，后者在切换功能的时候速度有优势，但是加重了主页面的负担。 在传统的页面型网站中，页面之间是互相隔离的，因此，如果在页面间存在可复用的代码，一般是提取成单独的文件，并且可能会需要按照每个页面的需求去进行合并。单页应用中，如果总的代码量不大，可以整体打包一次在首页载入，如果大到一定规模，再作运行时加载，加载的粒度可以搞得比较大，不同的块之间没有重复部分。 路由与状态的管理我们最开始看到的几个在线应用，有的是对路由作了管理的，有的没有。 管理路由的目的是什么呢？是为了能减少用户的导航成本。比如说我们有一个功能，经历过多次导航菜单的点击，才呈现出来。如果用户想要把这个功能地址分享给别人，他怎么才能做到呢？ 传统的页面型产品是不存在这个问题的，因为它就是以页面为单位的，也有的时候，服务端路由处理了这一切。但是在单页应用中，这成为了问题，因为我们只有一个页面，界面上的各种功能区块是动态生成的。所以我们要通过对路由的管理，来实现这样的功能。 具体的做法就是把产品功能划分为若干状态，每个状态映射到相应的路由，然后通过pushState这样的机制，动态解析路由，使之与功能界面匹配。 有了路由之后，我们的单页面产品就可以前进后退，就像是在不同页面之间一样。 其实在Web产品之外，早就有了管理路由的技术方案，Adobe Flex中，就会把比如TabNavigator，甚至下拉框的选中状态对应到url上，因为它也是单“页面”的产品模式，需要面对同样的问题。 当产品状态复杂到一定程度的时候，路由又变得很难应用了，因为状态的管理极其麻烦，比如开始的时候我们演示的c9.io在线IDE，它就没法把状态对应到url上。 缓存与本地存储在单页应用的运作机制中，缓存是一个很重要的环节。 由于这类系统的前端部分几乎全是静态文件，所以它能够有机会利用浏览器的缓存机制，而比如动态加载的界面模板，也完全可以做一些自定义的缓存机制，在非首次的请求中直接取缓存的版本，以加快加载速度。 甚至，也出现了一些方案，在动态加载JavaScript代码的同时，把它们也缓存起来。比如Addy Osmani的这个basket.js，就利用了HTML5 localStorage作了js和css文件的缓存。 在单页产品中，业务代码也常常会需要跟本地存储打交道，存储一些临时数据，可以使用localStorage或者localStorageDB来简化自己的业务代码。 服务端通信传统的Web产品通常使用JSONP或者AJAX这样的方式与服务端通信，但在单页Web应用中，有很大一部分采用WebSocket这样的实时通讯方式。 WebSocket与传统基于HTTP的通信机制相比，有很大的优势。它可以让服务端很便利地使用反向推送，前端只响应确实产生业务数据的事件，减少一遍又一遍无意义的AJAX轮询。 由于WebSocket只在比较先进的浏览器上被支持，有一些库提供了在不同浏览器中的兼容方案，比如socket.io，它在不支持WebSocket的浏览器上会降级成使用AJAX或JSONP等方式，对业务代码完全透明、兼容。 内存管理传统的Web页面一般是不需要考虑内存的管理的，因为用户的停留时间相对少，即使出现内存泄漏，可能很快就被刷新页面之类的操作冲掉了，但单页应用是不同的，它的用户很可能会把它开一整天，因此，我们需要对其中的DOM操作、网络连接等部分格外小心。 样式的规划在单页应用中，因为页面的集成度高，所有页面聚集到同一作用域，样式的规划也变得重要了。 样式规划主要是几个方面： 基准样式的分离这里面主要包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式支持。 组件样式的划分这里面是两个层面的规划，首先是各种界面组件及其子元素的样式，其次是一些修饰样式。组件样式应当尽量减少互相依赖，各组件的样式允许冗余。 堆叠次序的管理传统Web页面的特点是元素多，但是层次少，单页应用会有些不同。 在单页应用中，需要提前为各种UI组件规划堆叠次序，也就是z-index，比如说，我们可能会有各种弹出对话框，浮动层，它们可能组合成各种堆叠状态。新的对话框的z-index需要比旧的高，才能确保盖在它上面。诸如此类，都需要我们对这些可能的遮盖作规划，那么，怎样去规划呢？ 了解通信知识的人，应当会知道，不同的频率段被划分给不同的通信方式使用，在一些国家，领空的使用也是有划分的，我们也可以用同样的方式来预先分段，不同类型的组件的z-index落到各自的区间，以避免它们的冲突。 单页应用的产品形态我们在开始的时候提到，存在着很多新型Web产品，使用单页应用的方式构建，但实际上，这类产品不仅仅存在于Web上。点开Chrome商店，我们会发现很多离线应用，这些产品都可以算是单页应用的体现。 除了各种浏览器插件，借助node-webkit这样的外壳平台，我们可以使用Web技术来构建本地应用，产品的主要部分仍然是我们熟悉的单页应用。 单页应用的流行程度正在逐渐增加，大家如果关注了一些初创型互联网企业，会发现其中很大一部分的产品模式是单页化的。这种模式能带给用户流畅的体验，在开发阶段，对JavaScript技能水平要求较高。 单页应用开发过程中，前后端是天然分离的，双方以API为分界。前端作为服务的消费者，后端作为服务的提供者。在此模式下，前端将会推动后端的服务化。当后端不再承担模板渲染、输出页面这样工作的情况下，它可以更专注于所提供的API的实现，而在这样的情况下，Web前端与各种移动终端的地位对等，也逐渐使得后端API不必再为每个端作差异化设计了。 部署模式的改变在现在这个时代，我们已经可以看到一种产品的出现了，那就是“无后端”的Web应用。这是一种什么东西呢？基于这种理念，你的产品很可能只需要自己编写静态Web页面，在某种BaaS（Backend as a Service）云平台上定制服务端API和云存储，集成这个平台提供的SDK，通过AJAX等方式与之打交道，实现注册认证、社交、消息推送、实时通信、云存储等功能。 我们观察一下这种模式，会发现前后端的部署已经完全分离了，前端代码完全静态化，这意味着可以把它们放置到CDN上，访问将大大地加速，而服务端托管在BaaS云上，开发者也不必去关注一些部署方面的繁琐细节。 假设你是一名创业者，正在做的是一种实时协同的单页产品，可以在云平台上，快速定制后端服务，把绝大部分宝贵的时间花在开发产品本身上。 单页应用的缺陷单页应用最根本的缺陷就是不利于SEO，因为界面的绝大部分都是动态生成的，所以搜索引擎很不容易索引它。 产品单页化带来的挑战一个产品想要单页化，首先是它必须适合单页的形态。其次，在这个过程中，对开发模式会产生一些变更，对开发技能也会有一些要求。 开发者的JavaScript技能必须过关，同时需要对组件化、设计模式有所认识，他所面对的不再是一个简单的页面，而是一个运行在浏览器环境中的桌面软件。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-07-01-从零开始编写自己的JavaScript框架（一）","date":"2019-04-14T09:10:49.496Z","updated":"2019-04-14T09:10:49.496Z","comments":true,"path":"2019/04/14/杂谈/2013-07-01-从零开始编写自己的JavaScript框架（一）/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2013-07-01-从零开始编写自己的JavaScript框架（一）/","excerpt":"从零开始编写自己的JavaScript框架（一）#1. 模块的定义和加载 ##1.1 模块的定义 一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。 先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？ 我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。 考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。","text":"从零开始编写自己的JavaScript框架（一）#1. 模块的定义和加载 ##1.1 模块的定义 一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。 先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？ 我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。 考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？ 在很多传统高级语言里，变量作用域的边界是大括号，在{}里面定义的变量，作用域不会传到外面去，但我们的JavaScript大人不是这样的，他的边界是function。所以我们这段代码，i仍然能打出值： for (var i=0; i&lt;5; i++) { //do something } alert(i); 那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。 我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过：C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！”Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！”C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！ 啊，我们发现了什么，既然无法避免全局的作用域，那与其让100个function都全局，不如只让一个来全局，其他的都由它管理。 本来我们打算自己当上帝的，现在只好改行先当个工商局长。你想开店吗？先来注册，不然封杀你！于是良民们纷纷来注册。店名叫什么，从哪进货，卖什么的，一一登记在案，为了方便下面的讨论，我们连进货的过程都让工商局管理起来。 店名，指的就是这里的模块名，从哪里进货，代表它依赖什么其他模块，卖什么，表示它对外提供一些什么特性。 好了，考虑到我们的这个注册管理机构是个全局作用域，我们还得把它挂在window上作为属性，然后再用一个function隔离出来，要不然，别人也定义一个同名的，就把我们覆盖掉了。 (function() { window.thin = { define: function(name, dependencies, factory) { //register a module } }; })(); 在这个module方法内部，应当怎么去实现呢？我们的module应当有一个地方存储，但存储是要在工商局内部的，不是随便什么人都可以看到的，所以，这个存储结构也放在工商局同样的作用域里。 用什么结构去存储呢？工商局备案的时候，店名不能跟已有的重复，所以我们发现这是用map的很好场景，考虑到JavaScript语言层面没有map，我们弄个Object来存。 (function() { var moduleMap = {}; window.thin = { define: function(name, dependencies, factory) { if (!moduleMap[name]) { var module = { name: name, dependencies: dependencies, factory: factory }; moduleMap[name] = module; } return moduleMap[name]; } }; })(); 现在，模块的存储结构就搞好了。 ##1.2 模块的使用 存的部分搞好了，我们来看看怎么取。现在来了一个商家，卖木器的，他需要从一个卖钉子的那边进货，卖钉子的已经来注册过了，现在要让这个木器厂能买到钉子。现在的问题是，两个商家处于不同的作用域，也就是说，它们互相不可见，那通过什么方式，我们才能让他们产生调用关系呢？ 个人解决不了的问题还是得靠政府，有困难要坚决克服，没有困难就制造困难来克服。现在困难有了，该克服了。商家说，我能不能给你我的进货名单，你帮我查一下它们在哪家店，然后告诉我？这么简单的要求当然一口答应下来，但是采用什么方式传递给你呢？这可犯难了。 我们参考AngularJS框架，写了一个类似的代码： thin.define(&quot;A&quot;, [], function() { //module A }); thin.define(&quot;B&quot;, [&quot;A&quot;], function(A) { //module B var a = new A(); }); 看这段代码特别在哪里呢？模块A的定义，毫无特别之处，主要看模块B。它在依赖关系里写了一个字符串的A，然后在工厂方法的形参写了一个真真切切的A类型。嗯？这个有些奇怪啊，你的A类型要怎么传递过来呢？其实是很简单的，因为我们声明了依赖项的数组，所以可以从依赖项，挨个得到对应的工厂方法，然后创建实例，传进来。 use: function(name) { var module = moduleMap[name]; if (!module.entity) { var args = []; for (var i=0; i&lt;module.dependencies.length; i++) { if (moduleMap[module.dependencies[i]].entity) { args.push(moduleMap[module.dependencies[i]].entity); } else { args.push(this.use(module.dependencies[i])); } } module.entity = module.factory.apply(noop, args); } return module.entity; } 我们可以看到，这里面递归获取了依赖项，然后当作参数，用这个模块的工厂方法来实例化了一下。这里我们多做了一个判断，如果模块工厂已经执行过，就缓存在entity属性上，不需要每次都创建。以此类推，假如一个模块有多个依赖项，也可以用类似的方式写，毫无压力： thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(A, B, C) { //module D var a = new A(); var b = new B(); var c = new C(); }); 注意了，D模块的工厂，实参的名称未必就要是跟依赖项一致，比如，以后我们代码较多，可以给依赖项和模块名称加命名空间，可能变成这样： thin.define(&quot;foo.D&quot;, [&quot;foo.A&quot;, &quot;foo.B&quot;, &quot;foo.C&quot;], function(A, B, C) { //module D var a = new A(); var b = new B(); var c = new C(); }); 这段代码仍然可以正常运行。我们来做另外一个测试，改变形参的顺序： thin.define(&quot;A&quot;, [], function() { return &quot;a&quot;; }); thin.define(&quot;B&quot;, [], function() { return &quot;b&quot;; }); thin.define(&quot;C&quot;, [], function() { return &quot;c&quot;; }); thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(B, A, C) { return B + A + C; }); var D = thin.use(&quot;D&quot;); alert(D); 试试看，我们的D打出什么结果呢？结果是”abc”，所以说，模块工厂的实参只跟依赖项的定义有关，跟形参的顺序无关。我们看到，在AngularJS里面，并非如此，实参的顺序是跟形参一致的，这是怎么做到的呢？ 我们先离开代码，思考这么一个问题：如何得知函数的形参名数组？对，我们是可以用func.length得到形参个数，但无法得到每个形参的变量名，那怎么办呢？ AngularJS使用了一种比较极端的办法，分析了函数的字面量。众所周知，在JavaScript中，任何对象都隐含了toString方法，对于一个函数来说，它的toString就是自己的实现代码，包含函数签名和注释。下面我贴一下AngularJS里面的这部分代码： var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m; var FN_ARG_SPLIT = /,/; var FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/; var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg; function annotate(fn) { var $inject, fnText, argDecl, last; if (typeof fn == &apos;function&apos;) { if (!($inject = fn.$inject)) { $inject = []; fnText = fn.toString().replace(STRIP_COMMENTS, &apos;&apos;); argDecl = fnText.match(FN_ARGS); forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){ arg.replace(FN_ARG, function(all, underscore, name){ $inject.push(name); }); }); fn.$inject = $inject; } } else if (isArray(fn)) { last = fn.length - 1; assertArgFn(fn[last], &apos;fn&apos;); $inject = fn.slice(0, last); } else { assertArgFn(fn, &apos;fn&apos;, true); } return $inject; } 可以看到，这个代码也不长，重点是类型为function的那段，首先去除了注释，然后获取了形参列表字符串，这段正则能获取到两个结果，第一个是全函数的实现，第二个才是真正的形参列表，取第二个出来split，就得到了形参的字符串列表了，然后按照这个顺序再去加载依赖模块，就可以让形参列表不对应于依赖项数组了。 AngularJS的这段代码很强大，但是要损耗一些性能，考虑到我们的框架首要原则是简单，甚至可以为此牺牲一些灵活性，我们不做这么复杂的事情了。 ##1.3 模块的加载 到目前为止，我们可以把多个模块都定义在一个文件中，然后手动引入这个js文件，但是如果一个页面要引用很多个模块，引入工作就变得比较麻烦，比如说，单页应用程序（SPA）一般比较复杂，往往包含数以万计行数的js代码，这些代码至少分布在几十个甚至成百上千的模块中，如果我们也在主界面就加载它们，载入时间会非常难以接受。但我们可以这样看：主界面加载的时候，并不是用到了所有这些功能，能否先加载那些必须的，而把剩下的放在需要用的时候再去加载？ 所以我们可以考虑万能的AJAX，从服务端获取一个js的内容，然后……，怎么办，你当然说不能eval了，因为据说eval很evil啦，但是它evil在哪里呢？主要是破坏全局作用域啦，怎么怎么，但是如果这些文件里面都是按照我们规定的模块格式写，好像也没有什么在全局作用域的……，好吧。 算了，我们还是用最简单的方式了，就是动态创建script标签，然后设置src，添加到document.head里，然后监听它们的完成事件，做后续操作。真的很简单，因为我们的框架不需要考虑那么多种情况，不需要AMD，不需要require那么麻烦，用这框架的人必须按照这里的原则写。 我也偷懒了，只是贴一下代码，顺便解释一下，界面把所依赖的js文件路径放在数组里，然后挨个创建script标签，src设置为路径，添加到head中，监听它们的完成事件。在这个完成时间里，我们要做这么一些事情：在fileMap里记录当前js文件的路径，防止以后重复加载，检查列表中所有文件，看看是否全部加载完了，如果全加载好了，就执行回调。 require: function (pathArr, callback) { for (var i = 0; i &lt; pathArr.length; i++) { var path = pathArr[i]; if (!fileMap[path]) { var head = document.getElementsByTagName(&apos;head&apos;)[0]; var node = document.createElement(&apos;script&apos;); node.type = &apos;text/javascript&apos;; node.async = &apos;true&apos;; node.src = path + &apos;.js&apos;; node.onload = function () { fileMap[path] = true; head.removeChild(node); checkAllFiles(); }; head.appendChild(node); } } function checkAllFiles() { var allLoaded = true; for (var i = 0; i &lt; pathArr.length; i++) { if (!fileMap[pathArr[i]]) { allLoaded = false; break; } } if (allLoaded) { callback(); } } } ##1.4 小结 到此为止，我们的简易框架的模块定义系统就完成了。完整的代码如下： (function () { var moduleMap = {}; var fileMap = {}; var noop = function () { }; var thin = { define: function(name, dependencies, factory) { if (!moduleMap[name]) { var module = { name: name, dependencies: dependencies, factory: factory }; moduleMap[name] = module; } return moduleMap[name]; }, use: function(name) { var module = moduleMap[name]; if (!module.entity) { var args = []; for (var i=0; i&lt;module.dependencies.length; i++) { if (moduleMap[module.dependencies[i]].entity) { args.push(moduleMap[module.dependencies[i]].entity); } else { args.push(this.use(module.dependencies[i])); } } module.entity = module.factory.apply(noop, args); } return module.entity; }, require: function (pathArr, callback) { for (var i = 0; i &lt; pathArr.length; i++) { var path = pathArr[i]; if (!fileMap[path]) { var head = document.getElementsByTagName(&apos;head&apos;)[0]; var node = document.createElement(&apos;script&apos;); node.type = &apos;text/javascript&apos;; node.async = &apos;true&apos;; node.src = path + &apos;.js&apos;; node.onload = function () { fileMap[path] = true; head.removeChild(node); checkAllFiles(); }; head.appendChild(node); } } function checkAllFiles() { var allLoaded = true; for (var i = 0; i &lt; pathArr.length; i++) { if (!fileMap[pathArr[i]]) { allLoaded = false; break; } } if (allLoaded) { callback(); } } } }; window.thin = thin; })(); 测试代码如下： thin.define(&quot;constant.PI&quot;, [], function() { return 3.14159; }); thin.define(&quot;shape.Circle&quot;, [&quot;constant.PI&quot;], function(pi) { var Circle = function(r) { this.r = r; }; Circle.prototype = { area : function() { return pi * this.r * this.r; } } return Circle; }); thin.define(&quot;shape.Rectangle&quot;, [], function() { var Rectangle = function(l, w) { this.l = l; this.w = w; }; Rectangle.prototype = { area: function() { return this.l * this.w; } }; return Rectangle; }); thin.define(&quot;ShapeTypes&quot;, [&quot;shape.Circle&quot;, &quot;shape.Rectangle&quot;], function(Circle, Rectangle) { return { CIRCLE: Circle, RECTANGLE: Rectangle }; }); thin.define(&quot;ShapeFactory&quot;, [&quot;ShapeTypes&quot;], function(ShapeTypes) { return { getShape: function(type) { var shape; switch (type) { case &quot;CIRCLE&quot;: { shape = new ShapeTypes[type](arguments[1]); break; } case &quot;RECTANGLE&quot;: { shape = new ShapeTypes[type](arguments[1], arguments[2]); break; } } return shape; } }; }); var ShapeFactory = thin.use(&quot;ShapeFactory&quot;); alert(ShapeFactory.getShape(&quot;CIRCLE&quot;, 5).area()); alert(ShapeFactory.getShape(&quot;RECTANGLE&quot;, 3, 4).area());","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-01-14-前端开发技术的发展","date":"2019-04-14T09:10:49.493Z","updated":"2019-04-14T09:10:49.494Z","comments":true,"path":"2019/04/14/杂谈/2013-01-14-前端开发技术的发展/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2013-01-14-前端开发技术的发展/","excerpt":"前端开发技术的发展前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了： 专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。 VML和SVG等基于XML的描述图形的语言。 从属于XML体系的XML，XPath，DTD等技术。 用于支撑后端的ASP，JSP，ASP.net，PHP，nodejs等语言或者技术。 被第三方程序打包的一种类似浏览器的宿主环境，比如Adobe AIR和使用HyBird方式的一些开发技术，如PhoneGap（它使用Android中的WebView等技术，让开发人员使用传统Web开发技术来开发本地应用） Adobe Flash，Flex，Microsoft Silverlight，Java Applet，JavaFx等RIA开发技术。 本文从狭义的前端定义出发，探讨一下这方面开发技术的发展过程。","text":"前端开发技术的发展前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了： 专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。 VML和SVG等基于XML的描述图形的语言。 从属于XML体系的XML，XPath，DTD等技术。 用于支撑后端的ASP，JSP，ASP.net，PHP，nodejs等语言或者技术。 被第三方程序打包的一种类似浏览器的宿主环境，比如Adobe AIR和使用HyBird方式的一些开发技术，如PhoneGap（它使用Android中的WebView等技术，让开发人员使用传统Web开发技术来开发本地应用） Adobe Flash，Flex，Microsoft Silverlight，Java Applet，JavaFx等RIA开发技术。 本文从狭义的前端定义出发，探讨一下这方面开发技术的发展过程。从前端开发技术的发展来看，大致可以分为以下几个阶段： #一. 刀耕火种 ##1. 静态页面 最早期的Web界面基本都是在互联网上使用，人们浏览某些内容，填写几个表单，并且提交。当时的界面以浏览为主，基本都是HTML代码，有时候穿插一些JavaScript，作为客户端校验这样的基础功能。代码的组织比较简单，而且CSS的运用也是比较少的。 最简单的是这样一个文件： &lt;html&gt; &lt;head&gt; &lt;title&gt;测试一&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;p&gt;段落内容&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ##2. 带有简单逻辑的界面这个界面带有一段JavaScript代码，用于拼接两个输入框中的字符串，并且弹出窗口显示。 &lt;html&gt; &lt;head&gt; &lt;title&gt;测试二&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;firstNameInput&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;lastNameInput&quot; type=&quot;text&quot; /&gt; &lt;input type=&quot;button&quot; onclick=&quot;greet()&quot; /&gt; &lt;script language=&quot;JavaScript&quot;&gt; function greet() { var firstName = document.getElementById(&quot;firstNameInput&quot;).value; var lastName = document.getElementById(&quot;lastNameInput&quot;).value; alert(&quot;Hello, &quot; + firstName + &quot;.&quot; + lastName); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ##3. 结合了服务端技术的混合编程 由于静态界面不能实现保存数据等功能，出现了很多服务端技术，早期的有CGI（Common Gateway Interface，多数用C语言或者Perl实现的），ASP（使用VBScript或者JScript），JSP（使用Java），PHP等等，Python和Ruby等语言也常被用于这类用途。 有了这类技术，在HTML中就可以使用表单的post功能提交数据了，比如： &lt;form method=&quot;post&quot; action=&quot;username.asp&quot;&gt; &lt;p&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot; /&gt;&lt;/p&gt; &lt;p&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; /&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; 在这个阶段，由于客户端和服务端的职责未作明确的划分，比如生成一个字符串，可以由前端的JavaScript做，也可以由服务端语言做，所以通常在一个界面里，会有两种语言混杂在一起，用&lt;%和%&gt;标记的部分会在服务端执行，输出结果，甚至经常有把数据库连接的代码跟页面代码混杂在一起的情况，给维护带来较大的不便。 &lt;html&gt; &lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;p&gt; &lt;% response.write(&quot;Hello world from server!&quot;) %&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ##4.组件化的萌芽 这个时代，也逐渐出现了组件化的萌芽。比较常见的有服务端的组件化，比如把某一类服务端功能单独做成片段，然后其他需要的地方来include进来，典型的有：ASP里面数据库连接的地方，把数据源连接的部分写成conn.asp，然后其他每个需要操作数据库的asp文件包含它。 上面所说的是在服务端做的，浏览器端通常有针对JavaScript的，把某一类的Javascript代码写到单独的js文件中，界面根据需要，引用不同的js文件。针对界面的组件方式，通常利用frameset和iframe这两个标签。某一大块有独立功能的界面写到一个html文件，然后在主界面里面把它当作一个frame来载入，一般的B/S系统集成菜单的方式都是这样的。 此外，还出现了一些基于特定浏览器的客户端组件技术，比如IE浏览器的HTC（HTML Component）。这种技术最初是为了对已有的常用元素附加行为的，后来有些场合也用它来实现控件。微软ASP.net的一些版本里，使用这种技术提供了树形列表，日历，选项卡等功能。HTC的优点是允许用户自行扩展HTML标签，可以在自己的命名空间里定义元素，然后，使用HTML，JavaScript和CSS来实现它的布局、行为和观感。这种技术因为是微软的私有技术，所以逐渐变得不那么流行。 Firefox浏览器里面推出过一种叫XUL的技术，也没有流行起来。 #二. 铁器时代 这个时代的典型特征是Ajax的出现。 ##1. AJAXAJAX其实是一系列已有技术的组合，早在这个名词出现之前，这些技术的使用就已经比较广泛了，GMail因为恰当地应用了这些技术，获得了很好的用户体验。 由于Ajax的出现，规模更大，效果更好的Web程序逐渐出现，在这些程序中，JavaScript代码的数量迅速增加。出于代码组织的需要，“JavaScript框架”这个概念逐步形成，当时的主流是prototype和mootools，这两者各有千秋，提供了各自方式的面向对象组织思路。 ##2. JavaScript基础库 Prototype框架主要是为JavaScript代码提供了一种组织方式，对一些原生的JavaScript类型提供了一些扩展，比如数组、字符串，又额外提供了一些实用的数据结构，如：枚举，Hash等，除此之外，还对dom操作，事件，表单和Ajax做了一些封装。 Mootools框架的思路跟Prototype很接近，它对JavaScript类型扩展的方式别具一格，所以在这类框架中，经常被称作“最优雅的”对象扩展体系。 从这两个框架的所提供的功能来看，它们的定位是核心库，在使用的时候一般需要配合一些外围的库来完成。 jQuery与这两者有所不同，它着眼于简化DOM相关的代码。例如： DOM的选择 jQuery提供了一系列选择器用于选取界面元素，在其他一些框架中也有类似功能，但是一般没有它的简洁、强大。 $(&quot;*&quot;) //选取所有元素 $(&quot;#lastname&quot;) //选取id为lastname的元素 $(&quot;.intro&quot;) //选取所有class=&quot;intro&quot;的元素 $(&quot;p&quot;) //选取所有&amp;lt;p&amp;gt;元素 $(&quot;.intro.demo&quot;) //选取所有 class=&quot;intro&quot;且class=&quot;demo&quot;的元素 链式表达式： 在jQuery中，可以使用链式表达式来连续操作dom，比如下面这个例子： 如果不使用链式表达式，可能我们需要这么写： var neat = $(&quot;p.neat&quot;); neat.addClass(&quot;ohmy&quot;); neat.show(&quot;slow&quot;); 但是有了链式表达式，我们只需要这么一行代码就可以完成这些： $(&quot;p.neat&quot;).addClass(&quot;ohmy&quot;).show(&quot;slow&quot;); 除此之外，jQuery还提供了一些动画方面的特效代码，也有大量的外围库，比如jQuery UI这样的控件库，jQuery mobile这样的移动开发库等等。 ##3. 模块代码加载方式 以上这些框架提供了代码的组织能力，但是未能提供代码的动态加载能力。动态加载JavaScript为什么重要呢？因为随着Ajax的普及，jQuery等辅助库的出现，Web上可以做很复杂的功能，因此，单页面应用程序（SPA，Single Page Application）也逐渐多了起来。 单个的界面想要做很多功能，需要写的代码是会比较多的，但是，并非所有的功能都需要在界面加载的时候就全部引入，如果能够在需要的时候才加载那些代码，就把加载的压力分担了，在这个背景下，出现了一些用于动态加载JavaScript的框架，也出现了一些定义这类可被动态加载代码的规范。 在这些框架里，知名度比较高的是RequireJS，它遵循一种称为AMD（Asynchronous Module Definition）的规范。 比如下面这段，定义了一个动态的匿名模块，它依赖math模块 define([&quot;math&quot;], function(math) { return { addTen : function(x) { return math.add(x, 10); } }; }); 假设上面的代码存放于adder.js中，当需要使用这个模块的时候，通过如下代码来引入adder： &lt;script src=&quot;require.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;adder&quot;], function(adder) { //使用这个adder }); &lt;/script&gt; RequireJS除了提供异步加载方式，也可以使用同步方式加载模块代码。AMD规范除了使用在前端浏览器环境中，也可以运行于nodejs等服务端环境，nodejs的模块就是基于这套规范定义的。（修订，这里弄错了，nodejs是基于类似的CMD规范的） #三. 工业革命 这个时期，随着Web端功能的日益复杂，人们开始考虑这样一些问题： 如何更好地模块化开发 业务数据如何组织 界面和业务数据之间通过何种方式进行交互 在这种背景下，出现了一些前端MVC、MVP、MVVM框架，我们把这些框架统称为MV*框架。这些框架的出现，都是为了解决上面这些问题，具体的实现思路各有不同，主流的有Backbone，AngularJS，Ember，Spine等等，本文主要选用Backbone和AngularJS来讲述以下场景。 ##1. 数据模型 在这些框架里，定义数据模型的方式与以往有些差异，主要在于数据的get和set更加有意义了，比如说，可以把某个实体的get和set绑定到RESTful的服务上，这样，对某个实体的读写可以更新到数据库中。另外一个特点是，它们一般都提供一个事件，用于监控数据的变化，这个机制使得数据绑定成为可能。 在一些框架中，数据模型需要在原生的JavaScript类型上做一层封装，比如Backbone的方式是这样： var Todo = Backbone.Model.extend({ // Default attributes for the todo item. defaults : function() { return { title : &quot;empty todo...&quot;, order : Todos.nextOrder(), done : false }; }, // Ensure that each todo created has `title`. initialize : function() { if (!this.get(&quot;title&quot;)) { this.set({ &quot;title&quot; : this.defaults().title }); } }, // Toggle the &apos;done&apos; state of this todo item. toggle : function() { this.save({ done : !this.get(&quot;done&quot;) }); } }); 上述例子中，defaults方法用于提供模型的默认值，initialize方法用于做一些初始化工作，这两个都是约定的方法，toggle是自定义的，用于保存todo的选中状态。 除了对象，Backbone也支持集合类型，集合类型在定义的时候要通过model属性指定其中的元素类型。 // The collection of todos is backed by *localStorage* instead of a remote server. var TodoList = Backbone.Collection.extend({ // Reference to this collection&apos;s model. model : Todo, // Save all of the todo items under the &apos;&quot;todos-backbone&quot;&apos; namespace. localStorage : new Backbone.LocalStorage(&quot;todos-backbone&quot;), // Filter down the list of all todo items that are finished. done : function() { return this.filter(function(todo) { return todo.get(&apos;done&apos;); }); }, // Filter down the list to only todo items that are still not finished. remaining : function() { return this.without.apply(this, this.done()); }, // We keep the Todos in sequential order, despite being saved by unordered //GUID in the database. This generates the next order number for new items. nextOrder : function() { if (!this.length) return 1; return this.last().get(&apos;order&apos;) + 1; }, // Todos are sorted by their original insertion order. comparator : function(todo) { return todo.get(&apos;order&apos;); } }); 数据模型也可以包含一些方法，比如自身的校验，或者跟后端的通讯、数据的存取等等，在上面两个例子中，也都有体现。 AngularJS的模型定义方式与Backbone不同，可以不需要经过一层封装，直接使用原生的JavaScript简单数据、对象、数组，相对来说比较简便。 ##2. 控制器 在Backbone中，是没有独立的控制器的，它的一些控制的职责都放在了视图里，所以其实这是一种MVP（Model View Presentation）模式，而AngularJS有很清晰的控制器层。 还是以这个todo为例，在AngularJS中，会有一些约定的注入，比如$scope，它是控制器、模型和视图之间的桥梁。在控制器定义的时候，将$scope作为参数，然后，就可以在控制器里面为它添加模型的支持。 function TodoCtrl($scope) { $scope.todos = [{ text : &apos;learn angular&apos;, done : true }, { text : &apos;build an angular app&apos;, done : false }]; $scope.addTodo = function() { $scope.todos.push({ text : $scope.todoText, done : false }); $scope.todoText = &apos;&apos;; }; $scope.remaining = function() { var count = 0; angular.forEach($scope.todos, function(todo) { count += todo.done ? 0 : 1; }); return count; }; $scope.archive = function() { var oldTodos = $scope.todos; $scope.todos = []; angular.forEach(oldTodos, function(todo) { if (!todo.done) $scope.todos.push(todo); }); }; } 本例中为$scope添加了todos这个数组，addTodo，remaining和archive三个方法，然后，可以在视图中对他们进行绑定。 ##3. 视图在这些主流的MV*框架中，一般都提供了定义视图的功能。在Backbone中，是这样定义视图的： // The DOM element for a todo item... var TodoView = Backbone.View.extend({ //... is a list tag. tagName : &quot;li&quot;, // Cache the template function for a single item. template : _.template($(&apos;#item-template&apos;).html()), // The DOM events specific to an item. events : { &quot;click .toggle&quot; : &quot;toggleDone&quot;, &quot;dblclick .view&quot; : &quot;edit&quot;, &quot;click a.destroy&quot; : &quot;clear&quot;, &quot;keypress .edit&quot; : &quot;updateOnEnter&quot;, &quot;blur .edit&quot; : &quot;close&quot; }, // The TodoView listens for changes to its model, re-rendering. Since there&apos;s // a one-to-one correspondence between a **Todo** and a **TodoView** in this // app, we set a direct reference on the model for convenience. initialize : function() { this.listenTo(this.model, &apos;change&apos;, this.render); this.listenTo(this.model, &apos;destroy&apos;, this.remove); }, // Re-render the titles of the todo item. render : function() { this.$el.html(this.template(this.model.toJSON())); this.$el.toggleClass(&apos;done&apos;, this.model.get(&apos;done&apos;)); this.input = this.$(&apos;.edit&apos;); return this; }, //...... // Remove the item, destroy the model. clear : function() { this.model.destroy(); } }); 上面这个例子是一个典型的“部件”视图，它对于界面上的已有元素没有依赖。也有那么一些视图，需要依赖于界面上的已有元素，比如下面这个，它通过el属性，指定了HTML中id为todoapp的元素，并且还在initialize方法中引用了另外一些元素，通常，需要直接放置到界面的顶层试图会采用这种方式，而“部件”视图一般由主视图来创建、布局。 // Our overall **AppView** is the top-level piece of UI. var AppView = Backbone.View.extend({ // Instead of generating a new element, bind to the existing skeleton of // the App already present in the HTML. el : $(&quot;#todoapp&quot;), // Our template for the line of statistics at the bottom of the app. statsTemplate : _.template($(&apos;#stats-template&apos;).html()), // Delegated events for creating new items, and clearing completed ones. events : { &quot;keypress #new-todo&quot; : &quot;createOnEnter&quot;, &quot;click #clear-completed&quot; : &quot;clearCompleted&quot;, &quot;click #toggle-all&quot; : &quot;toggleAllComplete&quot; }, // At initialization we bind to the relevant events on the `Todos` // collection, when items are added or changed. Kick things off by // loading any preexisting todos that might be saved in *localStorage*. initialize : function() { this.input = this.$(&quot;#new-todo&quot;); this.allCheckbox = this.$(&quot;#toggle-all&quot;)[0]; this.listenTo(Todos, &apos;add&apos;, this.addOne); this.listenTo(Todos, &apos;reset&apos;, this.addAll); this.listenTo(Todos, &apos;all&apos;, this.render); this.footer = this.$(&apos;footer&apos;); this.main = $(&apos;#main&apos;); Todos.fetch(); }, // Re-rendering the App just means refreshing the statistics -- the rest // of the app doesn&apos;t change. render : function() { var done = Todos.done().length; var remaining = Todos.remaining().length; if (Todos.length) { this.main.show(); this.footer.show(); this.footer.html(this.statsTemplate({ done : done, remaining : remaining })); } else { this.main.hide(); this.footer.hide(); } this.allCheckbox.checked = !remaining; }, //...... }); 对于AngularJS来说，基本不需要有额外的视图定义，它采用的是直接定义在HTML上的方式，比如： &lt;div ng-controller=&quot;TodoCtrl&quot;&gt; &lt;span&gt;{{remaining()}} of {{todos.length}} remaining&lt;/span&gt; &lt;a href=&quot;&quot; ng-click=&quot;archive()&quot;&gt;archive&lt;/a&gt; &lt;ul class=&quot;unstyled&quot;&gt; &lt;li ng-repeat=&quot;todo in todos&quot;&gt; &lt;input type=&quot;checkbox&quot; ng-model=&quot;todo.done&quot;&gt; &lt;span class=&quot;done-{{todo.done}}&quot;&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form ng-submit=&quot;addTodo()&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;todoText&quot; size=&quot;30&quot; placeholder=&quot;add new todo here&quot;&gt; &lt;input class=&quot;btn-primary&quot; type=&quot;submit&quot; value=&quot;add&quot;&gt; &lt;/form&gt; &lt;/div&gt; 在这个例子中，使用ng-controller注入了一个TodoCtrl的实例，然后，在TodoCtrl的$scope中附加的那些变量和方法都可以直接访问了。注意到其中的ng-repeat部分，它遍历了todos数组，然后使用其中的单个todo对象创建了一些HTML元素，把相应的值填到里面。这种做法和ng-model一样，都创造了双向绑定，即： 改变模型可以随时反映到界面上 在界面上做的操作（输入，选择等等）可以实时反映到模型里。 而且，这种绑定都会自动忽略其中可能因为空数据而引起的异常情况。 ##4. 模板 模板是这个时期一种很典型的解决方案。我们常常有这样的场景：在一个界面上重复展示类似的DOM片段，例如微博。以传统的开发方式，也可以轻松实现出来，比如： var feedsDiv = $(&quot;#feedsDiv&quot;); for (var i = 0; i &lt; 5; i++) { var feedDiv = $(&quot;&lt;div class=&apos;post&apos;&gt;&lt;/div&gt;&quot;); var authorDiv = $(&quot;&lt;div class=&apos;author&apos;&gt;&lt;/div&gt;&quot;); var authorLink = $(&quot;&lt;a&gt;&lt;/a&gt;&quot;) .attr(&quot;href&quot;, &quot;/user.html?user=&apos;&quot; + &quot;Test&quot; + &quot;&apos;&quot;) .html(&quot;@&quot; + &quot;Test&quot;) .appendTo(authorDiv); authorDiv.appendTo(feedDiv); var contentDiv = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;) .html(&quot;Hello, world!&quot;) .appendTo(feedDiv); var dateDiv = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;) .html(&quot;发布日期：&quot; + new Date().toString()) .appendTo(feedDiv); feedDiv.appendTo(feedsDiv); } 但是使用模板技术，这一切可以更加优雅，以常用的模板框架UnderScore为例，实现这段功能的代码为： var templateStr = &apos;&lt;div class=&quot;post&quot;&gt;&apos; +&apos;&lt;div class=&quot;author&quot;&gt;&apos; + &apos;&lt;a href=&quot;/user.html?user={{creatorName}}&quot;&gt;@{{creatorName}}&lt;/a&gt;&apos; +&apos;&lt;/div&gt;&apos; +&apos;&lt;div&gt;{{content}}&lt;/div&gt;&apos; +&apos;&lt;div&gt;{{postedDate}}&lt;/div&gt;&apos; +&apos;&lt;/div&gt;&apos;; var template = _.template(templateStr); template({ createName : &quot;Xufei&quot;, content: &quot;Hello, world&quot;, postedDate: new Date().toString() }); 也可以这么定义： &lt;script type=&quot;text/template&quot; id=&quot;feedTemplate&quot;&gt; &lt;% _.each(feeds, function (item) { %&gt; &lt;div class=&quot;post&quot;&gt; &lt;div class=&quot;author&quot;&gt; &lt;a href=&quot;/user.html?user=&lt;%= item.creatorName %&gt;&quot;&gt;@&lt;%= item.creatorName %&gt;&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;%= item.content %&gt;&lt;/div&gt; &lt;div&gt;&lt;%= item.postedData %&gt;&lt;/div&gt; &lt;/div&gt; &lt;% }); %&gt; &lt;/script&gt; &lt;script&gt; $(&apos;#feedsDiv&apos;).html( _.template($(&apos;#feedTemplate&apos;).html(), feeds)); &lt;/script&gt; 除此之外，UnderScore还提供了一些很方便的集合操作，使得模板的使用更加方便。如果你打算使用BackBone框架，并且需要用到模板功能，那么UnderScore是一个很好的选择，当然，也可以选用其它的模板库，比如Mustache等等。 如果使用AngularJS，可以不需要额外的模板库，它自身就提供了类似的功能，比如上面这个例子可以改写成这样： &lt;div class=&quot;post&quot; ng-repeat=&quot;post in feeds&quot;&gt; &lt;div class=&quot;author&quot;&gt; &lt;a ng-href=&quot;/user.html?user={{post.creatorName}}&quot;&gt;@{{post.creatorName}}&lt;/a&gt; &lt;/div&gt; &lt;div&gt;{{post.content}}&lt;/div&gt; &lt;div&gt; 发布日期：{{post.postedTime | date:'medium'}} &lt;/div&gt; &lt;/div&gt; 主流的模板技术都提供了一些特定的语法，有些功能很强。值得注意的是，他们虽然与JSP之类的代码写法类似甚至相同，但原理差别很大，这些模板框架都是在浏览器端执行的，不依赖任何服务端技术，即使界面文件是.html也可以，而传统比如JSP模板是需要后端支持的，执行时间是在服务端。 ##5. 路由 通常路由是定义在后端的，但是在这类MV*框架的帮助下，路由可以由前端来解析执行。比如下面这个Backbone的路由示例： var Workspace = Backbone.Router.extend({ routes: { &quot;help&quot;: &quot;help&quot;, // #help &quot;search/:query&quot;: &quot;search&quot;, // #search/kiwis &quot;search/:query/p:page&quot;: &quot;search&quot; // #search/kiwis/p7 }, help: function() { ... }, search: function(query, page) { ... } }); 在上述例子中，定义了一些路由的映射关系，那么，在实际访问的时候，如果在地址栏输入”#search/obama/p2”，就会匹配到”search/:query/p:page”这条路由，然后，把”obama”和”2”当作参数，传递给search方法。 AngularJS中定义路由的方式有些区别，它使用一个$routeProvider来提供路由的存取，每一个when表达式配置一条路由信息，otherwise配置默认路由，在配置路由的时候，可以指定一个额外的控制器，用于控制这条路由对应的html界面： app.config([&apos;$routeProvider&apos;, function($routeProvider) { $routeProvider.when(&apos;/phones&apos;, { templateUrl : &apos;partials/phone-list.html&apos;, controller : PhoneListCtrl }).when(&apos;/phones/:phoneId&apos;, { templateUrl : &apos;partials/phone-detail.html&apos;, controller : PhoneDetailCtrl }).otherwise({ redirectTo : &apos;/phones&apos; }); }]); 注意，在AngularJS中，路由的template并非一个完整的html文件，而是其中的一段，文件的头尾都可以不要，也可以不要那些包含的外部样式和JavaScript文件，这些在主界面中载入就可以了。 ##6. 自定义标签 用过XAML或者MXML的人一定会对其中的可扩充标签印象深刻，对于前端开发人员而言，基于标签的组件定义方式一定是优于其他任何方式的，看下面这段HTML： &lt;div&gt; &lt;input type=&quot;text&quot; value=&quot;hello, world&quot;/&gt; &lt;button&gt;test&lt;/button&gt; &lt;/div&gt; 即使是刚刚接触这种东西的新手，也能够理解它的意思，并且能够照着做出类似的东西，如果使用传统的面向对象语言去描述界面，效率远远没有这么高，这就是在界面开发领域，声明式编程比命令式编程适合的最重要原因。 但是，HTML的标签是有限的，如果我们需要的功能不在其中，怎么办？在开发过程中，我们可能需要一个选项卡的功能，但是，HTML里面不提供选项卡标签，所以，一般来说，会使用一些li元素和div的组合，加上一些css，来实现选项卡的效果，也有的框架使用JavaScript来完成这些功能。总的来说，这些代码都不够简洁直观。 如果能够有一种技术，能够提供类似这样的方式，该多么好呢？ &lt;tabs&gt; &lt;tab name=&quot;Tab 1&quot;&gt;content 1&lt;/tab&gt; &lt;tab name=&quot;Tab 2&quot;&gt;content 2&lt;/tab&gt; &lt;/tabs&gt; 回忆一下，我们在章节1.4 组件化的萌芽 里面，提到过一种叫做HTC的技术，这种技术提供了类似的功能，而且使用起来也比较简便，问题是，它属于一种正在消亡的技术，于是我们的目光投向了更为现代的前端世界，AngularJS拯救了我们。 在AngularJS的首页，可以看到这么一个区块“Create Components”，在它的演示代码里，能够看到类似的一段： &lt;tabs&gt; &lt;pane title=&quot;Localization&quot;&gt; ... &lt;/pane&gt; &lt;pane title=&quot;Pluralization&quot;&gt; ... &lt;/pane&gt; &lt;/tabs&gt; 那么，它是怎么做到的呢？秘密在这里： angular.module(&apos;components&apos;, []).directive(&apos;tabs&apos;, function() { return { restrict : &apos;E&apos;, transclude : true, scope : {}, controller : function($scope, $element) { var panes = $scope.panes = []; $scope.select = function(pane) { angular.forEach(panes, function(pane) { pane.selected = false; }); pane.selected = true; } this.addPane = function(pane) { if (panes.length == 0) $scope.select(pane); panes.push(pane); } }, template : &apos;&lt;div class=&quot;tabbable&quot;&gt;&apos; + &apos;&lt;ul class=&quot;nav nav-tabs&quot;&gt;&apos; + &apos;&lt;li ng-repeat=&quot;pane in panes&quot; ng-class=&quot;{active:pane.selected}&quot;&gt;&apos; + &apos;&lt;a href=&quot;&quot; ng-click=&quot;select(pane)&quot;&gt;{{pane.title}}&lt;/a&gt;&apos; + &apos;&lt;/li&gt;&apos; + &apos;&lt;/ul&gt;&apos; + &apos;&lt;div class=&quot;tab-content&quot; ng-transclude&gt;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos;, replace : true }; }).directive(&apos;pane&apos;, function() { return { require : &apos;^tabs&apos;, restrict : &apos;E&apos;, transclude : true, scope : { title : &apos;@&apos; }, link : function(scope, element, attrs, tabsCtrl) { tabsCtrl.addPane(scope); }, template : &apos;&lt;div class=&quot;tab-pane&quot; ng-class=&quot;{active: selected}&quot; ng-transclude&gt;&apos; + &apos;&lt;/div&gt;&apos;, replace : true }; }) 这段代码里，定义了tabs和pane两个标签，并且限定了pane标签不能脱离tabs而单独存在，tabs的controller定义了它的行为，两者的template定义了实际生成的html，通过这种方式，开发者可以扩展出自己需要的新元素，对于使用者而言，这不会增加任何额外的负担。 #四. 一些想说的话 ###关于ExtJS 注意到在本文中，并未提及这样一个比较流行的前端框架，主要是因为他自成一系，思路跟其他框架不同，所做的事情，层次介于文中的二和三之间，所以没有单独列出。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-07-10-从零开始编写自己的JavaScript框架（二）","date":"2019-04-14T09:10:49.489Z","updated":"2019-04-14T09:10:49.489Z","comments":true,"path":"2019/04/14/杂谈/2013-07-10-从零开始编写自己的JavaScript框架（二）/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2013-07-10-从零开始编写自己的JavaScript框架（二）/","excerpt":"从零开始编写自己的JavaScript框架（二）#2. 数据绑定 ##2.1 数据绑定的原理 数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。 在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。 先看数据到界面上的的绑定，比如： &lt;input vm-value=&quot;name&quot;/&gt; var person = { name: &quot;Tom&quot; }; 如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？","text":"从零开始编写自己的JavaScript框架（二）#2. 数据绑定 ##2.1 数据绑定的原理 数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。 在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。 先看数据到界面上的的绑定，比如： &lt;input vm-value=&quot;name&quot;/&gt; var person = { name: &quot;Tom&quot; }; 如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如： var person = { name: &quot;Tom&quot;, setName: function(newName) { this.name = newName; //do something } }; 这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做： var person = { name: &quot;Tom&quot;, gender: 5 set: function(key, value) { this[key] = value; //do something } }; 或者合并两个方法，只判断是否传了参数： Person.prototype.name = function(value) { if (arguments.length == 0) { return this._name; } else { this._name = value; } } 这种情况下，赋值的时候就是person.name(“Tom”)，取值的时候就是var name = person.name()了。 有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。 在C#等一些语言里，有一种东西叫做存取器，比如说： class Person { private string name; public string Name { get { return name; } set { name = value; } } } 用的时候，person.Name = “Jerry”，就会调用到set里，相当于是个方法。 这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说： var person = {}; // Add an accessor property to the object. Object.defineProperty(person, &quot;name&quot;, { set: function (value) { this._name = value; //do something }, get: function () { return this._name; }, enumerable: true, configurable: true }); 赋值的时候，person.name = “Tom”，取值的时候，var name = person.name，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。 现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。 再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。 ##2.2 数据绑定的实现 我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。 function parseElement(element) { for (var i=0; i&lt;element.attributes.length; i++) { parseAttribute(element.attributes[i]); } for (var i=0; i&lt;element.children.length; i++) { parseElement(element.children[i]); } } 但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？ 我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。 因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。 thin.define(&quot;Person&quot;, [], function() { function Person() { this.name = &quot;Tom&quot;; this.age = 5; } Person.prototype = { growUp: function() { this.age++; } }; return Person; }); 模型方面都准备好了，现在来看界面： &lt;div vm-model=&quot;Person&quot;&gt; &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt; &lt;/div&gt; 为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。 好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？ 当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样： function parseElement(element, vm) { var model = vm; if (element.getAttribute(&quot;vm-model&quot;)) { model = bindModel(element.getAttribute(&quot;vm-model&quot;)); } for (var i=0; i&lt;element.attributes.length; i++) { parseAttribute(element, element.attributes[i], model); } for (var i=0; i&lt;element.children.length; i++) { parseElement(element.children[i], model); } } 看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。 function bindModel(modelName) { thin.log(&quot;model&quot; + modelName); var model = thin.use(modelName, true); var instance = new model(); return instance; } 现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的： init，用于绑定初始化方法 click，用于绑定点击 value，绑定变量 enable和disable，绑定可用状态 visible和invisible，绑定可见状态 然后就可以实现我们parseAttribute函数了： function parseAttribute(element, attr, model) { if (attr.name.indexOf(&quot;vm-&quot;) == 0) { var type = attr.name.slice(3); switch (type) { case &quot;init&quot;: bindInit(element, attr.value, model); break; case &quot;value&quot;: bindValue(element, attr.value, model); break; case &quot;click&quot;: bindClick(element, attr.value, model); break; case &quot;enable&quot;: bindEnable(element, attr.value, model, true); break; case &quot;disable&quot;: bindEnable(element, attr.value, model, false); break; case &quot;visible&quot;: bindVisible(element, attr.value, model, true); break; case &quot;invisible&quot;: bindVisible(element, attr.value, model, false); break; case &quot;element&quot;: model[attr.value] = element; break; } } } 注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。 这么多绑定，不打算都讲，用bindValue函数来说明一下吧： function bindValue(element, key, vm) { thin.log(&quot;binding value: &quot; + key); vm.$watch(key, function (value, oldValue) { element.value = value || &quot;&quot;; }); element.onkeyup = function () { vm[key] = element.value; }; element.onpaste = function () { vm[key] = element.value; }; } 我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。 在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。 接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。 然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。 var Binder = { $watch: function (key, watcher) { if (!this.$watchers[key]) { this.$watchers[key] = { value: this[key], list: [] }; Object.defineProperty(this, key, { set: function (val) { var oldValue = this.$watchers[key].value; this.$watchers[key].value = val; for (var i = 0; i &lt; this.$watchers[key].list.length; i++) { this.$watchers[key].list[i](val, oldValue); } }, get: function () { return this.$watchers[key].value; } }); } this.$watchers[key].list.push(watcher); } }; 但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。 function bindModel(name) { thin.log(&quot;binding model: &quot; + name); var model = thin.use(name, true); var instance = new model().extend(Binder); instance.$watchers = {}; return instance; } 看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？ 先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。 同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。 嗯，我们是不是可以试一下了？来写个代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Simple binding demo&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;binding&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;xu.fei@outlook.com&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/thin.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div vm-model=&quot;test.Person&quot;&gt; &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt; &lt;/div&gt; &lt;div vm-model=&quot;test.Person&quot; vm-init=&quot;init&quot;&gt; &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; thin.define(&quot;test.Person&quot;, [], function () { function Person() { this.name = &quot;Tom&quot;; this.age = 5; } Person.prototype = { init: function () { this.name = &quot;Jerry&quot;; this.age = 3; }, growUp: function () { this.age++; } }; return Person; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 或者访问这里：http://xufei.github.io/thin/demo/simple-binding.html 以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。 我们还有一个更实际一点的例子，结合了另外一个系列里面写的简单DataGrid控件，做了一个很基础的人员管理界面：http://xufei.github.io/thin/demo/binding.html ##2.3 小结 到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-10-01-企业软件领域前端开发的困境","date":"2019-04-14T09:10:49.480Z","updated":"2019-04-14T09:10:49.480Z","comments":true,"path":"2019/04/14/杂谈/2013-10-01-企业软件领域前端开发的困境/","link":"","permalink":"https://qccs.github.io/2019/04/14/杂谈/2013-10-01-企业软件领域前端开发的困境/","excerpt":"企业软件领域前端开发的困境这个问题问得很有意思，在每个行业里，前端开发的侧重点是不一样的，重要性也有所不同，简单来说可以分为3个大类：互联网、企业应用、游戏，分别侧重于：交互、架构、算法。 在这三个大类里，互联网方向的前端开发最为正统，算是根正苗红，所以在这个领域的人，对标准研究得最为透彻，对交互理解得最为深刻，目前前端方向的高手大多集中在这个领域。这个领域的人最关注的问题是兼容性，对一些细节的优化把握得炉火纯青。因为这个领域的业务特点，前端做的事情过于扁平，整个可发挥的余地不够，虽然高手众多，但就像很多龙挤在浅水里，常常有无用武之地的感叹。刚才玉伯这篇文章，讲述的就是这个领域中前端的困惑。 企业应用方向的前端开发其实很多时候并不在意他们用的是Web还是其他类似技术，比如Flex，Silverlight等，对他们来说，即使是C/S的系统，也能够发挥出很大价值。这个领域的人最关注的问题是组件化和快速业务开发。","text":"企业软件领域前端开发的困境这个问题问得很有意思，在每个行业里，前端开发的侧重点是不一样的，重要性也有所不同，简单来说可以分为3个大类：互联网、企业应用、游戏，分别侧重于：交互、架构、算法。 在这三个大类里，互联网方向的前端开发最为正统，算是根正苗红，所以在这个领域的人，对标准研究得最为透彻，对交互理解得最为深刻，目前前端方向的高手大多集中在这个领域。这个领域的人最关注的问题是兼容性，对一些细节的优化把握得炉火纯青。因为这个领域的业务特点，前端做的事情过于扁平，整个可发挥的余地不够，虽然高手众多，但就像很多龙挤在浅水里，常常有无用武之地的感叹。刚才玉伯这篇文章，讲述的就是这个领域中前端的困惑。 企业应用方向的前端开发其实很多时候并不在意他们用的是Web还是其他类似技术，比如Flex，Silverlight等，对他们来说，即使是C/S的系统，也能够发挥出很大价值。这个领域的人最关注的问题是组件化和快速业务开发。从企业软件的方向来说，它的业务是很丰富的，对各种前端技术的应用也都很广泛，一个大型的企业应用，几乎什么特性都能用上。相对于互联网系统，它的客户相对比较专业，可以排除一些低端过时的浏览器，所以少了很多兼容的负担，在框架选型上，也可以接受很复杂的框架，比如ExtJS、AngularJS等，因为他们的业务特性，往往需要很复杂框架的支持。 用我所在的电信行业软件举例，业务复杂度非常高，一套全业务系统会有两千左右的数据库表，两千个左右的业务菜单，其中有些业务界面的复杂度非常惊人，而且经常会根据需求有较大变动，性能也有较高要求。 理论上来说，前端在这个领域可以领悟到很多事情，但这个领域有个最大的问题，盈利太低，不足以支撑很深入的研究，另一个无奈的问题是，由于历史原因，前端开发人员在这个领域并不容易受到重视，比如说资深技术人员多数是做后端开发的，认为前端很小儿科，在应届生入职筛选的时候，也会把能力较高的弄去做后端开发，剩下的留给前端。这些原因，造成了企业应用的前端领域就像一个又大又深的湖，里面小鱼小虾众多，却很少有大鱼。 我在企业软件前端开发做了很多年，经常思考其中的一些问题，在这个领域做，总是有一种寂寞的感觉。我们这种行业，为了保证交付的及时，倾向于划分业务开发和技术平台开发，业务开发人员并不在难解决的问题上花时间，遇到问题的时候向技术平台团队寻求支持，把问题转移给更专业的人，避免耽误自己的交付时间，在他们开工之前，也由技术平台团队预先搭建框架，他们直接在这个上面以固定的模式进行开发。两个团队，前者的特点是多而泛，后者的特点是少而精。 这么做，效率比较高，但带来一个问题，业务开发团队的技术水平很难提升，因为他总是忙碌赶工，很少有时间去思考很多问题的前因后果，即使你帮他解决了问题，告诉他，他也不一定有心情去关注一遍，因为他确实很忙。可能有些有激情的人会自己花点时间研究一下，但多数人很难有这样的心境。 这就造成了业务开发团队和平台开发团队的技术实力严重脱节。从另外一个角度看，技术平台团队长期专门给别人解决问题，自己却很少全职参与某个业务项目的开发，他也很难有成就感。这还不是最大的问题，最大问题是，不管从哪个团队，都很难成长出能够设计最适合这些业务的前端架构的人，这恰恰是这个领域前端开发最重要的部分。 当出现各种新技术的时候，平台团队比较容易去快速跟进，但投入通常不会很大，当取得一些进展的时候，会逐步向业务开发团队推广，但这个推广的难度是很大的，因为人数的比例会比较大，当技术从一个人向三个人推进的时候，是相对还算容易的，如果从一个向十个或者二十个人去推进，难度就大多了。而由于传统企业盈利规模的限制，没办法在每个技术方向都有较大投入，所以往往就是一两个人去折腾，他们在探索的过程中遇到问题，是很难找到能够交流的人的，如果自己解决不了问题，就会持续苦闷，非常寂寞。前端这个领域更是如此，现在客户端技术这么多，各种终端，各种浏览器，各种前端框架，每个上面投入一个人，就已经是个很大团队了，这种模式很明显就碰到瓶颈了，因为它很直接地跟人员编制产生了冲突。扩编直接对利润产生冲击，但是不扩编的话，技术平台团队的压力就会进一步加大，除了要探索新技术，还要对越来越庞大的业务开发团队作技术支持，每个人都痛不欲生。 这种困境怎么解决呢，我想了很久，无计可施，也许，是时候要效仿互联网企业的开发模式了？但是积重难返，而且传统企业招聘的门槛远比互联网企业低，人员的能力有差距，也很难有互联网企业那么蓬勃而广泛的技术研究气氛，可能就更难做下去了。 可能这个领域的出路是寻找更为简单快速的开发方式，并且把相关的外围工具也做大做强，在业务领域中，把组件也积累沉淀出来，这时候能够用更少的业务开发人员来实现同等规模的系统，把更多人力节约出来做技术探索和改进吧？","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-01-20-为什么企业应用这么“钟情”于IE6","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2014-01-20-为什么企业应用这么“钟情”于IE6/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2014-01-20-为什么企业应用这么“钟情”于IE6/","excerpt":"为什么企业应用这么“钟情”于IE6企业内部的信息化，很多起步都很早，但B/S化基本都是从2000年以后开始的，之前有各种客户端，比如基本的Win32 API开发，或者Delphi体系（VCL等，C++ Builder也算在内），微软的几个封装化的体系（ATL，MFC，还有昙花一现的JFC），Java体系（AWT、Swing，SWT等），这些技术本身都比较成熟，IDE的支持也不错，但最终，很大一部分迁移到Web上了。 迁移到Web的最直接因素是部署成本，B/S架构有天然的部署优势，无需分发，这一点人所共知，但另外还有个重要因素是开发成本。很多人对这一点不相信，为什么呢，因为现在前端码农也不便宜啊，怎么就他降低开发成本了？","text":"为什么企业应用这么“钟情”于IE6企业内部的信息化，很多起步都很早，但B/S化基本都是从2000年以后开始的，之前有各种客户端，比如基本的Win32 API开发，或者Delphi体系（VCL等，C++ Builder也算在内），微软的几个封装化的体系（ATL，MFC，还有昙花一现的JFC），Java体系（AWT、Swing，SWT等），这些技术本身都比较成熟，IDE的支持也不错，但最终，很大一部分迁移到Web上了。 迁移到Web的最直接因素是部署成本，B/S架构有天然的部署优势，无需分发，这一点人所共知，但另外还有个重要因素是开发成本。很多人对这一点不相信，为什么呢，因为现在前端码农也不便宜啊，怎么就他降低开发成本了？早期的Web界面并不花哨，所以对一些技巧的要求远不如现在高，而且只存在一个主流浏览器（IE6），更是无需更多的知识，逻辑基本都放在后端，前端要做的事情基本只有写表单和表格类的HTML，从这个角度看，门槛确实低得可以，写标签的难度远远低于用高级语言写界面。 在这种情况下，大量的表单类应用就被迁移到B/S模式了，其中有时候会出现复杂一些的需求，比如流程的建模，在对VML不熟悉的情况下，很多这种东西会被开发成一个独立的客户端，跟B/S系统连到同样的数据库，变通解决这个问题。但其实在IE6里面，VML本身已经非常可用了，所以这时候也有很多图形化的东西用VML做，比如我自己05年写的这个，抓了个录像在这里：http://xufei.github.io/assets/iom.swf 作为企业应用，另有个重要的事情就是代码的组件化复用，比如说，上面我这个录像里面的树型结构和选项卡，其实给开发人员用的时候很简单： &lt;z:tree id=&quot;tacheTree&quot;&gt;&lt;/z:tree&gt; document.getElementById(&quot;tacheTree&quot;).loadXML(xml); 这两句分别是界面中的声明跟JS代码中的调用，为什么可以这么写呢，是因为IE中有HTC（HTML Component），可以自己用HTML和JS定义标签，只需要用命名空间引入就可以。这个其实是非常有用的功能，一般的企业都必定会在此基础上有所积累，即使现在的Web Components，也没有比它高端到哪里去。 以上这些是从开发视角看的，作为一个运行平台来说，IE6已经非常足够，布局有些小问题，大家其实无所谓，用点技巧也可以摆得比较整齐。如果有大模块的集成，就来个iframe，也都工作得很好。 我们再来看看为什么很多企业软件固守IE体系。提到企业软件，大家经常有个误会，认为企业软件的前端就都是照着IE6来开发的，其实不是这样，企业软件产品是有延续性的，在已有产品上做升级的代价非常大，比如说一套很深入使用了IE only特性的系统，想要迁移到跨浏览器上，这个代价有多大？首先要构建同等复杂度的控件库，然后把功能逐个迁移，最后还要考虑一些已经被废弃了但是暂时没有替代方案的东西，整个过程是非常痛苦的。 很多时候，并不是开发人员意识不到这些问题，而是他没有解决办法。技术上的困难，经过一些努力都是可以克服的，更大的困难在于软件升级的成本。比如说，你评估了把代码修改成跨浏览器，需要50个人做一年，谁为这个过程买单？如果你站在企业决策者的角度，是会搞50个人来做一年，还是让你的2000个员工都稍微克服一下，只使用IE来访问系统？ 即使你说这次升级完了就解决了现在的跨浏览器问题，如何确保以后再出个什么浏览器也能支持？如何保证再也不会伤筋动骨地修改代码？谁也说不准未来是什么样，所以，他只有到了不得不升级的时候，才会考虑做这件事。会是现在吗？不一定，因为即使很新版本的IE，也还有兼容模式，他只要还能用下去，就不太有动力去折腾。 那么，我们再看看企业软件开发商是如何处理这个问题的。毫无疑问，企业软件开发商是希望你每年都升级的，因为传统的软件都是一次买断，然后收点维护费，客户是卖一个少一个，但你想升级，那就得交钱，谁会跟钱过不去呢？从这些企业长久的发展来说，它也会让自己的产品逐步去贴近标准，老的产品就这样了，你总不能现在开发个东西还说IE only吧，那估计都不好意思拿出去卖。所以说，这类企业在开发新系统的时候，反而会采用更激进的策略，比如说我就从某个基线往上支持，IE10+，Chrome 27+之类。在江苏电信的CRM系统里，从2011年开始就是推荐客户使用Firefox来访问系统的，大家去电信营业厅办业务，可以观察一下营业员使用的浏览器，其实在很多方面，传统软件厂商也不像外界猜测的那么固步自封。 很多时候，从企业软件开发商的角度看，新的浏览器标准并未带来多少比IE6为代表的“低端浏览器”更有价值的特性，SVG取代了VML，Web Components取代了HTML Components，多了一些储存、文件之类的本地接口，还有摄像头之类偶尔用得上的东西，之前大家用Flash的Socket，现在变成WebSocket，该XMLHTTP的还是XMLHTTP。HTML5体系中提升最大的标签语义化、布局和样式等在这个领域带来的震撼并不强烈，最有价值的反倒是JS性能上的大幅提升。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-11-20-Web应用的组件化开发（一）","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2013-11-20-Web应用的组件化开发（一）/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2013-11-20-Web应用的组件化开发（一）/","excerpt":"Web应用的组件化开发（一）基本思路#1. 为什么要做组件化？ 无论前端也好，后端也好，都是整个软件体系的一部分。软件产品也是产品，它的研发过程也必然是有其目的。绝大多数软件产品是追逐利润的，在产品目标确定的情况下，成本有两个途径来优化：减少部署成本，提高开发效率。 减少部署成本的方面，业界研究得非常多，比如近几年很流行的“去IOE”，就是很典型的，从一些费用较高的高性能产品迁移到开源的易替换的产品集群，又比如使用Linux + Mono来部署.net应用，避开Windows Server的费用。 提高开发效率这方面，业界研究得更多，主要途径有两点：加快开发速度，减少变更代价。怎样才能加快开发速度呢？如果我们的开发不是重新造轮子，而是每一次做新产品都可以利用已有的东西，那就会好很多。怎样才能减少变更代价呢？如果我们能够理清模块之间的关系，合理分层，每次变更只需要修改其中某个部分，甚至不需要修改代码，仅仅是改变配置就可以，那就更好了。","text":"Web应用的组件化开发（一）基本思路#1. 为什么要做组件化？ 无论前端也好，后端也好，都是整个软件体系的一部分。软件产品也是产品，它的研发过程也必然是有其目的。绝大多数软件产品是追逐利润的，在产品目标确定的情况下，成本有两个途径来优化：减少部署成本，提高开发效率。 减少部署成本的方面，业界研究得非常多，比如近几年很流行的“去IOE”，就是很典型的，从一些费用较高的高性能产品迁移到开源的易替换的产品集群，又比如使用Linux + Mono来部署.net应用，避开Windows Server的费用。 提高开发效率这方面，业界研究得更多，主要途径有两点：加快开发速度，减少变更代价。怎样才能加快开发速度呢？如果我们的开发不是重新造轮子，而是每一次做新产品都可以利用已有的东西，那就会好很多。怎样才能减少变更代价呢？如果我们能够理清模块之间的关系，合理分层，每次变更只需要修改其中某个部分，甚至不需要修改代码，仅仅是改变配置就可以，那就更好了。我们先不看软件行业，来看一下制造行业，比如汽车制造业，他们是怎么造汽车的呢？造汽车之前，先设计，把整个汽车分解为不同部件，比如轮子，引擎，车门，座椅等等，分别生产，最后再组装，所以它的制造过程可以较快。如果一辆汽车轮胎被扎破了，需要送去维修，维修的人也没有在每个地方都修一下，而是只把轮胎拆下来修修就好了，这个轮胎要是实在坏得厉害，就干脆换上个新的，整个过程不需要很多时间。 席德梅尔出过一款很不错的游戏，叫做《文明》（Civilization），在第三代里面，有一项科技研究成功之后，会让工人工作效率加倍，这项科技的名字就叫做：可替换部件（Replacement Parts）。所以，软件行业也应当引入可替换的部件，一般称为组件。 #2. 早期的前端怎么做组件化的？ 在服务端，我们有很多组件化的途径，像J2EE的Beans就是一种。组件建造完成之后，需要引入一些机制来让它们可配置，比如说，工作流引擎，规则引擎，这些引擎用配置的方式组织最基础的组件，把它们串联为业务流程。不管使用什么技术、什么语言，服务端的组件化思路基本没有本质差别，大家是有共识的，具体会有服务、流程、规则、模型等几个层次。 早期展示层基本以静态为主，服务端把界面生成好，浏览器去拿来展示，所以这个时期，有代码控制的东西几乎全在服务端，有分层的，也有不分的。如果做了分层，大致结构就是下图这样： 这个图里，JSP（或者其他什么P，为了举例方便，本文中相关的服务端技术都用Java系的来表示）响应浏览器端的请求，把HTML生成出来，跟相关的JavaScript和CSS一起拿出去展示。注意这里的关键，浏览器端对界面的形态和相关业务逻辑基本都没有控制权，属于别人给什么就展示什么，想要什么要先提申请的尴尬局面。 这个时期的Web开发，前端的逻辑是基本可忽略的，所以前端组件化方式大同小异，无论是ASP还是JSP还是其他什么P，都可以自定义标签，把HTML代码和行间逻辑打包成一个标签，然后使用者直接放置在想要的地方，就可以了。 在这一时代，所谓的组件化，基本都是taglib这样的思路，把某一块界面包括它的业务逻辑一起打成一个端到端的组件，整个非常独立，直接一大块从界面到逻辑都有，而且逻辑基本上都是在服务端控制，大致结构如下图所示。 #3. SPA时代，出现了新问题 自从Web2.0逐渐流行，Web前端已经不再是纯展示了，它逐渐把以前在C/S里面做的一些东西做到B/S里面来，比如说Google和微软的在线Office，这种复杂度的Web应用如果还用传统那种方式做组件化，很显然是行不通的。 我们看看之前这种组件化的方式，本质是什么？是展现层跟业务逻辑层的隔离，后端在处理业务逻辑，前端纯展现。如果现在还这么划分，就变成了前端有界面和逻辑，后端也有逻辑，这就比较乱了。我们知道，纯逻辑的分层组件化还是比较容易的，任何逻辑如果跟展现混起来，就比较麻烦了，所以我们要把分层的点往前推，推到也能把单独的展现层剥离出来。 如下图所示，因为实际上HTML、CSS、JavaScript这些都逐渐静态化，所以不再需要把它们放在应用服务器上了，我们可以把它们放在专门的高性能静态服务器上，再进一步发展，就可以是CDN（Content Delivery Network，内容分发网络）。前端跟后端的通信，基本都是通过AJAX来，也会有一些其他的比如WebSocket之类，总之尽量少刷新了。 在这张图里面可以看到，真正的前端已经形成了，它跟应用服务器之间形成了天然的隔离，所以也能够很独立地进行一些发展演进。 现在很多Web程序在往SPA（单页面程序，Single Page Application）的方向发展，这类系统通常比较类似传统的C/S程序，交互过程比较复杂，因此它的开发过程也会遇到一些困难。 那为什么大家要做SPA呢？它有很多明显的好处，最核心的优势就是高效。这个高效体现在两个方面：一是对于用户来说，这种方式做出来的东西体验较好，类似传统桌面程序，对于那些需要频繁操作的行业用户，有很大优势。二是运行的效率较高，之前集成一些菜单功能，可能要用iframe的方式引入，但每个iframe要独立引入一些公共文件，服务器文件传输的压力较大，还要初始化自己的一套内存环境，比较浪费，互相之间也不太方便通信，一般要通过postMessage之类的方式去交互。 有了SPA之后，比如一块界面，就可以是一个HTML片段，用AJAX去加载过来处理之后放到界面上。如果有逻辑的JavaScript代码，也可以用require之类的异步加载机制去运行时加载，整体的思路是比较好的。 很多人说，就以这样的需求，用jQuery再加一个异步js加载框架，不是很足够了吗？这两个东西用得好的话，也是能够解决一些问题的，但它们处理的并不是最关键的事情。在Web体系中，展现层是很天然的，因为就是HTML和CSS，如果只从文件隔离的角度，也可以做出一种划分的方式，逻辑放在单独的js文件里，html内部尽量不写js，这就是之前比较主流的前端代码划分方式。 刚才我们提到，SPA开发的过程中会遇到一些困难，这些困难是因为复杂度大为提升，导致了一些问题，有人把这些困难归结为纯界面的复杂度，比如说，控件更复杂了之类，没有这么简单。问题在于什么呢？我打个比方：我们在电脑上开两个资源管理器窗口，浏览到同一个目录，在一个目录里把某个文件删了，你猜猜另外一个里面会不会刷新？ 毫无疑问，也会刷新，但是你看看你用的Web页面，如果把整个复杂系统整合成单页的，能保证对一个数据的更新就实时反馈到所有用它的地方吗？怎么做，是不是很头疼？代码组织的复杂度大为提高，所以需要做一些架构方面的提升。 #4. 架构的变更 提到架构，我们通常会往设计模式上想。在著名的《设计模式》一书中，刚开始就讲了一种典型的处理客户端开发的场景，那就是MVC。 传统的MVC理念我们并不陌生，因为有Struts，所以在Web领域也有比较经典的MVC架构，这里面的V，就负责了整个前端的渲染，而且是服务端的渲染，也就是输出HTML。如下图所示： 在SPA时代，这已经不合适了，所以浏览器端形成了自己的MVC等层次，这里的V已经变成客户端渲染了，通常会使用一些客户端的HTML模版去实现，而模型和控制器，也相应地在浏览器端形成了。 我们有很多这个层面的框架，比如Backbone，Knockout，Avalon，Angular等，采用了不同的设计思想，有的是MVC，有的是MVP，有的是MVVM，各有其特点。 以Angular为例，它推荐使用双向绑定去实现视图和模型的关联，这么一来，如果不同视图绑定在同一模型上，就解决了刚才所说的问题。而模型本身也通过某种机制，跟其他的逻辑模块进行协作。 这种方式就是依赖注入。依赖注入的核心理念就是通过配置来实例化所依赖的组件。使用这种模式来设计软件架构，会牺牲一些性能，在跟踪调试的便利性等方面也会有所损失，但换来的是无与伦比的松耦合和可替代性。 比如说，这些组件就可以单独测试，然后在用的时候随手引入，毫无压力。对于从事某一领域的企业来说，光这一条就足以吸引他在上面大量投入，把所有不常变动领域模型的业务代码都用此类办法维护起来，这是一种财富。 #5. MV*框架的基本原理 如果我们来设计Angular这么一个前端框架，应当如何入手呢？很显然，逻辑的控制必须使用JavaScript，一个框架，最本质的事情在于它的逻辑处理方式。 我们的界面为什么可以多姿多彩？因为有HTML和CSS，注意到这两种东西都是配置式的写法，参照后端的依赖注入，如果把这两者视为跟Spring框架中一些XML等同的配置文件，思路就豁然开朗了。 与后端不同的是，充当前端逻辑工具的JavaScript不能做入口，必须挂在HTML里才能运行，所以出现了一个怪异的状况：逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者Hybird的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。好消息是，过了这一步，逻辑层就开始大放异彩了。 从这个时候开始，框架就启动了，它要做哪些事情呢？ 初始化自身（bootstrap） 异步加载可能尚未引入的JavaScript代码（require） 解析定义在HTML上的规则（template parser） 实例化模型（scope） 创建模型和DOM的关联关系（binding, injection） 这些是主线流程，还有一些支线，比如： 解析url的search字符串，恢复状态（route） 加载HTML部件模板（template url） 部件模板和模型的关联（binding） #6. 如何做组件化 ##6.1. HTML的组件化 SPA的一个典型特征就是部分加载，界面的部件化也是其中比较重要的一环。界面片段在动态请求得到之后，借助模版引擎之类的技术，经过某种转换，放置到主界面相应的地方。所以，从这个角度来看，HTML的组件化非常容易理解，那就是界面的片段化和模板化。 ##6.2. JavaScript的组件化 JavaScript这个部分有好几个发展阶段。 早期的共享文件，把公共功能的代码提出出来，多个页面共用 动态引用，消灭全局变量 在某些框架上进一步划分，比如Angular里面又分为provider，service，factory，controller JavaScript组件化的目标是什么呢，是清晰的职责，松耦合，便于单元测试和重复利用。这里的松耦合不仅体现在js代码之间，也体现在js跟DOM之间的关系，所以像Angular这样的框架会有directive的概念，把DOM操作限制到这类代码中，其他任何js代码不操作DOM。 如上图所示，总的原则是先分层次，层内再作切分。这么做的话，不再存在之前那种端到端组件了，使用起来没有原先那么方便，但在另外很多方面比较好。 ##6.3. CSS的组件化 这方面，业界也有很多探索，比如LESS，SASS，Stylus等。为什么CSS也要做组件化呢？传统的CSS是一种扁平的文本结构，变更成本较高，比如说想要把结构从松散改紧凑，需要改动很多。如果把实际使用的CSS只当作输出结果，而另外有一种适合变更的方式当作中间过程，这就好多了。比如说，我们把一些东西定义成变量，每个细节元素使用这些变量，当需要整体变更的时候，只需修改这些变量然后重新生成一下就可以了。 以上，我们讨论了大致的Web前端开发的组件化思路，后续将阐述组件化之后的协作过程和管控机制。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-04-27-基于AngularJS的企业软件前端架构","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2014-04-27-基于AngularJS的企业软件前端架构/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2014-04-27-基于AngularJS的企业软件前端架构/","excerpt":"基于AngularJS的企业软件前端架构这篇是我参加QCon北京2014的演讲内容： 提纲：企业应用在软件行业中占有很大的比重，而这类软件多数现在也都采用B/S的模式开发，在这个日新月异的时代，它们的前端开发技术找到了什么改进点呢？ B/S企业软件前端开发模式大体上与桌面软件类似，都是偏重量级的，在前端可能会有较多的业务逻辑，这些业务逻辑如何被合理模块化，与界面分离，以便测试，成为这个领域的一个重要挑战。另一方面，由于企业应用的界面相对规整，偏重的是数据存取，没有太多花哨的东西，所以常见的界面控件也是可枚举的，如何让开发界面的工作能更快完成，甚至由不擅长编写代码的业务设计人员来做，与界面原型的工作合二为一，能提高不少开发效率。 在AngularJS等MV*框架出现之后，给这个领域带来一些契机，架构师们能够有机会去重新规划前端的架构，甚至是开发流程，从而让整个软件的生产更为高效。 本文将探讨它给这个领域带来的变化。","text":"基于AngularJS的企业软件前端架构这篇是我参加QCon北京2014的演讲内容： 提纲：企业应用在软件行业中占有很大的比重，而这类软件多数现在也都采用B/S的模式开发，在这个日新月异的时代，它们的前端开发技术找到了什么改进点呢？ B/S企业软件前端开发模式大体上与桌面软件类似，都是偏重量级的，在前端可能会有较多的业务逻辑，这些业务逻辑如何被合理模块化，与界面分离，以便测试，成为这个领域的一个重要挑战。另一方面，由于企业应用的界面相对规整，偏重的是数据存取，没有太多花哨的东西，所以常见的界面控件也是可枚举的，如何让开发界面的工作能更快完成，甚至由不擅长编写代码的业务设计人员来做，与界面原型的工作合二为一，能提高不少开发效率。 在AngularJS等MV*框架出现之后，给这个领域带来一些契机，架构师们能够有机会去重新规划前端的架构，甚至是开发流程，从而让整个软件的生产更为高效。 本文将探讨它给这个领域带来的变化。 正文：企业应用前端的特点企业应用系统是一种很常见的软件系统，这类系统的特点是面向某个行业，功能较复杂，对界面的要求一般是整齐，不追求花哨。这类系统通常有C/S和B/S两个流派，其中的B/S方式因为部署和集成的便利，使用得较为普遍。 同样是在浏览器中做东西，写企业应用和网站的差别也很明显。企业应用的业务逻辑较重，前端有一定的厚重性，但是对效果并不追求很多，主要是各类控件的使用，表单的存取值等等。 企业应用产品的一些特点如下： 独占模式。 一般用户使用互联网产品，都是片段时间使用，比如购物或者阅读，做完之后就刷新或者关闭浏览器了，而企业应用往往是工作的全部，从早上上班开始打开，到下班才关掉，一天绝大部分工作都在上面完成，比如一个呼叫中心的操作员。 重业务，轻视觉 企业应用对视觉的追求是比较低的，一般不会要求花哨效果，以业务操作的流畅性为第一目标。 界面规整，模式单一 企业应用的界面布局相对有模式可循，可以用很少的场景来穷举，界面横平竖直，比较规整，使用到的控件元素也是可穷举的，基本没有什么特效。 键盘操作 由于企业应用的用户都相对比较专业，在上岗之前需要经过统一培训，而且每个用户使用的频度较高，很多时候他们会用尽量快捷的方式来做操作，比如键盘，这一点在互联网产品中比较少见。所以，有时候大家为了追求好看，把系统原生的select用div来替换，在这种情况下反而增加了用户的麻烦。 逻辑复杂 我之前所在的行业中，业务逻辑很复杂，前端可能会需要写很多复杂的逻辑，JS代码大部分是在处理逻辑，而不是界面交互。 加载速度的侧重不同 互联网产品往往很重视首屏优化，但是其策略可能与企业应用不同。比如说，3个200k的模块，在网站型产品中可能优化成一个100k加三个150k的模块，但在企业应用中，很可能优化成一个400k加三个50k的模块。为什么会这样呢？因为内容型的网站讲究的优化策略是分摊，如果首次加载太慢，会很影响用户的信心，但企业应用用户的容忍度是较高的，他并不在乎刚打开的时候慢一些，因为打开了之后就要用一天，对于之后每步操作的模块加载速度倒是要求很高。另外，对于内存泄露的处理，也要求得比较高一些。整个这些策略，其实是来源于C/S系统的影响。 浏览器版本相对宽松 很多时候提到企业应用，大家的想法就是低端，IE6，但其实这个的原因是客户只购买软件，运维一般自己做，每年不会有很多持续的投入来改进，所以导致很多老系统不能持续升级。软件厂商其实反倒可以用更激进的策略去升级浏览器，用户对这个的接受度还是比较高的，使用系统的群体也是比互联网用户小很多的，抛弃老旧浏览器的事情也确实可以干，比如我就见过几年前某电信营业系统预装的都是Firefox。 企业应用常见的前端框架在开发B/S企业应用前端的人群中，有很大一部分群体选择了服务端的组件化方式，比如JSF之类，它的弊端是与异构服务端的第三方系统集成比较麻烦。也有不少人使用Bindows和ExtJS这样的框架，最近的KendoUI也是个不错的选择。 每种类型选一个有代表性的来说说： HTC 在浏览器端扩展标签 早期有些团队采用的方式，一般会跟XMLHTTP等结合使用，易于使用，界面代码整洁，但已被主流浏览器抛弃。 JSF等 在服务端生成界面 以后端为主的架构师最推崇的方式，受Struts的MVC模型影响很深，弱化了前端，使得前端蜕化为后端的一种附属。 GWT 编译阶段生成界面 写其他语言来生成HTML和JS，一般会依赖于一种前端UI库。这种方式也比较受后端架构师喜欢，因为他们觉得写JS很头疼，宁可写Java。 ExtJS 用JS封装界面组件，干脆就不要HTML了 这是另外一种极端，从Bindows开始，使用纯逻辑代码来描述界面，走着跟Java Swing一样的道路，也有不少人喜欢。但这种方式在没有好用的界面设计器的情况下非常痛苦。 Flex等 脱离HTML体系，另辟蹊径 这条路其实是对Java Applet的一种延续，好处是可以不受HTML体系的制约，独立发展，所以其实这些体系在企业应用领域的成熟度远超HTML体系。 曾经的企业B/S应用几件宝有一段时间，我们几乎只有IE6，所以那个时候的前端开发人员很快乐，没有兼容的压力。那时候，我们如何构建前端应用呢？ 参见http://weibo.com/1858846672/B1fL3vuYN?mod=weibotime HTC 这是最好用的声明控件的方式。 XMLHTTP 尽管还没有AJAX的概念，但我们已经可以用它做前后端分离的传输机制了。 VML 在IE里面画矢量图，不使用插件，有其他选择吗？ XSLT 把XML数据转换成HTML，跟现在的前端模板像吗？ popup 创建右键菜单最好的方式。 用这些技术构建的一个典型企业应用 单页应用和前端分层当时这些系统的构建方式也可以算单页应用，我们用iframe来集成菜单，每个菜单有自己独立的功能，整个主界面是始终不会刷新的。 时光飞逝，这些年，前端有了什么本质的改变，产生了翻天覆地的变化吗？ 有时候我们回顾一下，却发现多数都是在增加完善一些细节，真正有颠覆性的有比如以RequireJS和SeaJS为代表的模块定义和加载库，npm这样的包管理器，grunt，gulp，百度fis这样的集成开发模式。为什么它们算是本质改进呢？ 因为这些标志着前端开发从粗放的模式，逐渐变化到精确控制的形态。比如我们再也不能不管代码的依赖关系，也不能一打开界面就不分青红皂白把所有可能要用到的代码都立刻加载过来，那个时代已经过去了，从任何角度讲，现代的前端开发都在精细化，从代码的可控，到界面体验的精细优化，到整个团队甚至公司甚至互联网上的组件共享，以及前端团队协作流程的改进，这已经是一个很成规模的产业了。 我们把眼光放到2013年，在这一年里最火的前端技术莫过于NodeJS和AngularJS，前者给我们带来的是一种开发方式的改变，后者是一种典型的前端分层方案。Angular是前端MV*框架的一个流派，用过的人都会觉得很爽。它爽在什么地方呢？因为它帮我们做的事情太多了，一个双向绑定，无所不包，凡是存取值相关的操作，基本都不用自己写代码。在企业应用前端功能里，表单的存取值和校验占据了很大的比例，这些事都不用干了，那简直太好了。 如果就因为这个用Angular，那还有些早。有一些第三方代码被称为库，另外一些称为框架，Angular是框架而不是库。框架的含义是，有更强的约束性，并非作为辅助功能来提供的。 先看一下企业应用的通常形态吧，会有一个可配置的菜单，然后多半会采用MDI的形式，能打开多个业务功能，用选项卡的形式展示起来，可以随时切换操作。每个人每天常用的功能是可以穷举的，他进入系统之后，一般要用到下班才关掉。所以这种系统非常适合做成单页应用，开始的时候加载一个总体框架，每点击一个菜单，就加载这个菜单对应的功能模块，放在一个新的选项卡或者别的什么地方展示出来。 在早期做这种系统的时候，一般都会用iframe来集成菜单，这种方式很方便，但是每个菜单页都要载入共同的框架文件，初始化一个环境，数据之间也不能精确共用。 所以现在我们做企业信息系统，不再适合用iframe来集成菜单，所有菜单的业务代码，会在同一个页面的作用域中共存。这在某些方面是便利，比如数据的共享，一个选择全国城市的下拉框，在多个功能中都存在，意味着这些城市的数据我们可以只加载一次。但从另外一个角度来说，也是一种挑战，因为数据之间产生干扰的可能性大大增加了。 我们回顾一下在传统的客户端开发中是怎么做的，早在经典的《设计模式》一书中，就提到了MVC模式，这是一种典型的分层模式。长期以来，在Web开发人员心中的MVC，指的都是Struts框架的那张图，但我们单页应用中的MVC，其实更接近最原始的《设计模式》书中概念。所以我们要在前端分层，而不仅仅把整个前端都推到视图层。 做单页应用，前端不分层是很难办的，当规模扩大的时候，很难处理其中一些隐患。分层更重要的好处是能够从全盘考虑一些东西，比如说数据的共享。跨模块的数据共享是一个比较复杂的话题，搞得不好就会导致不一致的情况，如果考虑到在分层的情况下，把各种数据来源都统一维护，就好办多了。 所以，以AngularJS为代表的前端MV*框架最重要的工作就是做了这些对于分层的指导和约束性工作，在此基础上，我们可以进一步优化单页应用这类产品。 前端的自定义标签体系构建一个大型企业应用，最重要的是建立整套组件体系。一般针对某行业的软件，长期下来都会有很多固定的模式，可以提炼成组件和规则，从前端来看，体现为控件库和前端逻辑。控件库这个是老生常谈，在很多框架里都有这个概念，但各自对应的机制是不同的。 从写一个界面的角度来讲，最为便利的方式是基于标签的声明式代码，比如我们常见的HTML，还有微软的XAML，Flex中的MXML等，都很直接，设想一下在没有可视化IDE的情况用类似Java Swing和微软WinForm这样的方式编写界面，毫无疑问写XML的方式更易被接受。所以，我们可以得出初步的结论，界面的部分应该写标签。 很遗憾，HTML自带的标签是不足的，它有基本表单输入控件，但是缺乏DataGrid，Tree之类更富有表现性的控件。所以绝大多数界面库，都采用某种使用JavaScript的方式来编写这类控件，比如： 12345678910111213&lt;div id=\"tabs\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#tabs-1\"&gt;Nunc tincidunt&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#tabs-2\"&gt;Proin dolor&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#tabs-3\"&gt;Aenean lacinia&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=\"tabs-1\"&gt; &lt;/div&gt; &lt;div id=\"tabs-2\"&gt; &lt;/div&gt; &lt;div id=\"tabs-3\"&gt; &lt;/div&gt;&lt;/div&gt; 123$(function() &#123; $( \"#tabs\" ).tabs();&#125;); 如果这样，这些复杂控件就都要通过JavaScript来创建和渲染了，这与我们刚才提到的原则是违背的。那我们寻找的是什么呢，是一种能扩展已有HTML体系的东西。在早期，IE浏览器中有HTC，可以通过引入命名空间来声明组件，现在的标准浏览器中又引入了Web Components，在Polymer这个框架中可以看到更多的细节。说到底，这类方式要做些什么事情呢？ 隔离组件的实现，让使用变得简单 支持自行扩展新的组件 作一些作用域上的隔离，比如Web Components里面，style标签上可以加作用域，表示这个样式只生效于组件内部 从另外一个角度讲，为什么我们非要这么做不可？最大好处来自哪里？对于大型项目而言，管理成本和变更成本都是需要认真考虑的。如果一个组件，需要在DOM中声明一个节点， 然后再用一个js去获取DOM，把DOM渲染出来，再填充数据的话，这个过程的管理成本是很大的，因为HTML和JS这两个部分丢了一个都会有问题，无论在什么时候，维护一个文件总是比维护多个文件要强的，我们看HTC那种方式，为什么它的使用成本很低，因为它可以把控件自身的DOM、逻辑、样式全部写在自己内部，整个一个文件被人引用就可以了。在现在这个阶段不存在这么好用的技术了，只能退而求其次。 所以，在这个点上，Angular带来的好处是可扩展的标签体系，这也就是标签的语义化。Angular的主打功能之一是指令，使用这种方式，可以很容易扩展标签或者属性。比如，业务开发人员可以直接写： 123&lt;panel&gt; &lt;tree data=\"&#123;&#123;data&#125;&#125;\"&gt;&lt;/tree&gt;&lt;/panel&gt; 这样多么直观，而且可以跟原有的HTML代码一起编写，不造成任何负担。语义化的标签是快速编写界面的不二法门。 业务逻辑有了语义化标签之后，如果我们只写界面不写逻辑，那也够了，但现实往往没有这么美好，我们还要来考虑一下业务逻辑怎么办。 企业应用一般都是面向某行业的，在这个行业内部，会有一些约定俗成的业务模型和流程，这些东西如何复用，一直是一个难题。以往的做法，会把这些东西都放在服务端，用类似Java这样的语言来实现业务元素、业务规则和业务流程的管理。 这种做法所带来的一个缺点就是对界面层的忽视，因为他只把界面层当作展示，对其中可能出现的大量JavaScript逻辑感到无所适从。很多从事这一领域的架构师不认同界面层的厚度，他们认为这一层只应当是很薄的，纯展示相关的，但在这个时代，已经不存在真正轻量级的界面了。 前面提到，我们在前端作分层，把展现层跟业务逻辑层完全隔离，带来的好处就是逻辑层不存在对DOM的操作，只有纯粹的逻辑和远程调用，这么一来，这一层的东西都可以很容易做测试。对于一个大型产品来说，持续集成是很有必要的，自动化测试是持续集成中不可缺少的一环。如果不做分层，这个测试可能就比较难做，现在我们能把容易的先做掉，而且纯逻辑的代码，还可以用更快的方式来测试。 之前我们做前端的单元测试，都需要把代码加载到浏览器来执行，或者自行封装一些“无头浏览器”，也就是不打开实际的展示，模拟这个测试过程。这个过程相对来说还是有些慢，因为它还有加载的这个网络传输的过程，如果我们能在服务端做这个事情呢？ 我们看到，最近很火的NodeJS，它从很多方面给了前端工程师一个机会，去更多地把控整个开发流程，在我们这个场景下，如果能把针对前端逻辑的单元测试都放在node里做，那效率就会更高。 二次开发平台我们来看看，有了这么一套分层机制，又有了界面标签库之后，该做些什么呢？ 做企业软件的公司，有不少会做二次开发平台，这个平台的目标是整合一些已有的行业组件，让业务开发人员甚至是不懂技术的业务人员通过简单的拖拉、配置的形式，组合生成新的业务功能。 从界面的角度看，拖拽生成很容易，很多界面原型工具都可以做，但要如何整合数据和业务？因为你要生成的这个功能，是实实在在要拿去用，不是有个样子看就可以，所以要能跟真实数据结合起来。 但这事情谈何容易！ 就比如说，界面上有一个选择所属行业的下拉框，里面数据是配置出来的，对这个数据的查询操作在后端，作为一个查询服务或者是业务对象管理起来，有些传统的方式可能是在后端作这个关联，Angular框架可以把这个事情推到前端来。相比Backbone这样的框架来说，Angular由于有双向绑定，这个过程会变得特别省事。一个界面片段想要和数据关联起来，要做的事情就是各种属性的设置，所以动态加载和动态绑定都会比较容易。 比如： partial.html123&lt;ul&gt; &lt;li ng-repeat=\"item in items\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; main.html123...&lt;div ng-include=\"'partial.html'\" ng-controller=\"CtrlA\"&gt;&lt;/div&gt;... a.js123function CtrlA($scope) &#123; $scope.items = [&#123;name:\"Tom\"&#125;, &#123;name:\"Jerry\"&#125;];&#125; b.js123function CtrlB($scope) &#123; $scope.items = [&#123;name:\"Donald\"&#125;, &#123;name:\"Micky\"&#125;];&#125; 在上面的例子里，这个列表显示什么，完全取决于ng-controller=”CtrlA”这句，如果我们把这句搞成配置的，就很容易把数据源换成另外一个CtrlB，甚至说，即使在同一版本上做项目化，引入另外一个包含CtrlA其他版本的js文件，也基本无需更改其他代码，这就达到了二次开发的一个目的：尽可能以配置而不是编码去新增、维护新功能。 移动开发现在的企业软件已经不能只考虑PC的浏览器了，很多客户都会有移动办公的需求。响应式设计是一种常见的解决方案，但是在企业应用领域，想要把复杂的业务功能设计成响应式界面的代价太大了，况且界面设计本身就是开发企业软件的这些公司的短板，所以我们的比较简单的办法是对PC和移动终端单独设计界面，这样就有了一个问题了，这两种界面的业务逻辑并没有差别，如果我们要维护两套代码，代价是非常大的，能有什么办法共用一些东西呢？ 如果不采用分层的形式，那这个很麻烦，我们注意到两种系统的差异只在UI层，如果我们用分层的模式，可以共用UI层以外的东西。具体到Angular里面来说，比如service，factory，甚至controller都是可以共用的，只有directive和HTML模板随设备产生差异就可以了。 之前我们很少看到有基于Angular的移动端开发框架，但现在有了，比如Ionic，使用这样的框架，可以直接引用已有的业务逻辑代码，只在展示上作一些调整。这么做有很多好处，同时也对代码的架构水准有一定要求，需要把业务逻辑跟界面展示完全切割开。 这样带来的好处也是很明显的，独立的业务逻辑，因为它不依赖于界面了，所以很容易控制，做单元测试，集成测试，打桩等等，总之它是纯逻辑的东西，在后端可以用什么方式保证代码质量，在前端的业务逻辑也一样可以用，业务逻辑可以因此而清晰稳定。 对于企业应用而言，这么做可以极大程度地复用以往的业务逻辑，只在负责最终展示的代码部分作差异化。 工程化上面这些技术性的问题都解决了，剩下的都是规模带来的边际效应，这需要我们从工程化角度去考虑很多问题： 某个JS模块被修改，如何得知会影响谁？ 某个界面片段被调整，会影响什么界面？ 如何最小化发布？ 如何一键测试、打包、压缩？ 。。。。。。 这些话题，篇幅所限，不在本文中叙述，可以查看我另外的关于Web应用组件化的文章。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-10-22-前端MV☆框架的意义","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2013-10-22-前端MV☆框架的意义/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2013-10-22-前端MV☆框架的意义/","excerpt":"前端MV*框架的意义经常有人质疑，在前端搞MV有什么意义？也有人提出这样的疑问：以AngularJS，Knockout，BackBone为代表的MV框架，它跟jQuery这样的框架有什么区别？我jQuery用得好好的，有什么必要再引入这种框架？ 回答这些问题之前，先要理清一些历史，前端从什么时候开始有框架的？ 早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，这个时期每个界面上只有很少的JavaScript逻辑，基本不太需要框架。随着AJAX的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了，以jQuery为代表，针对界面上常见的DOM操作，远程请求，数据处理等作了封装，也有专注于处理数据的Underscore，严格来说，这些都不能算框架，而是算库。 库和框架是有一些区别的：库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构。框架则是面向一个领域，提供一套解决方案，如果你用我，就得按照我的方式办事。按照这个定义，jQuery和Underscore都只能算是库，ExtJS和dojo算框架。 MV*框架又是为什么兴起的呢？它的出现，伴随着一些Web产品逐渐往应用方向发展，遇到了在C/S领域相同的问题：由于前端功能的增强、代码的膨胀，导致不得不做“前端的架构”这个事情了。","text":"前端MV*框架的意义经常有人质疑，在前端搞MV有什么意义？也有人提出这样的疑问：以AngularJS，Knockout，BackBone为代表的MV框架，它跟jQuery这样的框架有什么区别？我jQuery用得好好的，有什么必要再引入这种框架？ 回答这些问题之前，先要理清一些历史，前端从什么时候开始有框架的？ 早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，这个时期每个界面上只有很少的JavaScript逻辑，基本不太需要框架。随着AJAX的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了，以jQuery为代表，针对界面上常见的DOM操作，远程请求，数据处理等作了封装，也有专注于处理数据的Underscore，严格来说，这些都不能算框架，而是算库。 库和框架是有一些区别的：库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构。框架则是面向一个领域，提供一套解决方案，如果你用我，就得按照我的方式办事。按照这个定义，jQuery和Underscore都只能算是库，ExtJS和dojo算框架。 MV*框架又是为什么兴起的呢？它的出现，伴随着一些Web产品逐渐往应用方向发展，遇到了在C/S领域相同的问题：由于前端功能的增强、代码的膨胀，导致不得不做“前端的架构”这个事情了。很多做后端开发的人对前端架构很不屑，认为前端只是很薄的一层东西，做架构干什么？什么，不但要搞架构，还要搞MVC？Java Struts的MVC中，整个前端都只能算是View而已，你还要在这个View里面划分模型和控制器等其他东西？他们中的多数对这个很不屑，但Web前端随着复杂度的增加，很多地方跟客户端已经没有本质区别了。 jQuery的思维方式是：以DOM操作为中心MV*框架的思维方式是：以模型为中心，DOM操作只是附加 所以回到那个问题上，jQuery满足了你的业务需要，你还有什么必要引入MV*框架？ 这个是要看产品类型的，如果是页面型产品，多数确实不太需要它，因为页面中的JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。 长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。在以往的经验里，他们是有做MVC的，也尝试做了一些界面组件，但做法比较过时，比如说使用JSF或者GWT这样的方式。 JSF的问题是什么？它的问题并不在于界面跟逻辑混合，所谓的纵向切分组件，Polymer这种纯前端框架也是这么切分的，它问题在于组件的生成和渲染不在同一个地方。所以，逻辑代码的位置很尴尬，如果这个界面简单还好说，复杂起来就很麻烦了，就是很多明明是前端逻辑代码，却需要通过后端去生成。 GWT这种方式相对要好一些，它的问题是留给UI调节的余地太小了，比较缺乏灵活性。 这类基于某种服务端技术的组件化方式有一些局限性，比如它较大程度限制了前端的发挥，在早一些的时候，这种方式可能还不错，但是现在随着时代发展，用户对前端用户体验要求越来越高，需要我们把很大一部分精力继续放回前端来。JSF等方案的另外一个问题是绑定了某种服务端环境，很难切换到另外一种后端上，如果碰上要用Hybird方式开发，想复用一些前端逻辑，几乎毫无可能。 那么，我们看看纯前端的框架，看看都是怎么解决这些问题的。以Google为例，它推出了两个框架，Polymer和Angular，而且处于并行发展的阶段，这两者理念还有不小的差别，给不少人带来了困惑。 Polymer切分组件的方式有点类似JSF，它跟HTML5标准中的Shadow DOM和Element有很大联系，这种切分组件的方式非常直观，每个组件都是端到端的，包含UI和逻辑，直接放置到某个界面上就能用，这种方式很容易被业务开发人员接受，但里面的时序比较难处理。 比如说，有两个组件，里面各包含一个下拉框，有数据的联动关系，因为它们处在两个不同的组件里，联动的处理代码就很难写，考虑到组件的特点，要尽量隐藏自己的内部实现，所以从外部获取组件内部的某个元素要绕一层，而组件不能依赖其他外部的东西，所以到最后只有通过事件去实现，这个联动代码写好了应当放在哪里，也是个大问题。我们的例子仅仅是这么简单，就要绕这么个大圈子才能保证时序，如果场景比较复杂，非常难以控制。 如果同样的组件在某个界面被复用多次，数据的一致性也很难保证，设想一下某个界面存在两个一样的下拉框，分别处于不同组件中，两者的数据都需要分别去加载，这个过程是有浪费的，更严重的是，如果这个下拉框对应的数据有更新，很难把每个实例都更新一遍，这个处理过程是非常麻烦的。 Angular框架处理问题的方式跟它有所不同，它是水平分层，所有这些数据访问逻辑都跟UI彻底分离，所以可以很轻松地把这个逻辑代码写出来，这么一来，前面所述端到端的组件就彻底退化，变成只有界面展现了。 看看刚才碰到的两个问题，第一个，模型代码按照业务领域进行划分，获取的数据放在两个不同的数组，然后通过双向绑定跟UI产生关联，如果UI上一个下拉框选中项发生变更，只需要监控这个取值项，然后更新另一个下拉框的取值列表即可，完全不需要绕弯子。即使这两个处于不同模型中，也可以用类似后端的方式，采用事件总线等机制去完成通信。 第二个更简单了，复用的组件其实只有UI，也就是说，只有UI是多实例的，模型其实只有一份，比如说一个地区的树形结构，即使一个界面上同时有维护和使用两种功能，都可以共享同一份模型，当维护这边对数据进行了更新，就实时反馈到模型中，然后由双向绑定再把这个模型同步到界面上的使用方去，整个过程清晰可控。 从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的MV框架，这个状况会大有改观。MV框架的理念是把前端按照职责分层，每一层都相对比较独立，有自己的价值，也有各自发挥的余地。 为什么多数做互联网前端开发的同学们感受不到MV*框架的重要性呢，因为在这个协作体系里，Model的这一块不够复杂，在传统软件领域，Model的部分是代码最多的，View的相对少一些，而互联网领域里，基本是相反的，所以Model这块沦为附加，如果主要在操作View和Controller，那当然jQuery这类框架比较好用了。 所以，经常看到有互联网产品的同学们讲前端MVC，但举例的时候，都比较牵强，很多时候，他们举出来的那个Model，其实都不能算真正的Model，而是在操作View的过程中一些辅助的模型，真正的Model是贯穿前后端的。 归根结底，前端MV*框架带来的是一整套工作流程的变更，后端工程师也可以编写前端的模型代码，把它跟后端彻底打通，交互工程师处理UI跟模型的互动关系，UI工作人员可以专注、无障碍地处理HTML源码，把它们以界面模版的形式提供给交互工程师。这一整套协作机制能够大大提高B/S架构系统的开发效率，如果再有外围的管控平台，生产效率将真正踏进工业化的阶段。 到这个阶段，前端开发人员的出路是什么呢？我认为有两种。拿服装行业来对比，如果你要的是普通的，就使用工业手段批量生产，使用MV*框架，做好架构和组件重用，做得快，细节不是很讲究。如果你想要更好的，有特色的，就需要名家设计，手工打造，非常精巧，高端大气上档次。所以，这也就代表着前端开发的两种发展方向。","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-12-02-一些JS题目的解答","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2013-12-02-一些JS题目的解答/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2013-12-02-一些JS题目的解答/","excerpt":"一些JS题目的解答在这里看到一些测试题，我HTML和CSS比较一般，尝试把里面的JS题目都解答一下： #1. “1” + 2 + “3” + 4 10 1234 37 答案：1234，加法优先级等同，从左往右，数字与字符串相加，数字转换成字符串进行运算，结果等同于：”12”+”3”+4 = “123”+4 = “1234”。","text":"一些JS题目的解答在这里看到一些测试题，我HTML和CSS比较一般，尝试把里面的JS题目都解答一下： #1. “1” + 2 + “3” + 4 10 1234 37 答案：1234，加法优先级等同，从左往右，数字与字符串相加，数字转换成字符串进行运算，结果等同于：”12”+”3”+4 = “123”+4 = “1234”。 #2. 4 + 3 + 2 + &quot;1&quot; 10 4321 91 答案：91，优先级同上，从左往右，等同于：7+2+”1” = 9+”1” = “91”。 #3. var foo = 1; function bar() { foo = 10; return; function foo() {} } bar(); alert(foo); 1 10 Function undefined Error 答案：1，function的定义会提前到当前作用域之前，所以等同于： var foo = 1; function bar() { function foo() {} foo = 10; return; } bar(); alert(foo); 所以，在foo=10的时候，foo是有定义的，属于局部变量，影响不到外层的foo。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope Unlike functions defined by function expressions or by the Function constructor, a function defined by a function declaration can be used before the function declaration itself. #4. function bar() { return foo; foo = 10; function foo() {} var foo = 11; } alert(typeof bar()); number function undefined Error 答案：function，与上题类似，等同于： function bar() { function foo() {} return foo; foo = 10; var foo = 11; } alert(typeof bar()); 在return之后声明和赋值的foo都无效，所以返回了function。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return A function immediately stops at the point where return is called. 补充，这个解答有问题： @尤里卡Eureka：JS中function声明和var声明都会被提前，最终得到结果为function，是因为名称解析顺序-Name Resolution Order(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~ #5. var x = 3; var foo = { x: 2, baz: { x: 1, bar: function() { return this.x; } } } var go = foo.baz.bar; alert(go()); alert(foo.baz.bar()); 1,2 1,3 2,1 2,3 3,1 3,2 答案：3,1this指向执行时刻的作用域，go的作用域是全局，所以相当于window，取到的就是window.x，也就是var x=3;这里定义的x。而foo.baz.bar()里面，this指向foo.baz，所以取到的是这个上面的x，也就是1。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FOperators%2Fthis #6. var x = 4, obj = { x: 3, bar: function() { var x = 2; setTimeout(function() { var x = 1; alert(this.x); }, 1000); } }; obj.bar(); 1 2 3 4 undefined 答案：4，不管有这个setTimeout还是把这个函数立即执行，它里面这个function都是孤立的，this只能是全局的window，即使不延时，改成立即执行结果同样是4。 #7. x = 1; function bar() { this.x = 2; return x; } var foo = new bar(); alert(foo.x); 1 2 undefined 答案：2，这里主要问题是最外面x的定义，试试把x=1改成x={}，结果会不同的。这是为什么呢？在把函数当作构造器使用的时候，如果手动返回了一个值，要看这个值是否简单类型，如果是，等同于不写返回，如果不是简单类型，得到的就是手动返回的值。如果，不手动写返回值，就会默认从原型创建一个对象用于返回。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new #8. function foo(a) { alert(arguments.length); } foo(1, 2, 3); 1 2 3 undefined 答案3，arguments取的是实参的个数，而foo.length取的是形参个数。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments/length?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments%2Flength arguments.length provides the number of arguments actually passed to a function. This can be more or less than the defined parameter count (See Function.length). #9. var foo = function bar() {}; alert(typeof bar); function object undefined 答案：undefined，这种情况下bar的名字从外部不可见，那是不是这个名字别人就没法知道了呢？不是，toString就可以看到它，比如说alert(foo)，可以看看能打出什么。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope The function name can be used only within the function’s body. Attempting to use it outside the function’s body results in an error (or undefined if the function name was previously declared via a var statement). #10. var arr = []; arr[0] = &apos;a&apos;; arr[1] = &apos;b&apos;; arr.foo = &apos;c&apos;; alert(arr.length); 1 2 3 undefined 答案：2，数组的原型是Object，所以可以像其他类型一样附加属性，不影响其固有性质。 #11. function foo(a) { arguments[0] = 2; alert(a); } foo(1); 1 2 undefined 答案：2，实参可以直接从arguments数组中修改。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments The arguments can also be set #12. function foo(){} delete foo.length; alert(typeof foo.length); number undefined object Error 答案：number，foo.length是无法删除的，它在Function原型上，重点它的configurable是false。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete delete can’t remove certain properties of predefined objects (like Object, Array, Math etc). These are described in ECMAScript 5 and later as non-configurable","categories":[],"tags":[]},{"title":"","slug":"杂谈/2014-01-06-影响企业应用前端开发效率的因素","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2014-01-06-影响企业应用前端开发效率的因素/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2014-01-06-影响企业应用前端开发效率的因素/","excerpt":"影响企业应用前端开发效率的因素原先是在知乎上回答一个问题的，整理了放这里： 我们来分析一下究竟哪些因素让企业应用的前端开发这么困扰。 先看看界面部分吧。 #1. 命令式还是声明式毫无疑问，就写界面来说，声明式的代码编写效率远高于命令式： &lt;Panel title=&quot;Test&quot;&gt; &lt;Button label=&quot;Click me&quot;/&gt; &lt;/Panel&gt; Panel p = new Panel(); p.title = &quot;Test&quot;; Button b = new Button(); b.label = &quot;Click me&quot;; p.add(b); 第一种容易写，容易理解。","text":"影响企业应用前端开发效率的因素原先是在知乎上回答一个问题的，整理了放这里： 我们来分析一下究竟哪些因素让企业应用的前端开发这么困扰。 先看看界面部分吧。 #1. 命令式还是声明式毫无疑问，就写界面来说，声明式的代码编写效率远高于命令式： &lt;Panel title=&quot;Test&quot;&gt; &lt;Button label=&quot;Click me&quot;/&gt; &lt;/Panel&gt; Panel p = new Panel(); p.title = &quot;Test&quot;; Button b = new Button(); b.label = &quot;Click me&quot;; p.add(b); 第一种容易写，容易理解。 #2. 控件标签集不管你的软件面向什么行业，至少都要一些控件，或者是基本的表单输入，或者是复杂的比如树形表格，里面还可以跨行跨列渲染的。 如果我们有一套映射到控件的标签，那么写代码是肯定会简单很多的，比如说，在HTML里面没有原生的Panel，那么，刚才第一段代码可能就要变成： &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;Simple HTML Loader&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;button&gt;Click me&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 我们为了使得界面代码编写更高效，毫无疑问会倾向于把这么一堆东西简化成一个Panel标签，这样就会逐步建立一套面向自己行业的标签集。 #3. 带逻辑的控件刚才这个例子为什么简单呢，因为它只是一个普通容器，静态的，不带逻辑，所以即使你用什么静态模板也能解决问题。如果复杂一点，是一个TabNavigator，就要考虑切换的事件，再复杂一些是个树形表格，那就更麻烦了。 我们来看jQuery提供的插件方式实现TabNaviator： &lt;div id=&quot;tabs&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#tabs-1&quot;&gt;Nunc tincidunt&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#tabs-2&quot;&gt;Proin dolor&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#tabs-3&quot;&gt;Aenean lacinia&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;tabs-1&quot;&gt; &lt;/div&gt; &lt;div id=&quot;tabs-2&quot;&gt; &lt;/div&gt; &lt;div id=&quot;tabs-3&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function() { $( &quot;#tabs&quot; ).tabs(); }); &lt;/script&gt; 从我个人的角度看，这种代码很愚蠢。蠢在何处呢？HTML这类声明式的界面描述语言，写起来本来应当直观一些的，但是被这么一搞，又往命令式的方向去了。而且两种东西混杂，声明和渲染居然分了两处，又增加了维护的成本。 难道就没有别的办法来解决这个问题吗？ 我们看看其他语言和框架，比如Flex和Silverlight。 &lt;mx:TabNavigator id=&quot;tn&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;!-- Define each panel using a VBox container. --&gt; &lt;mx:VBox label=&quot;Panel 1&quot;&gt; &lt;mx:Label text=&quot;TabNavigator container panel 1&quot;/&gt; &lt;/mx:VBox&gt; &lt;mx:VBox label=&quot;Panel 2&quot;&gt; &lt;mx:Label text=&quot;TabNavigator container panel 2&quot;/&gt; &lt;/mx:VBox&gt; &lt;mx:VBox label=&quot;Panel 3&quot;&gt; &lt;mx:Label text=&quot;TabNavigator container panel 3&quot;/&gt; &lt;/mx:VBox&gt; &lt;/mx:TabNavigator&gt; 上面这段是Flex里面的TabNavigator，在这个链接底部有运行结果：TabNavigator 为什么它可以看不到逻辑的代码，但是又确实能有动作呢，因为它的实现类是mx.containers.TabNavigator，在这个代码里，可以自己手动去处理一切内部实现，但是暴露给业务开发人员的就是这么简单的标签。 我们看看在HTML和JS这个体系里用什么办法去解决。不要提JSF这类服务端技术，因为它的思路也是不好的，展示代码的生成和渲染都不在一个地方，会有很多问题。 #4. Polymer与Angular 早期IE里有HTC，也就是HTML Components，因为别的浏览器厂商不喜欢，所以快要消亡了。在W3C新的HTML规范里，有一个Web Components，参见这里：Introduction to Web Components 这个东西跟HTC的思想本出同源，它引入了Custom Elements和Shadow DOM这两个概念，也就是说，我可以自定义一个标签，然后在内部随便怎么折腾，用这个标签的人可以很方便。 很美好，是不是，但是只适用于比较新的浏览器，基于这个理念架构的框架Polymer的目标也只是支持一些比较新的浏览器。Polymer 那么怎么办呢？我们还有Angular，它也可以自定义标签，然后用directive的方式写内部实现。 &lt;tabs&gt; &lt;pane title=&quot;Localization&quot;&gt; &lt;/pane&gt; &lt;pane title=&quot;Pluralization&quot;&gt; &lt;/pane&gt; &lt;/tabs&gt; &lt;script id=&quot;components.js&quot;&gt; angular.module(&apos;components&apos;, []) .directive(&apos;tabs&apos;, function() { return { restrict: &apos;E&apos;, transclude: true, scope: {}, controller: function($scope, $element) { var panes = $scope.panes = []; $scope.select = function(pane) { angular.forEach(panes, function(pane) { pane.selected = false; }); pane.selected = true; } this.addPane = function(pane) { if (panes.length == 0) $scope.select(pane); panes.push(pane); } }, template: &apos;&lt;div class=&quot;tabbable&quot;&gt;&apos; + &apos;&lt;ul class=&quot;nav nav-tabs&quot;&gt;&apos; + &apos;&lt;li ng-repeat=&quot;pane in panes&quot; ng-class=&quot;{active:pane.selected}&quot;&gt;&apos;+ &apos;&lt;a href=&quot;&quot; ng-click=&quot;select(pane)&quot;&gt;{{pane.title}}&lt;/a&gt;&apos; + &apos;&lt;/li&gt;&apos; + &apos;&lt;/ul&gt;&apos; + &apos;&lt;div class=&quot;tab-content&quot; ng-transclude&gt;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos;, replace: true }; }) .directive(&apos;pane&apos;, function() { return { require: &apos;^tabs&apos;, restrict: &apos;E&apos;, transclude: true, scope: { title: &apos;@&apos; }, link: function(scope, element, attrs, tabsCtrl) { tabsCtrl.addPane(scope); }, template: &apos;&lt;div class=&quot;tab-pane&quot; ng-class=&quot;{active: selected}&quot; ng-transclude&gt;&apos; + &apos;&lt;/div&gt;&apos;, replace: true }; }) &lt;/script&gt; 这么一来，也就有些接近我们的目标了，看到现在，我们还记得目标是什么吗？是尽可能精简的面向领域的容器和控件标签集，有了这个，写界面代码才能更简单。 #5. 为什么HTML默认标签集这么小 事情结束了吗？没有呢。我们的HTML体系为什么标签集这么小？因为他要解决的是通用领域的东西，怎样才能通用呢？要的是尽可能无歧义。 怎样的东西会没有歧义？那就是它的含义尽可能少，比如说单行文本输入框，总没人对它有歧义吧，它无非就是可以设置最大最小长度，是否只读，是否禁用，最多通过某种规则来限制输入字符，最多最多，也就这些可做的了，大家都认同。 Button就不同了，一开始他是 &lt;input type=&quot;button&quot; value=&quot;Click&quot;/&gt; 后来大家想要各种各样的button，于是开放了 &lt;button&gt;&lt;/button&gt; 这样的标签，可以在里面写各种HTML，我记得当时很多人在中间加上下和左右两层marquee，简直玩坏了。 现在HTML里面又有了数字输入，日期时间输入这样的东西，数字的没什么疑问，就是最大最小值，步进值等等，日期时间这个就复杂了，它怎么做，都有人不满意。有人要日期排左边，有人要时间排上面，有人只要年和月，有人只要分和秒。有人要点空白表示选中，有人要双击日期表示选中，还有人想用农历、波斯历、尼泊尔历，简直没完了，还不如不做，谁要谁自己做…… 所以，面向各领域的人们，自己动手，丰衣足食吧。 #6. 界面修饰 好了，控件集的问题解决了，我们来看看界面的修饰。 你们发现没有，不管用什么非HTML的标签体系，可能写代码会很快，但是有时候要修饰界面，比如只是调整一下所有容器的边距，某些按钮的圆角之类，就会生不如死。 这时候你会发现，HTML里面的CSS真是神器，什么都能干，而且是面向切面的，只要你的HTML结构是良好的，完全不需要调整这个层面的代码。为什么其他体系的CSS没有这么强呢？比如说Flex也可以写CSS，QT也可以写CSS。 因为CSS的部分实在是太复杂了，复杂到整个浏览器里面绝大部分的代码都在处理这方面的东西，像Google的Chrome团队有1000多人，别的体系没法有这么大投入，只能看着羡慕。 上次看到一个问题，近30年来软件开发体系有哪些本质的改进？我觉得CSS真的可以入选，这是一个把结构和展现完全分离的典范，并且实现得很好。 我们的前端开发一般都是面向某个领域的，不管什么领域，CSS方向都可以有一个很独立的规划，因为它可以不影响界面的结构。所以这个方面，其实不太会对前端开发造成太多压力，压力只集中在维护CSS的人群身上。 好了，上面扯了那么多，其实到现在还在界面的层次，一直没有去谈到真正的逻辑。那么，最让我们困扰的部分是哪里呢？ #7. 模块化和加载 Web前端开发有个最苦闷的事情就是选型，因为HTML这个体系很开放，提供的默认能力又不是很足够，如果要做复杂交互的东西，会需要很多额外的工作。有各种框架从各种角度来解决问题，但怎么把这些东西整合到正好符合自己的需要，是一个很花精力的事情，很多时候恨不得自己把全部轮子都造一遍。 真正的开发工作中，跨浏览器，踩各种坑应该是最烦闷的事，其他部分，如果有做好自己领域里标签的定义，或者不用标签用其他方式，应该不算特别困难。有人说JavaScript语言本身比较松散，所以写业务逻辑比较头疼，这不算大问题。基于B/S的开发，有一个大坑是你在运行的时候要先把代码加载过来，然后才能跑。你看那些C/S软件，有这困扰吗？再看看后端程序员，谁还要关心自己的代码执行之前要做的事情？ 所以后端程序员写前端代码，都情不自禁地会引入一大堆库。我们形象一点来描述一下这个过程： 嗯，大家都用jQuery，我也引入，抄了两段代码发现真不错。咦，我要个树控件，网上逛了一圈，拿了个zTree回来。再埋头苦干半个小时，缺数据表格控件，于是过了一会，jQuery UI被整体引入了。再埋头苦干，上网乱点了点，浏览器跳出个广告，一看叫做Kendo UI，看看发现不错，引进来再说，用里面的某个控件。又过了一阵，听说最近Angular很火啊，看了看例子，表单功能怎么那么强，我也要用！捣鼓捣鼓又加进去了。项目里又要用图表库，看了半天眼睛都花了，百度的ECharts不错哦，引进来。哎呀我界面怎么那么丑，人家的怎么那么清爽，查看源码，一看，Bootstrap，去官网一看，真乃神器，不用简直对不起自己。 没多久之后，这个界面已经融合了各种主流框架，代码写法五花八门，依赖了几M的JS库，更要命的是里面某些JS有冲突，某些样式也互相覆盖，快疯了。 这里有哪些问题呢？ JS代码要先加载到界面才能执行，而这么几M的代码加载过来就要好久了，然后每个框架还要把自己初始化，又耗不少时间，半分钟之后自己写的JS才开始执行，用户等得都快怀孕了。 不管是JS还是CSS，都应当控制基准的代码，这件事的主要意义是避免冲突，因为整个体系都比较松散，如果不加控制，就会造成冲突。即使在服务端写Java，也有类签名一致性之类的问题，所以这个部分必须要重视。 刚才这两点，第二点暂时不是我们要探讨的范围，第一点，引出的话题就是异步加载，这是一个可以展开说很多的话题，也不再说了。异步加载和缓存是面对复杂场景必做的优化措施。 但是这个里面规范就有好几种，具体实现方式就更多了。ES6的module也许可以解决这个问题。harmony:modules [ES Wiki] #8. 逻辑的分层 网站型和应用型Web程序对分层的需求是不一样的。网站型的逻辑大部分都在处理UI，而应用型可能有很多业务逻辑，这部分需要更好的组织，以便复用，或者即使我们的目标不包括复用，为了这个代码的可维护性，也需要有比较好的组织方式。 本质上这些组织方式与传统的客户端软件开发没什么不同，主要要做的无非就是UI层的隔离，或者模板化，或者别的什么方式。纯逻辑的代码大家都会写，但这个逻辑怎么跟界面产生关系，这是个问题。 有些框架通过在HTML元素上设置额外属性，然后启动的时候读取，在框架内部做一些相关的事情，比如Angular、Avalon和Knockout。有的框架在视图层中让开发人员手动去处理界面，就像未引入框架的那样，比如Backbone，两者是各有利弊的。 前面这种，一般功能是会很强大，但是它自身所做的东西必须足够多，多得帮你做掉绝大部分本来该自己做的事，你才会特别爽。所以，用这类框架来做表单型应用的时候，是会非常舒服的，因为这些需求他做框架的时候能预见，所以比如校验、联动、存取之类的都会处理掉。假如你要做一个绘图类应用，这就麻烦了，不管你是用Canvas还是SVG，它所能帮到的都不多。这时候，后面这类可能反而适合一些。 这些数据分层框架的原理是什么呢？是要做一层表单与数据的对应关系，所以他要检测数据的变动，比如一个Object，它某个值变更了，要去把对应的界面更改之类。这里面也有很多的坑，可以一步一步踩过来。。。 到现在，我大致可以回答你的问题，什么情况下前端开发会比较轻松呢？ 针对自己领域的界面标签库比较完善，或者易于扩展 样式容易调整，并且独立于界面元素 逻辑模块化，层次分明，在某种统一规范上存在大量可用库咦，我这三点好像在说微软的WPF体系吗？","categories":[],"tags":[]},{"title":"","slug":"杂谈/2013-12-09-Web应用的组件化（二）","date":"2019-04-13T07:28:25.000Z","updated":"2019-04-13T07:28:25.000Z","comments":true,"path":"2019/04/13/杂谈/2013-12-09-Web应用的组件化（二）/","link":"","permalink":"https://qccs.github.io/2019/04/13/杂谈/2013-12-09-Web应用的组件化（二）/","excerpt":"Web应用的组件化开发（二）管控平台在上一篇中我们提到了组件化的大致思路，这一篇主要讲述在这么做之后，我们需要哪些外围手段去管控整个开发过程。从各种角度看，面对较大规模前端开发团队，都有必要建立这么一个开发阶段的协作平台。 在这个平台上，我们要做哪些事情呢？","text":"Web应用的组件化开发（二）管控平台在上一篇中我们提到了组件化的大致思路，这一篇主要讲述在这么做之后，我们需要哪些外围手段去管控整个开发过程。从各种角度看，面对较大规模前端开发团队，都有必要建立这么一个开发阶段的协作平台。 在这个平台上，我们要做哪些事情呢？ #1. HTML片段 我们为什么要管理HTML片段？因为有界面要用它们，当这些片段多了之后，需要有个地方来管理起来，可以检索、预览它们，还能看到大致描述。 这应该是整个环节中一个相对很简单的东西，照理说，有目录结构，然后剩下的就是单个的HTML片段文件了，这就可以解决存储和检索的问题了，但我们还要考虑更多。 已有的HTML片段，如何被使用呢？这肯定是一种类似include的方式，通过某种特殊标签（不管是前端还是后端的方式）把这些片段引用进来，这时候就有了第一个问题： 假设有界面A和界面B同时引用了片段C，在某个开发人员修改片段C内容的时候，他如何得知将会影响到界面A和B呢？一个比较勉强的方式是全项目查找，但这在很多情况下是不够的。 如果我们的HTML片段是作为独立的公共库存在的，它已经不能通过项目内查找去解决这一问题了，因为不管A还是B，只要他不处于片段C的项目空间，就无从追寻。 这时候很多人会问两个问题： 跨项目的界面片段重用，意义在哪里？ 如果我们的产品是针对一个小领域，它的复杂度根本不需要划分多个项目部分来协作完成。设想场景是面对很大的行业，各项目都是子产品，将来可能是其中若干个联合部署，这时候，保持其中的一致性是非常重要的。比如我们有个基本配置界面，在多个子产品中都要用，如果各自开发一个，其操作风格很可能就是不一致的，给人的印象就是不专业。所以会需要把常见的界面片段都归集起来，供业务方挑选使用。 修改C，只提供说明，但是不通知A和B，不实时更新他们的版本，然后自行决定怎样升级，如何？ 这会有一个问题，每次有小功能升级的时候，代码是最容易同步合并的，所以才会有“持续集成”这个概念，如果是一直伴随升级，总要比隔一个大阶段才升级好，升级成本应尽量分摊到平时，就像农妇养小猪，小猪每天长一点，每天都抱来抱去，不觉得吃力，即使长大了也还能抱得动。 现在问题就很明确了，一定要有一种方式来把这个依赖关系管理起来，很显然，已有的版本库是肯定管不了这些的，所以只能在外围做一些处理。 我们建立一个管理平台，除了管理实体文件的版本，还管它们之间的关系。具体这个关系如何收集整理，有两种方式：手动配置，代码分析。 手动配置是比较土的方式，开发人员每提交一个文件，就去这系统上手动配置它的依赖关系。代码分析的话，要在每次提交文件的时候解析文件的包含规则，找出确切的文件。这两者各有利弊，前者比较笨，但容易做，后者对代码格式的要求比较高，要考虑的情况较多。 我们的界面往往不是那么简单，HTML片段也可能有层次的，举例来说： 界面A里面包含了片段B，但是片段B自身又包含了片段C，所以这个依赖关系也是有层级的，需要在设计的时候一并考虑。 #2. JavaScript模块 JavaScript代码的管理，比HTML片段的状况好一些，因为业界很多这方面的解决方案。但它们还是没有解决当依赖项产生变更的时候反向通知的问题。 所以我们还是得像HTML片段一样，把它们的依赖关系都管理到平台里。于是，每个JavaScript模块都显式配置了自己所依赖的其他模块，通过这种单向关系，形成了一套完整的视图。 在JavaScript模块的代码实现中，我们是不提倡直接写依赖关系的。很多通用规范，比如AMD，往往建议我们这样写模块： define([&apos;dep1&apos;, &apos;dep2&apos;], function (dep1, dep2) { var moduleA = function () {}; return moduleA; }); 但我们的系统是面向行业的，比这种通用解决方案要苛刻一些。比如说，如果有一天重构代码，JavaScript模块们调整了目录或者名字，这么写的就痛苦了，他必须把所有影响到的都去调整一遍，这是要搜索替换的。况且，就像上面HTML模板的部分提到的，影响了处于其他项目中依赖它的代码，缺少合适的方式去通知他们修改。 所以我们期望的是，在每个编写的JavaScript模块中只存放具体实现，而把依赖关系放在我们的平台上管理，这样，即使当前模块作了改名之类的重构处理，处于外部项目中依赖它的那些代码也不必修改，下一次版本发布的生成过程会自动把这些事情干掉。 对应到上面的这段代码，我们需要开发人员做的只是其中的实现，也就是moduleA的那个部分，外面这些依赖的壳子，是会在发布阶段根据已配置的依赖关系自动生成的。 如果需要，JavaScript模块还可以细分，比如类似Angular里面那样，把factory，controller和directive分离出来，这会对后续有些处理提供方便。 现在我们有必要讨论一下模块的粒度了，我们这里提到的都是基本的粒度，每个JavaScript模块中存放的应该只有一个很具体东西的实现。那么，有个问题，在我们发布的时候，是不是就按照这个粒度发布出去呢？ 很显然不行，如果这么做，很可能会出现复杂界面一次要用10多个HTTP请求才能加载完它所需要的所有JavaScript代码的情况，所以需要做一些合并。 那么，合并的策略是什么？在我们这个平台上，开发人员又是要怎样定义这个合并关系的呢？我们需要在模块之上定义一个更大粒度的组织方式，这个方式与模块的关系，就好比Java里面，jar文件与class的关系。如果开发人员不显式配置，也可以通过全局策略，比如按最下层目录来合并。 这个时候，在实际使用这些代码的时候，需要带两个配置信息过去，一个是要动态载入的JavaScript文件（合并之后的），二是每个JavaScript文件中包含的原始模块。 #3. 单元测试 如果JavaScript模块都已经被良好有序管理起来，就可以为它们考虑单元测试的事情了。单元测试对于提高基础单元的可靠度，是有非常重要意义的。 在我们这个平台里，可以把单元测试跟JavaScript模块关联起来，每个JavaScript模块可以挂一组单元测试代码，这些代码可以在线编写，在线运行。 单元测试的本质就是编写模拟代码来调用已有模块，考虑到我们的模块是JavaScript，所以很多思路都倾向于在浏览器端执行它们，对于单个模块的单元测试，这不是个问题。 如果要批量执行整个系统的单元测试，那就不一样了。把JavaScript代码先加载到浏览器中，然后再执行，很多时候并不需要这么复杂。我们完全可以在服务端把它们做了。 借助Node.js的能力，我们可以在服务端执行JavaScript代码，也就意味着能够把绝大多数JavaScript模块的单元测试在服务端就执行掉。当然，我们为此可能要多做不少事情，比如说，有些库需要移植一份node版的，常见的有AJAX调用等等。 注意了，能够在服务端做JavaScript单元测试是有先决条件的，代码的分层必须很良好，除了视图层，其他任何层面都不能操作DOM。所以我们这里主要测试的也正是除了视图层之外的所有JavaScript业务逻辑。至于视图层怎么办？这个真的很难解决，这世界上不是所有东西都能自动做的，只能先把可做的做了，以后再来考虑这些。 #4. 文档和示例管理 ##4.1. 文档 现在我们有HTML片段和JavaScript模块了，需要给它们多一些描述信息。简单描述显然是不够的，我们还要详细文档。 这种详细文档可以通过某种方式生成，也可以由开发人员手动编写。与传统的离线文档不同，在线的文档更实时，并且，每当一个开发人员变更了他的文档之后，不需要经过全量构建，访问者可以实时访问到他的最新版本。 熟悉GitHub的朋友们可能早已习惯这种方式，在项目库里面存在一些以md格式结尾的文本文件，使用markdown语法来编写一些说明文档。 毫无疑问，这类格式很适合在线协作，所以我们也会在平台上集成这么一种编写文档的方式，无论是针对HTML模板还是JavaScript模块，或者是其他什么类型，甚至还可以用来当博客，就像月影同学的gitpress平台，能直接从GitHub上拉取文本或者HTML文件形成博客。 文档除了以集成的形式浏览之外，应当也可以以单独链接的方式发出去，这时候用户就可以像看一个新闻网页一样去浏览。如果再进一步做下去，还可以做电子书的生成，提供打包的离线文档。 ##4.2. 示例 在编写代码文档的过程中，可能免不了要插入示例，示例有两种形态，一种是纯文本，类似gist这样，一种是可在线运行，类似jsfiddle和jsbin这样。 这两种都有各自的优点，所以可以都做，示例的存放可以与文档类似，也应当能通过一个链接独立运行。 ##4.3. 幻灯片 有时候我们看到一些在线的幻灯片，觉得效果很帅，比如reveal.js，我们的开发人员有时候作代码分析或者走查的时候也不免要写一些演示，如果能把这些东西也随项目管理起来，能在线查看，会是很不错的一件事。所以我们也可以考虑给它们加个存储界面，甚至做个简易的在线编写器。 #5. 项目与目录管理 说到现在，我们似乎还遗漏了一点什么。那就是以上提到的这些东西，以什么为组织单位来存储？ 考虑到我们的这个平台是要管理一整个大产品的全部前端内容的，它里面应该分了很多项目，对应到子产品上，这么一来，很自然地，项目就成了第一级组织单位。项目之下，没有悬念地，只有目录了。 对于一个项目而言，它有哪些要做的事情呢？首先要能配置其实体存储位置。前面提到的这么多代码、文档之类，最终都是要实体存储的，怎么存？我们当然可以自己搞一套，在文件系统上做起来，但是还要考虑它们的版本管理，非常麻烦，所以不如直接对接某个版本库，调用它的接口去存取文件，这里配置的就是版本库的路径。 其次，要考虑从已有项目复制，类似GitHub里面的fork功能，不过内部处理机制可以略有不同，fork的项目默认未必要有实体文件，只有当产生了修改或者新增操作的时候才创建，剩下的还引用原来的就可以了。我们这里的项目复制功能是为项目化版本而考虑的，经常出现一个产品版本支持多个客户项目的情况，所以可能会用得着这个特性。 然后，也要考虑项目的依赖关系。依赖一个项目，意思是需要用到它里面的组件，所以实质是组件的依赖。提供项目依赖这个视图，只是为了未来变更的一些考虑。 #6. 评论管理 之前提到，我们整个平台的目的是为了提高大型前端团队的协作能力，协作是离不开交流的。上述的任何功能，都应当带有交流沟通的能力。 比如说，如果开发人员A使用了其他人写的一个代码组件a，对其中一些细节有疑问，他应当可以对它进行评论。在他评论的时候，任何参与维护过这个组件的人员都能收到一个提醒，这时候他可以选择过来看看，回复这个疑问。同理，在文档、示例下也可以如此操作。 在互联网上有这类产品，用于在任意URL下挂接评论交流系统，比较有名的就是Disqus，我们可以看到很多网站下面挂着它，用于做交流评论，这样用户可以用一个账号在多个网站之间交流。国内也有同类的，比如多说，能够用微博、QQ等账号登录进行交流。 从我们这个平台本身看，如果是部署在企业内部作流程提升，引入外部评论系统的可能性就比较小了。因为在企业内部用，一定是希望这个员工的账号信息跟工号挂钩，也能够跟版本服务器账号等模块作集成，权限也便于控制。 从另外一个角度讲，某个人员登录这个系统的时候，他可能收到很多消息，来自不同的代码或文档位置，挨个点过去回复也有些麻烦，我们应当给他提供一个全局视图，让他能在一个统一的界面把这些问题都答复掉，如果他需要的话，也是可以点进去到实际的位置。 #7. 用户和权限控制 从以上部分我们已经看到，这个系统是一个比较复杂的开发过程管控平台。这样的话，每个使用的人就应当可以登录，然后分配不同的权限等级。 未登录用户应当有一些东西的查看权限，但是不能发表评论。已登录的用户根据权限级别，可以控制能否创建、修改项目，创建、修改目录，代码，单元测试，文档等。 #8. 国际化字符串管理 一个跨语言区域的Web应用不可避免要跟国际化打交道，这个事情通常是在服务端做，比如通过在界面代码中嵌入类似&lt;% =getRes(key, lan) %&gt;这样的代码，去获取相应的字符串，替换到界面里来。 这个事情是要占用应用服务器资源的，而且国际化本身其实是一个在运行之前就已经确定的事，完全可以把这个过程放在发布阶段就做掉。比如说，我们给每种语言预先就把代码生成多份，只是部署在一起，根据需要的情况来动态加载特定的那一份。 有不少客户端的国际化方案，是把资源文件拆细，以页面为单位存储，但这其实是不太合理的。第一个原因就是在Web2.0时代，“页面”这个概念本身就已经弱化了，到了单页应用里，整个应用都只是一个页面，这个时候，资源文件以什么粒度来组织呢？ 我们提到过，采用MV*框架去做Web应用的架构，有一个目标是做组件化。组件化的意图就是某个组件可以尽可能随心所欲地放在需要的地方用。如果把资源文件的粒度弄小到对应HTML片段和JavaScript模块这一级，灵活性倒是有了，带来的问题就是管理成本增大。 做一个行业应用，最重要的就是业务一致性，这包括逻辑的一致性，也包括了术语的一致性。某一个词，可能在多个资源文件中都出现，这就增加了不一致的可能性。 所以，应当有一个统一的术语管理平台，一切界面上出现的文字或者提示，都必须来自这个平台。 #9. 静态资源的管理 在发布系统的时候，除了需要发布代码，还需要发布图片等静态资源，这些东西也应当被管理起来。 静态资源在两种情况下可用：随产品发布，在本平台被引用。比如说有一个图片，在这个平台上作了管理，它可以被配置到某个项目上，在发布的时候导出。这个图片还可以被用链接的方式查看或者下载，如果本平台内部的一个文档或者示例要引用它，也是可以的。 #10. 样式与主题管理 在Web系统里，样式和主题是很重要的一环。样式的管理和发布一直是一个比较复杂的话题，早几年一般都是分块写，然后组合合并，最近这些年有LESS，SASS和Stylus这类技术，解决了编写和发布的分离问题。 我们看看发布的最大问题是什么？是不同部分的合并。为了追求灵活性，不得不把东西拆得很细，之前HTML片段和JavaScript模块的处理方式都是这样。这么做，我们就需要另外一件事：这些细小的东西，尽可能要覆盖全面。 对应到CSS里面，我们要做的是把每种在系统中可能出现的元素、类别都作为单独的规则维护起来，生成一个全局的规则列表。不同项目间，实现可以不同，但规则的名字是固定的，定制只允许修改实现，不允许修改规则。如果要新增之前没有的规则，也必须在全局规则列表里先添加，再作实现。 样式规则被管理之后，可以在界面组件上对它作关联，也可以不做。做的好处是发布的时候能只把用到的那些样式规则生成发布出去，如果能接受每次发布全量CSS，那也无所谓。 除了规则，也需要考虑一些变量的管理，在CSS中合理使用变量，会大为减轻定制化所导致的工作量。 #11. 一键发布 我们引入了这么一堆东西，其实是增加了发布的复杂度。为什么呢？ 之前不管HTML、JavaScript还是CSS，都是手写出来，最多经过一个minify的工作，就发布了，整个过程很简单，两句脚本搞定。 现在可复杂了，先要分析依赖关系，然后提取文件，然后国际化字符串替换，然后合并，然后代码压缩，整个过程很折腾，不给配置管理员一个解释的话，他一定过来砍人。 我们有个原则：解决问题的过程中，如果引入了新的问题，要求负责解决原问题的人也一起解决掉。现在为了一些意图，增加了版本发布的复杂度，那也要有个办法再把这事摆平，至少不能比原来复杂。 所以我们就要把这些过程都集成到管控平台里，做一个一键发布的过程，把所有的这些操作都集成起来，配置管理员发布版本的时候只要点一下就可以把所有这些事情做掉。甚至说，这些流程还可以配置，能够加减环节。 这时候我们做到了跟之前发版本一样方便，能不能多做点什么呢？ 可以把JavaScript单元测试集成到版本发布阶段。因为我们已经把JavaScript按照职责做了分层，并且把UI部分做了隔离，就可以在浏览器之外把这个单元测试做掉，平时提交代码的时候也可以做，最终在版本发布阶段再全量做一下，也是很有意义的。 代码依赖关系管理的另一个目的是什么呢？是最小化发布，既然我们都管理了文件之间的关系，那么，从根出发，显然是能够得出哪些代码文件在本项目中使用的，就可以每次从我们的全量代码库中取得确切需要的一部分来发布。这也是我们整个管控平台带来的优势。 #12. 小结 我们这一篇比较复杂，提出了一整套解决大规模前端协作的管控机制。这套理论的本质是在开发和版本发布之间加了一个环节，把Web体系中除了服务之外的一切静态资源都纳入其中，强化了现有主流的一些基于命令行的前端工程化组织模式。 相比于传统行业，比如汽车制造，我们这个环节相当于生产流水线的设计，其中一些组件的存储就类似仓储机制，发布就类似出厂过程。 这个平台本身还有不少其他的可做的东西，比如甚至可以在上面做界面的可视化定制等，这些是长远的终极目标，在后面的文章里会谈谈一些考虑。 后续文章中，我们会展望有了这个平台之后，整个前端的协作流程是怎样的。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之执行上下文","date":"2019-04-13T07:27:41.352Z","updated":"2019-04-13T07:27:41.352Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之执行上下文/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之执行上下文/","excerpt":"JavaScript深入之执行上下文 JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。","text":"JavaScript深入之执行上下文 JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack = [ globalContext]; 2.全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。 下一篇文章《JavaScript深入之闭包》 相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 重要参考《一道js面试题引发的思考》 本文写的太好，给了我很多启发。感激不尽！ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之偏函数","date":"2019-04-13T07:27:41.347Z","updated":"2019-04-13T07:27:41.348Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之偏函数/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之偏函数/","excerpt":"","text":"JavaScript专题之偏函数定义维基百科中对偏函数 (Partial application) 的定义为： In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. 翻译成中文： 在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。 什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。 举个简单的例子： 1234567891011function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 partial 函数可以做到局部应用var addOne = partial(add, 1);addOne(2) // 3 个人觉得翻译成“局部应用”或许更贴切些，以下全部使用“局部应用”。 柯里化与局部应用如果看过上一篇文章《JavaScript专题之柯里化》，实际上你会发现这个例子和柯里化太像了，所以两者到底是有什么区别呢？ 其实也很明显： 柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。 局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。 如果说两者有什么关系的话，引用 functional-programming-jargon 中的描述就是： Curried functions are automatically partially applied. partial我们今天的目的是模仿 underscore 写一个 partial 函数，比起 curry 函数，这个显然简单了很多。 也许你在想我们可以直接使用 bind 呐，举个例子： 1234567function add(a, b) &#123; return a + b;&#125;var addOne = add.bind(null, 1);addOne(2) // 3 然而使用 bind 我们还是改变了 this 指向，我们要写一个不改变 this 指向的方法。 第一版根据之前的表述，我们可以尝试着写出第一版： 123456789// 第一版// 似曾相识的代码function partial(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var newArgs = args.concat([].slice.call(arguments)); return fn.apply(this, newArgs); &#125;;&#125;; 我们来写个 demo 验证下 this 的指向： 123456789101112131415function add(a, b) &#123; return a + b + this.value;&#125;// var addOne = add.bind(null, 1);var addOne = partial(add, 1);var value = 1;var obj = &#123; value: 2, addOne: addOne&#125;obj.addOne(2); // ???// 使用 bind 时，结果为 4// 使用 partial 时，结果为 5 第二版然而正如 curry 函数可以使用占位符一样，我们希望 partial 函数也可以实现这个功能，我们再来写第二版： 1234567891011121314// 第二版var _ = &#123;&#125;;function partial(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var position = 0, len = args.length; for(var i = 0; i &lt; len; i++) &#123; args[i] = args[i] === _ ? arguments[position++] : args[i] &#125; while(position &lt; arguments.length) args.push(argumetns[position++]); return fn.apply(this, args); &#125;;&#125;; 我们验证一下： 123var subtract = function(a, b) &#123; return b - a; &#125;;subFrom20 = partial(subtract, _, 20);subFrom20(5); 写在最后值得注意的是：underscore 和 lodash 都提供了 partial 函数，但只有 lodash 提供了 curry 函数。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之类型判断(下)","date":"2019-04-13T07:27:41.343Z","updated":"2019-04-13T07:27:41.343Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之类型判断(下)/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之类型判断(下)/","excerpt":"JavaScript专题之类型判断(下)前言在上篇《JavaScript专题之类型判断(上)》中，我们抄袭 jQuery 写了一个 type 函数，可以检测出常见的数据类型，然而在开发中还有更加复杂的判断，比如 plainObject、空对象、Window 对象等，这一篇就让我们接着抄袭 jQuery 去看一下这些类型的判断。","text":"JavaScript专题之类型判断(下)前言在上篇《JavaScript专题之类型判断(上)》中，我们抄袭 jQuery 写了一个 type 函数，可以检测出常见的数据类型，然而在开发中还有更加复杂的判断，比如 plainObject、空对象、Window 对象等，这一篇就让我们接着抄袭 jQuery 去看一下这些类型的判断。 plainObjectplainObject 来自于 jQuery，可以翻译成纯粹的对象，所谓”纯粹的对象”，就是该对象是通过 “{}” 或 “new Object” 创建的，该对象含有零个或者多个键值对。 之所以要判断是不是 plainObject，是为了跟其他的 JavaScript对象如 null，数组，宿主对象（documents）等作区分，因为这些用 typeof 都会返回object。 jQuery提供了 isPlainObject 方法进行判断，先让我们看看使用的效果： 123456789101112131415function Person(name) &#123; this.name = name;&#125;console.log($.isPlainObject(&#123;&#125;)) // trueconsole.log($.isPlainObject(new Object)) // trueconsole.log($.isPlainObject(Object.create(null))); // trueconsole.log($.isPlainObject(Object.assign(&#123;a: 1&#125;, &#123;b: 2&#125;))); // trueconsole.log($.isPlainObject(new Person('yayu'))); // falseconsole.log($.isPlainObject(Object.create(&#123;&#125;))); // false 由此我们可以看到，除了 {} 和 new Object 创建的之外，jQuery 认为一个没有原型的对象也是一个纯粹的对象。 实际上随着 jQuery 版本的提升，isPlainObject 的实现也在变化，我们今天讲的是 3.0 版本下的 isPlainObject，我们直接看源码： 123456789101112131415161718192021222324252627282930313233343536373839// 上节中写 type 函数时，用来存放 toString 映射结果的对象var class2type = &#123;&#125;;// 相当于 Object.prototype.toStringvar toString = class2type.toString;// 相当于 Object.prototype.hasOwnPropertyvar hasOwn = class2type.hasOwnProperty;function isPlainObject(obj) &#123; var proto, Ctor; // 排除掉明显不是obj的以及一些宿主对象如Window if (!obj || toString.call(obj) !== \"[object Object]\") &#123; return false; &#125; /** * getPrototypeOf es5 方法，获取 obj 的原型 * 以 new Object 创建的对象为例的话 * obj.__proto__ === Object.prototype */ proto = Object.getPrototypeOf(obj); // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true if (!proto) &#123; return true; &#125; /** * 以下判断通过 new Object 方式创建的对象 * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数 */ Ctor = hasOwn.call(proto, \"constructor\") &amp;&amp; proto.constructor; // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数 return typeof Ctor === \"function\" &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);&#125; 注意：我们判断 Ctor 构造函数是不是 Object 构造函数，用的是 hasOwn.toString.call(Ctor)，这个方法可不是 Object.prototype.toString，不信我们在函数里加上下面这两句话： 12console.log(hasOwn.toString.call(Ctor)); // function Object() &#123; [native code] &#125;console.log(Object.prototype.toString.call(Ctor)); // [object Function] 发现返回的值并不一样，这是因为 hasOwn.toString 调用的其实是 Function.prototype.toString，毕竟 hasOwnProperty 可是一个函数！ 而且 Function 对象覆盖了从 Object 继承来的 Object.prototype.toString 方法。函数的 toString 方法会返回一个表示函数源代码的字符串。具体来说，包括 function关键字，形参列表，大括号，以及函数体中的内容。 EmptyObjectjQuery提供了 isEmptyObject 方法来判断是否是空对象，代码简单，我们直接看源码： 12345678910function isEmptyObject( obj ) &#123; var name; for ( name in obj ) &#123; return false; &#125; return true;&#125; 其实所谓的 isEmptyObject 就是判断是否有属性，for 循环一旦执行，就说明有属性，有属性就会返回 false。 但是根据这个源码我们可以看出isEmptyObject实际上判断的并不仅仅是空对象。 举个栗子： 1234567console.log(isEmptyObject(&#123;&#125;)); // trueconsole.log(isEmptyObject([])); // trueconsole.log(isEmptyObject(null)); // trueconsole.log(isEmptyObject(undefined)); // trueconsole.log(isEmptyObject(1)); // trueconsole.log(isEmptyObject('')); // trueconsole.log(isEmptyObject(true)); // true 以上都会返回 true。 但是既然 jQuery 是这样写，可能是因为考虑到实际开发中 isEmptyObject 用来判断 {} 和 {a: 1} 是足够的吧。如果真的是只判断 {}，完全可以结合上篇写的 type 函数筛选掉不适合的情况。 Window对象Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，这点在《JavaScript深入之变量对象》中讲到过。我们可以利用这个特性判断是否是 Window 对象。 123function isWindow( obj ) &#123; return obj != null &amp;&amp; obj === obj.window;&#125; isArrayLikeisArrayLike，看名字可能会让我们觉得这是判断类数组对象的，其实不仅仅是这样，jQuery 实现的 isArrayLike，数组和类数组都会返回 true。 因为源码比较简单，我们直接看源码： 1234567891011121314function isArrayLike(obj) &#123; // obj 必须有 length属性 var length = !!obj &amp;&amp; \"length\" in obj &amp;&amp; obj.length; var typeRes = type(obj); // 排除掉函数和 Window 对象 if (typeRes === \"function\" || isWindow(obj)) &#123; return false; &#125; return typeRes === \"array\" || length === 0 || typeof length === \"number\" &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;&#125; 重点分析 return 这一行，使用了或语句，只要一个为 true，结果就返回 true。 所以如果 isArrayLike 返回true，至少要满足三个条件之一： 是数组 长度为 0 lengths 属性是大于 0 的数组，并且obj[length - 1]必须存在 第一个就不说了，看第二个，为什么长度为 0 就可以直接判断为 true 呢？ 那我们写个对象： 1var obj = &#123;a: 1, b: 2, length: 0&#125; isArrayLike 函数就会返回 true，那这个合理吗？ 回答合不合理之前，我们先看一个例子： 1234function a()&#123; console.log(isArrayLike(arguments))&#125;a(); 如果我们去掉length === 0 这个判断，就会打印 false，然而我们都知道 arguments 是一个类数组对象，这里是应该返回 true 的。 所以是不是为了放过空的 arguments 时也放过了一些存在争议的对象呢？ 第三个条件：length 是数字，并且 length &gt; 0 且最后一个元素存在。 为什么仅仅要求最后一个元素存在呢？ 让我们先想下数组是不是可以这样写： 1var arr = [,,3] 当我们写一个对应的类数组对象就是： 1234var arrLike = &#123; 2: 3, length: 3&#125; 也就是说当我们在数组中用逗号直接跳过的时候，我们认为该元素是不存在的，类数组对象中也就不用写这个元素，但是最后一个元素是一定要写的，要不然 length 的长度就不会是最后一个元素的 key 值加 1。比如数组可以这样写 12var arr = [1,,];console.log(arr.length) // 2 但是类数组对象就只能写成： 1234var arrLike = &#123; 0: 1, length: 1&#125; 所以符合条件的类数组对象是一定存在最后一个元素的！ 这就是满足 isArrayLike 的三个条件，其实除了 jQuery 之外，很多库都有对 isArrayLike 的实现，比如 underscore: 123456var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;var isArrayLike = function(collection) &#123; var length = getLength(collection); return typeof length == 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;&#125;; isElementisElement 判断是不是 DOM 元素。 123isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType === 1);&#125;; 结语这一篇我们介绍了 jQuery 的 isPlainObject、isEmptyObject、isWindow、isArrayLike、以及 underscore 的 isElement 实现。我们可以看到，即使是 jQuery 这样优秀的库，一些方法的实现也并不是非常完美和严密的，但是最后为什么这么做，其实也是一种权衡，权衡所失与所得，正如玉伯在《从 JavaScript 数组去重谈性能优化》中讲到： 所有这些点，都必须脚踏实地在具体应用场景下去分析、去选择，要让场景说话。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之变量对象","date":"2019-04-13T07:27:41.339Z","updated":"2019-04-13T07:27:41.339Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之变量对象/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之变量对象/","excerpt":"JavaScript深入之变量对象 JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言在上篇《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象","text":"JavaScript深入之变量对象 JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言在上篇《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 1console.log(this); 2.全局对象是由 Object 构造函数实例化的一个对象。 1console.log(this instanceof Object); 3.预定义了一堆，嗯，一大堆函数和属性。 123// 都能生效console.log(Math.random());console.log(this.Math.random()); 4.作为全局变量的宿主。 12var a = 1;console.log(this.a); 5.客户端 JavaScript 中，全局对象有 window 属性指向自身。 12345var a = 1;console.log(window.a);this.window.b = 2;console.log(this.b); 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 在进入执行上下文后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题最后让我们看几个例子： 1.第一题 123456789101112function foo() &#123; console.log(a); a = 1;&#125;foo(); // ???function bar() &#123; a = 1; console.log(a);&#125;bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 2.第二题 1234567console.log(foo);function foo()&#123; console.log(\"foo\");&#125;var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 下一篇文章《JavaScript深入之作用域链》 本文相关链接《JavaScript深入之执行上下文栈》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之数组扁平化","date":"2019-04-13T07:27:41.334Z","updated":"2019-04-13T07:27:41.334Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之数组扁平化/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之数组扁平化/","excerpt":"JavaScript专题之数组扁平化扁平化数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。 举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：","text":"JavaScript专题之数组扁平化扁平化数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。 举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：12var arr = [1, [2, [3, 4]]];console.log(flatten(arr)) // [1, 2, 3, 4] 知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了 递归我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法： 123456789101112131415161718// 方法 1var arr = [1, [2, [3, 4]]];function flatten(arr) &#123; var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result;&#125;console.log(flatten(arr)) toString如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为： 1[1, [2, [3, 4]]].toString() // \"1,2,3,4\" 调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？ 12345678910// 方法2var arr = [1, [2, [3, 4]]];function flatten(arr) &#123; return arr.toString().split(',').map(function(item)&#123; return +item &#125;)&#125;console.log(flatten(arr)) 然而这种方法使用的场景却非常有限，如果数组是 [1, ‘1’, 2, ‘2’] 的话，这种方法就会产生错误的结果。 reduce既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码： 12345678910// 方法3var arr = [1, [2, [3, 4]]];function flatten(arr) &#123; return arr.reduce(function(prev, next)&#123; return prev.concat(Array.isArray(next) ? flatten(next) : next) &#125;, [])&#125;console.log(flatten(arr)) …ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： 12var arr = [1, [2, [3, 4]]];console.log([].concat(...arr)); // [1, 2, [3, 4]] 我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： 12345678910111213// 方法4var arr = [1, [2, [3, 4]]];function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125;console.log(flatten(arr)) undercore那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~ 在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。 123456789101112131415161718192021222324252627282930313233343536373839/** * 数组扁平化 * @param &#123;Array&#125; input 要处理的数组 * @param &#123;boolean&#125; shallow 是否只扁平一层 * @param &#123;boolean&#125; strict 是否严格处理元素，下面有解释 * @param &#123;Array&#125; output 这是为了方便递归而传递的参数 * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528 */function flatten(input, shallow, strict, output) &#123; // 递归使用的时候会用到output output = output || []; var idx = output.length; for (var i = 0, len = input.length; i &lt; len; i++) &#123; var value = input[i]; // 如果是数组，就进行处理 if (Array.isArray(value)) &#123; // 如果是只扁平一层，遍历该数组，依此填入 output if (shallow) &#123; var j = 0, len = value.length; while (j &lt; len) output[idx++] = value[j++]; &#125; // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output else &#123; flatten(value, shallow, strict, output); idx = output.length; &#125; &#125; // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output else if (!strict)&#123; output[idx++] = value; &#125; &#125; return output;&#125; 解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子： 12var arr = [1, 2, [3, 4]];console.log(flatten(arr, true, true)); // [3, 4] 那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果： shallow true + strict false ：正常扁平一层 shallow false + strict false ：正常扁平所有层 shallow true + strict true ：去掉非数组元素 shallow false + strict true ： 返回一个[] 我们看看 underscore 中哪些方法调用了 flatten 这个基本函数： _.flatten首先就是 _.flatten： 123_.flatten = function(array, shallow) &#123; return flatten(array, shallow, false);&#125;; 在正常的扁平中，我们并不需要去掉非数组元素。 _.union接下来是 _.union： 该函数传入多个数组，然后返回传入的数组的并集， 举个例子： 12_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);=&gt; [1, 2, 3, 101, 10] 如果传入的参数并不是数组，就会将该参数跳过： 12_.union([1, 2, 3], [101, 2, 1, 10], 4, 5);=&gt; [1, 2, 3, 101, 10] 为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。 12345678// 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27)function unique(array) &#123; return Array.from(new Set(array));&#125;_.union = function() &#123; return unique(flatten(arguments, true, true));&#125; _.difference是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference： 语法为： _.difference(array, *others) 效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。 举个例子： 12_.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);=&gt; [1, 3] 实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值： 12345678function difference(array, ...rest) &#123; rest = flatten(rest, true, true); return array.filter(function(item)&#123; return rest.indexOf(item) === -1; &#125;)&#125; 注意，以上实现的细节并不是完全按照 underscore，具体细节的实现感兴趣可以查看源码。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之创建对象的多种方式以及优缺点","date":"2019-04-13T07:27:41.329Z","updated":"2019-04-13T07:27:41.329Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之创建对象的多种方式以及优缺点/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之创建对象的多种方式以及优缺点/","excerpt":"JavaScript深入之创建对象的多种方式以及优缺点 JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意： 这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson('kevin');","text":"JavaScript深入之创建对象的多种方式以及优缺点 JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意： 这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson('kevin'); 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) &#123; this.name = name; this.getName = function () &#123; console.log(this.name); &#125;;&#125;var person1 = new Person('kevin'); 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 2.1 构造函数模式优化12345678910function Person(name) &#123; this.name = name; this.getName = getName;&#125;function getName() &#123; console.log(this.name);&#125;var person1 = new Person('kevin'); 优点：解决了每个方法都要被重新创建的问题 缺点：这叫啥封装…… 3. 原型模式12345678910function Person(name) &#123;&#125;Person.prototype.name = 'keivn';Person.prototype.getName = function () &#123; console.log(this.name);&#125;;var person1 = new Person(); 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 3.1 原型模式优化123456789101112function Person(name) &#123;&#125;Person.prototype = &#123; name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：封装性好了一点 缺点：重写了原型，丢失了constructor属性 3.2 原型模式优化12345678910111213function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：实例可以通过constructor属性找到所属构造函数 缺点：原型模式该有的缺点还是有 4. 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 4.1 动态原型模式12345678910function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype.getName = function () &#123; console.log(this.name); &#125; &#125;&#125;var person1 = new Person(); 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');// 报错 并没有该方法person1.getName();// 注释掉上面的代码，这句是可以执行的。person2.getName(); 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; return new Person(name); &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');person1.getName(); // kevinperson2.getName(); // daisy 5.1 寄生构造函数模式123456789101112131415function Person(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = new Person('kevin');console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写： 12345678910111213141516171819202122function SpecialArray() &#123; var values = new Array(); for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]); &#125; values.toPipedString = function () &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray('red', 'blue', 'green');var colors2 = SpecialArray('red2', 'blue2', 'green2');console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]);&#125; 可以替换成： 1values.push.apply(values, arguments); 5.2 稳妥构造函数模式1234567891011121314151617function person(name)&#123; var o = new Object(); o.sayName = function()&#123; console.log(name); &#125;; return o;&#125;var person1 = person('kevin');person1.sayName(); // kevinperson1.name = \"daisy\";person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。 下一篇文章JavaScript深入之继承的多种方式和优缺点 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之new的模拟实现》 《JavaScript深入之call和apply的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之从零实现jQuery的extend","date":"2019-04-13T07:27:41.324Z","updated":"2019-04-13T07:27:41.324Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之从零实现jQuery的extend/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之从零实现jQuery的extend/","excerpt":"JavaScript专题之从零实现jQuery的extend前言jQuery 的 extend 是 jQuery 中应用非常多的一个函数，今天我们一边看 jQuery 的 extend 的特性，一边实现一个 extend! extend 基本用法先来看看 extend 的功能，引用 jQuery 官网： Merge the contents of two or more objects together into the first object. 翻译过来就是，合并两个或者更多的对象的内容到第一个对象中。","text":"JavaScript专题之从零实现jQuery的extend前言jQuery 的 extend 是 jQuery 中应用非常多的一个函数，今天我们一边看 jQuery 的 extend 的特性，一边实现一个 extend! extend 基本用法先来看看 extend 的功能，引用 jQuery 官网： Merge the contents of two or more objects together into the first object. 翻译过来就是，合并两个或者更多的对象的内容到第一个对象中。让我们看看 extend 的用法： 1jQuery.extend( target [, object1 ] [, objectN ] ) 第一个参数 target，表示要拓展的目标，我们就称它为目标对象吧。 后面的参数，都传入对象，内容都会复制到目标对象中，我们就称它们为待复制对象吧。 举个例子： 12345678910111213141516171819202122var obj1 = &#123; a: 1, b: &#123; b1: 1, b2: 2 &#125;&#125;;var obj2 = &#123; b: &#123; b1: 3, b3: 4 &#125;, c: 3&#125;;var obj3 = &#123; d: 4&#125;console.log($.extend(obj1, obj2, obj3));// &#123;// a: 1,// b: &#123; b1: 3, b3: 4 &#125;,// c: 3,// d: 4// &#125; 当两个对象出现相同字段的时候，后者会覆盖前者，而不会进行深层次的覆盖。 extend 第一版结合着上篇写得 《JavaScript专题之深浅拷贝》，我们尝试着自己写一个 extend 函数： 123456789101112131415161718192021// 第一版function extend() &#123; var name, options, copy; var length = arguments.length; var i = 1; var target = arguments[0]; for (; i &lt; length; i++) &#123; options = arguments[i]; if (options != null) &#123; for (name in options) &#123; copy = options[name]; if (copy !== undefined)&#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125;; extend 深拷贝那如何进行深层次的复制呢？jQuery v1.1.4 加入了一个新的用法： 1jQuery.extend( [deep], target, object1 [, objectN ] ) 也就是说，函数的第一个参数可以传一个布尔值，如果为 true，我们就会进行深拷贝，false 依然当做浅拷贝，这个时候，target 就往后移动到第二个参数。 还是举这个例子： 12345678910111213141516171819202122var obj1 = &#123; a: 1, b: &#123; b1: 1, b2: 2 &#125;&#125;;var obj2 = &#123; b: &#123; b1: 3, b3: 4 &#125;, c: 3&#125;;var obj3 = &#123; d: 4&#125;console.log($.extend(true, obj1, obj2, obj3));// &#123;// a: 1,// b: &#123; b1: 3, b2: 2, b3: 4 &#125;,// c: 3,// d: 4// &#125; 因为采用了深拷贝，会遍历到更深的层次进行添加和覆盖。 extend 第二版我们来实现深拷贝的功能，值得注意的是： 需要根据第一个参数的类型，确定 target 和要合并的对象的下标起始值。 如果是深拷贝，根据 copy 的类型递归 extend。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 第二版function extend() &#123; // 默认不进行深拷贝 var deep = false; var name, options, src, copy; var length = arguments.length; // 记录要复制的对象的下标 var i = 1; // 第一个参数不传布尔值的情况下，target默认是第一个参数 var target = arguments[0] || &#123;&#125;; // 如果第一个参数是布尔值，第二个参数是才是target if (typeof target == 'boolean') &#123; deep = target; target = arguments[i] || &#123;&#125;; i++; &#125; // 如果target不是对象，我们是无法进行复制的，所以设为&#123;&#125; if (typeof target !== 'object') &#123; target = &#123;&#125; &#125; // 循环遍历要复制的对象们 for (; i &lt; length; i++) &#123; // 获取当前对象 options = arguments[i]; // 要求不能为空 避免extend(a,,b)这种情况 if (options != null) &#123; for (name in options) &#123; // 目标属性值 src = target[name]; // 要复制的对象的属性值 copy = options[name]; if (deep &amp;&amp; copy &amp;&amp; typeof copy == 'object') &#123; // 递归调用 target[name] = extend(deep, src, copy); &#125; else if (copy !== undefined)&#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125;; 在实现上，核心的部分还是跟上篇实现的深浅拷贝函数一致，如果要复制的对象的属性值是一个对象，就递归调用 extend。不过 extend 的实现中，多了很多细节上的判断，比如第一个参数是否是布尔值，target 是否是一个对象，不传参数时的默认值等。 接下来，我们看几个 jQuery 的 extend 使用效果： target 是函数在我们的实现中，typeof target 必须等于 object，我们才会在这个 target 基础上进行拓展，然而我们用 typeof 判断一个函数时，会返回function，也就是说，我们无法在一个函数上进行拓展！ 什么，我们还能在一个函数上进行拓展！！ 当然啦，毕竟函数也是一种对象嘛，让我们看个例子： 12345function a() &#123;&#125;a.target = 'b';console.log(a.target); // b 实际上，在 underscore 的实现中，underscore 的各种方法便是挂在了函数上！ 所以在这里我们还要判断是不是函数，这时候我们便可以使用《JavaScript专题之类型判断(上)》中写得 isFunction 函数 我们这样修改： 123if (typeof target !== \"object\" &amp;&amp; !isFunction(target)) &#123; target = &#123;&#125;;&#125; 类型不一致其实我们实现的方法有个小 bug ，不信我们写个 demo: 12345678910111213141516var obj1 = &#123; a: 1, b: &#123; c: 2 &#125;&#125;var obj2 = &#123; b: &#123; c: [5], &#125;&#125;var d = extend(true, obj1, obj2)console.log(d); 我们预期会返回这样一个对象： 123456&#123; a: 1, b: &#123; c: [5] &#125;&#125; 然而返回了这样一个对象: 12345678&#123; a: 1, b: &#123; c: &#123; 0: 5 &#125; &#125;&#125; 让我们细细分析为什么会导致这种情况： 首先我们在函数的开始写一个 console 函数比如：console.log(1)，然后以上面这个 demo 为例，执行一下，我们会发现 1 打印了三次，这就是说 extend 函数执行了三遍，让我们捋一捋这三遍传入的参数： 第一遍执行到递归调用时： 1234var src = &#123; c: 2 &#125;;var copy = &#123; c: [5]&#125;;target[name] = extend(true, src, copy); 第二遍执行到递归调用时： 1234var src = 2;var copy = [5];target[name] = extend(true, src, copy); 第三遍进行最终的赋值，因为 src 是一个基本类型，我们默认使用一个空对象作为目标值，所以最终的结果就变成了对象的属性！ 为了解决这个问题，我们需要对目标属性值和待复制对象的属性值进行判断： 判断目标属性值跟要复制的对象的属性值类型是否一致: 如果待复制对象属性值类型为数组，目标属性值类型不为数组的话，目标属性值就设为 [] 如果待复制对象属性值类型为对象，目标属性值类型不为对象的话，目标属性值就设为 {} 结合着《JavaScript专题之类型判断(下)》中的 isPlainObject 函数，我们可以对类型进行更细致的划分： 123456789101112131415161718192021var clone, copyIsArray;...if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125;; &#125; target[name] = extend(deep, clone, copy);&#125; else if (copy !== undefined) &#123; target[name] = copy;&#125; 循环引用实际上，我们还可能遇到一个循环引用的问题，举个例子： 1234var a = &#123;name : b&#125;;var b = &#123;name : a&#125;var c = extend(a, b);console.log(c); 我们会得到一个可以无限展开的对象，类似于这样： 为了避免这个问题，我们需要判断要复制的对象属性是否等于 target，如果等于，我们就跳过： 12345678...src = target[name];copy = options[name];if (target === copy) &#123; continue;&#125;... 如果加上这句，结果就会是： 1&#123;name: undefined&#125; 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function extend() &#123; // 默认不进行深拷贝 var deep = false; var name, options, src, copy, clone, copyIsArray; var length = arguments.length; // 记录要复制的对象的下标 var i = 1; // 第一个参数不传布尔值的情况下，target 默认是第一个参数 var target = arguments[0] || &#123;&#125;; // 如果第一个参数是布尔值，第二个参数是 target if (typeof target == 'boolean') &#123; deep = target; target = arguments[i] || &#123;&#125;; i++; &#125; // 如果target不是对象，我们是无法进行复制的，所以设为 &#123;&#125; if (typeof target !== \"object\" &amp;&amp; !isFunction(target)) &#123; target = &#123;&#125;; &#125; // 循环遍历要复制的对象们 for (; i &lt; length; i++) &#123; // 获取当前对象 options = arguments[i]; // 要求不能为空 避免 extend(a,,b) 这种情况 if (options != null) &#123; for (name in options) &#123; // 目标属性值 src = target[name]; // 要复制的对象的属性值 copy = options[name]; // 解决循环引用 if (target === copy) &#123; continue; &#125; // 要递归的对象必须是 plainObject 或者数组 if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) &#123; // 要复制的对象属性值类型需要与目标属性值相同 if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125;; &#125; target[name] = extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125;; 思考题如果觉得看明白了上面的代码，想想下面两个 demo 的结果： 12var a = extend(true, [4, 5, 6, 7, 8, 9], [1, 2, 3]);console.log(a) // ??? 12345678910111213var obj1 = &#123; value: &#123; 3: 1 &#125;&#125;var obj2 = &#123; value: [5, 6, 7],&#125;var b = extend(true, obj1, obj2) // ???var c = extend(true, obj2, obj1) // ??? 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之类数组对象与arguments","date":"2019-04-13T07:27:41.318Z","updated":"2019-04-13T07:27:41.318Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之类数组对象与arguments/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之类数组对象与arguments/","excerpt":"JavaScript深入之类数组对象与arguments JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象","text":"JavaScript深入之类数组对象与arguments JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象举个例子： 12345678var array = ['name', 'age', 'sex'];var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]); // nameconsole.log(arrayLike[0]); // namearray[0] = 'new name';arrayLike[0] = 'new name'; 长度12console.log(array.length); // 3console.log(arrayLike.length); // 3 遍历123456for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 1arrayLike.push('4'); 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用 Function.call 间接调用： 1234567891011var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123; return item.toUpperCase();&#125;); // [\"NAME\", \"AGE\", \"SEX\"] 类数组转对象在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;// 1. sliceArray.prototype.slice.call(arrayLike); // [\"name\", \"age\", \"sex\"] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // 3. ES6 Array.fromArray.from(arrayLike); // [\"name\", \"age\", \"sex\"] // 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 Arguments对象接下来重点讲讲 Arguments 对象。 Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments);&#125;foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，接下来我们一个一个介绍。 length属性Arguments对象的length属性，表示实参的长度，举个例子： 12345678910function foo(b, c, d)&#123; console.log(\"实参的长度为：\" + arguments.length)&#125;console.log(\"形参的长度为：\" + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee属性Arguments 对象的 callee 属性，通过它可以调用函数自身。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = [];for (var i = 0; i &lt; 3; i++) &#123; (data[i] = function () &#123; console.log(arguments.callee.i) &#125;).i = i;&#125;data[0]();data[1]();data[2]();// 0// 1// 2 接下来讲讲 arguments 对象的几个注意要点： arguments 和对应参数的绑定12345678910111213141516171819202122232425262728function foo(name, age, sex, hobbit) &#123; console.log(name, arguments[0]); // name name // 改变形参 name = 'new name'; console.log(name, arguments[0]); // new name new name // 改变arguments arguments[1] = 'new age'; console.log(age, arguments[1]); // new age new age // 测试未传入的是否会绑定 console.log(sex); // undefined sex = 'new sex'; console.log(sex, arguments[2]); // new sex undefined arguments[3] = 'new hobbit'; console.log(hobbit, arguments[3]); // undefined new hobbit&#125;foo('name', 'age') 传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123; bar.apply(this, arguments);&#125;function bar(a, b, c) &#123; console.log(a, b, c);&#125;foo(1, 2, 3) 强大的ES6使用ES6的 … 运算符，我们可以轻松转成数组。 12345function func(...arguments) &#123; console.log(arguments); // [1, 2, 3]&#125;func(1, 2, 3); 应用arguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载… 欢迎留言回复。 下一篇文章JavaScript深入之创建对象的多种方式以及优缺点 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之函数组合","date":"2019-04-13T07:27:41.313Z","updated":"2019-04-13T07:27:41.313Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之函数组合/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之函数组合/","excerpt":"JavaScript专题之函数组合需求我们需要写一个函数，输入 ‘kevin’，返回 ‘HELLO, KEVIN’。 尝试12345678var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var hello = function(x) &#123; return 'HELLO, ' + x; &#125;;var greet = function(x)&#123; return hello(toUpperCase(x));&#125;;greet('kevin'); 还好我们只有两个步骤，首先小写转大写，然后拼接字符串。如果有更多的操作，greet 函数里就需要更多的嵌套，类似于 fn3(fn2(fn1(fn0(x))))。","text":"JavaScript专题之函数组合需求我们需要写一个函数，输入 ‘kevin’，返回 ‘HELLO, KEVIN’。 尝试12345678var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var hello = function(x) &#123; return 'HELLO, ' + x; &#125;;var greet = function(x)&#123; return hello(toUpperCase(x));&#125;;greet('kevin'); 还好我们只有两个步骤，首先小写转大写，然后拼接字符串。如果有更多的操作，greet 函数里就需要更多的嵌套，类似于 fn3(fn2(fn1(fn0(x))))。 优化试想我们写个 compose 函数： 12345var compose = function(f,g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; greet 函数就可以被优化为： 12var greet = compose(hello, toUpperCase);greet('kevin'); 利用 compose 将两个函数组合成一个函数，让代码从右向左运行，而不是由内而外运行，可读性大大提升。这便是函数组合。 但是现在的 compose 函数也只是能支持两个参数，如果有更多的步骤呢？我们岂不是要这样做： 1compose(d, compose(c, compose(b, a))) 为什么我们不写一个帅气的 compose 函数支持传入多个函数呢？这样就变成了： 1compose(d, c, b, a) compose我们直接抄袭 underscore 的 compose 函数的实现： 12345678910function compose() &#123; var args = arguments; var start = args.length - 1; return function() &#123; var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; &#125;;&#125;; 现在的 compose 函数已经可以支持多个函数了，然而有了这个又有什么用呢？ 在此之前，我们先了解一个概念叫做 pointfree。 pointfreepointfree 指的是函数无须提及将要操作的数据是什么样的。依然是以最初的需求为例： 1234567891011121314// 需求：输入 'kevin'，返回 'HELLO, KEVIN'。// 非 pointfree，因为提到了数据：namevar greet = function(name) &#123; return ('hello ' + name).toUpperCase();&#125;// pointfree// 先定义基本运算，这些可以封装起来复用var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var hello = function(x) &#123; return 'HELLO, ' + x; &#125;;var greet = compose(hello, toUpperCase);greet('kevin'); 我们再举个稍微复杂一点的例子，为了方便书写，我们需要借助在《JavaScript专题之函数柯里化》中写到的 curry 函数： 123456789101112131415161718// 需求：输入 'kevin daisy kelly'，返回 'K.D.K'// 非 pointfree，因为提到了数据：namevar initials = function (name) &#123; return name.split(' ').map(compose(toUpperCase, head)).join('. ');&#125;;// pointfree// 先定义基本运算var split = curry(function(separator, str) &#123; return str.split(separator) &#125;)var head = function(str) &#123; return str.slice(0, 1) &#125;var toUpperCase = function(str) &#123; return str.toUpperCase() &#125;var join = curry(function(separator, arr) &#123; return arr.join(separator) &#125;)var map = curry(function(fn, arr) &#123; return arr.map(fn) &#125;)var initials = compose(join('.'), map(compose(toUpperCase, head)), split(' '));initials(\"kevin daisy kelly\"); 从这个例子中我们可以看到，利用柯里化（curry）和函数组合 (compose) 非常有助于实现 pointfree。 也许你会想，这种写法好麻烦呐，我们还需要定义那么多的基础函数……可是如果有工具库已经帮你写好了呢？比如 ramda.js： 12// 使用 ramda.jsvar initials = R.compose(R.join('.'), R.map(R.compose(R.toUpper, R.head)), R.split(' ')); 而且你也会发现： Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。即不使用所要处理的值，只合成运算过程。 那么使用 pointfree 模式究竟有什么好处呢？ pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用，更符合语义，更容易复用，测试也变得轻而易举。 实战这个例子来自于 Favoring Curry： 假设我们从服务器获取这样的数据： 1234567891011121314151617181920212223var data = &#123; result: \"SUCCESS\", tasks: [ &#123;id: 104, complete: false, priority: \"high\", dueDate: \"2013-11-29\", username: \"Scott\", title: \"Do something\", created: \"9/22/2013\"&#125;, &#123;id: 105, complete: false, priority: \"medium\", dueDate: \"2013-11-22\", username: \"Lena\", title: \"Do something else\", created: \"9/22/2013\"&#125;, &#123;id: 107, complete: true, priority: \"high\", dueDate: \"2013-11-22\", username: \"Mike\", title: \"Fix the foo\", created: \"9/22/2013\"&#125;, &#123;id: 108, complete: false, priority: \"low\", dueDate: \"2013-11-15\", username: \"Punam\", title: \"Adjust the bar\", created: \"9/25/2013\"&#125;, &#123;id: 110, complete: false, priority: \"medium\", dueDate: \"2013-11-15\", username: \"Scott\", title: \"Rename everything\", created: \"10/2/2013\"&#125;, &#123;id: 112, complete: true, priority: \"high\", dueDate: \"2013-11-27\", username: \"Lena\", title: \"Alter all quuxes\", created: \"10/5/2013\"&#125; ]&#125;; 我们需要写一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据，然后筛选出这个用户的未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。 以 Scott 为例，最终筛选出的数据为： 123456[ &#123;id: 110, title: \"Rename everything\", dueDate: \"2013-11-15\", priority: \"medium\"&#125;, &#123;id: 104, title: \"Do something\", dueDate: \"2013-11-29\", priority: \"high\"&#125;] 普通的方式为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 第一版 过程式编程var fetchData = function() &#123; // 模拟 return Promise.resolve(data)&#125;;var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(function(data) &#123; return data.tasks; &#125;) .then(function(tasks) &#123; return tasks.filter(function(task) &#123; return task.username == membername &#125;) &#125;) .then(function(tasks) &#123; return tasks.filter(function(task) &#123; return !task.complete &#125;) &#125;) .then(function(tasks) &#123; return tasks.map(function(task) &#123; return &#123; id: task.id, dueDate: task.dueDate, title: task.title, priority: task.priority &#125; &#125;) &#125;) .then(function(tasks) &#123; return tasks.sort(function(first, second) &#123; var a = first.dueDate, b = second.dueDate; return a &lt; b ? -1 : a &gt; b ? 1 : 0; &#125;); &#125;) .then(function(task) &#123; console.log(task) &#125;)&#125;;getIncompleteTaskSummaries('Scott') 如果使用 pointfree 模式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 第二版 pointfree 改写var fetchData = function() &#123; return Promise.resolve(data)&#125;;// 编写基本函数var prop = curry(function(name, obj) &#123; return obj[name];&#125;);var propEq = curry(function(name, val, obj) &#123; return obj[name] === val;&#125;);var filter = curry(function(fn, arr) &#123; return arr.filter(fn)&#125;);var map = curry(function(fn, arr) &#123; return arr.map(fn)&#125;);var pick = curry(function(args, obj)&#123; var result = &#123;&#125;; for (var i = 0; i &lt; args.length; i++) &#123; result[args[i]] = obj[args[i]] &#125; return result;&#125;);var sortBy = curry(function(fn, arr) &#123; return arr.sort(function(a, b)&#123; var a = fn(a), b = fn(b); return a &lt; b ? -1 : a &gt; b ? 1 : 0; &#125;)&#125;);var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(prop('tasks')) .then(filter(propEq('username', membername))) .then(filter(propEq('complete', false))) .then(map(pick(['id', 'dueDate', 'title', 'priority']))) .then(sortBy(prop('dueDate'))) .then(console.log)&#125;;getIncompleteTaskSummaries('Scott') 如果直接使用 ramda.js，你可以省去编写基本函数: 12345678910111213141516// 第三版 使用 ramda.jsvar fetchData = function() &#123; return Promise.resolve(data)&#125;;var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(R.prop('tasks')) .then(R.filter(R.propEq('username', membername))) .then(R.filter(R.propEq('complete', false))) .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority']))) .then(R.sortBy(R.prop('dueDate'))) .then(console.log)&#125;;getIncompleteTaskSummaries('Scott') 当然了，利用 compose，你也可以这样写： 12345678910111213141516171819// 第四版 使用 composevar fetchData = function() &#123; return Promise.resolve(data)&#125;;var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(R.compose( console.log, R.sortBy(R.prop('dueDate')), R.map(R.pick(['id', 'dueDate', 'title', 'priority']) ), R.filter(R.propEq('complete', false)), R.filter(R.propEq('username', membername)), R.prop('tasks'), ))&#125;;getIncompleteTaskSummaries('Scott') compose 是从右到左依此执行，当然你也可以写一个从左到右的版本，但是从右向左执行更加能够反映数学上的含义。 ramda.js 提供了一个 R.pipe 函数，可以做的从左到右，以上可以改写为： 12345678910111213// 第五版 使用 R.pipevar getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(R.pipe( ), R.prop('tasks'), R.filter(R.propEq('username', membername)), R.filter(R.propEq('complete', false)), R.map(R.pick(['id', 'dueDate', 'title', 'priority']) R.sortBy(R.prop('dueDate')), console.log, ))&#125;; 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之从ECMAScript规范解读this","date":"2019-04-13T07:27:41.309Z","updated":"2019-04-13T07:27:41.310Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之从ECMAScript规范解读this/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之从ECMAScript规范解读this/","excerpt":"JavaScript深入之从ECMAScript规范解读this JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。","text":"JavaScript深入之从ECMAScript规范解读this JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。…… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！ Types首先是第 8 章 Types： Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript 的类型分为语言类型和规范类型。 ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。 而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。 Reference那什么又是 Reference ？ 让我们看 8.7 章 The Reference Specification Type： The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1;// 对应的Reference是：var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 再举个例子： 1234567891011121314var foo = &#123; bar: function () &#123; return this; &#125;&#125;; foo.bar(); // foo// bar对应的Reference是：var BarReference = &#123; base: foo, propertyName: 'bar', strict: false&#125;; 而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 这两个方法很简单，简单看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1;var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;;GetValue(fooReference) // 1; GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定this的值关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段： 看规范 11.2.3 Function Calls： 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then a.If IsPropertyReference(ref) is true, then i.Let thisValue be GetBase(ref). b.Else, the base of ref is an Environment Record i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 7.Else, Type(ref) is not Reference. a. Let thisValue be undefined. 让我们描述一下： 1.计算 MemberExpression 的结果赋值给 ref 2.判断 ref 是不是一个 Reference 类型 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo(); // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()(); // MemberExpression 是 foo()var foo = &#123; bar: function () &#123; return this; &#125;&#125;foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 2.判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。 举最后一个例子： 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = &#123; base: foo, name: 'bar', strict: false&#125;; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： 1this = GetBase(ref)， GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！ 唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例2： 1console.log((foo.bar)()); foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例5，逗号操作符，查看规范11.14 Comma Operator ( , ) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 1234567891011121314151617181920var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() &#123; console.log(this)&#125;foo(); MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;console.log((false || foo.bar)()); // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。 下一篇文章《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之解读v8排序源码","date":"2019-04-13T07:27:41.305Z","updated":"2019-04-13T07:27:41.306Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之解读v8排序源码/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之解读v8排序源码/","excerpt":"JavaScript专题之解读 v8 排序源码前言v8 是 Chrome 的 JavaScript 引擎，其中关于数组的排序完全采用了 JavaScript 实现。 排序采用的算法跟数组的长度有关，当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。(当然了，这种说法并不严谨)。 我们先来看看插入排序和快速排序。","text":"JavaScript专题之解读 v8 排序源码前言v8 是 Chrome 的 JavaScript 引擎，其中关于数组的排序完全采用了 JavaScript 实现。 排序采用的算法跟数组的长度有关，当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。(当然了，这种说法并不严谨)。 我们先来看看插入排序和快速排序。 插入排序原理将第一个元素视为有序序列，遍历数组，将之后的元素依次插入这个构建的有序序列中。 图示 实现12345678910111213141516171819function insertionSort(arr) &#123; for (var i = 1; i &lt; arr.length; i++) &#123; var element = arr[i]; for (var j = i - 1; j &gt;= 0; j--) &#123; var tmp = arr[j]; var order = tmp - element; if (order &gt; 0) &#123; arr[j + 1] = tmp; &#125; else &#123; break; &#125; &#125; arr[j + 1] = element; &#125; return arr;&#125;var arr = [6, 5, 4, 3, 2, 1];console.log(insertionSort(arr)); 时间复杂度时间复杂度是指执行算法所需要的计算工作量，它考察当输入值大小趋近无穷时的情况，一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数。 最好情况：数组升序排列，时间复杂度为：O(n) 最坏情况：数组降序排列，时间复杂度为：O(n²) 稳定性稳定性，是指相同的元素在排序后是否还保持相对的位置。 要注意的是对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。 比如 [3, 3, 1]，排序后，还是 [3, 3, 1]，但是其实是第二个 3 在 第一个 3 前，那这就是不稳定的排序算法。 插入排序是稳定的算法。 优势当数组是快要排序好的状态或者问题规模比较小的时候，插入排序效率更高。这也是为什么 v8 会在数组长度小于等于 10 的时候采用插入排序。 快速排序原理 选择一个元素作为”基准” 小于”基准”的元素，都移到”基准”的左边；大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 示例示例和下面的实现方式来源于阮一峰老师的《快速排序（Quicksort）的Javascript实现》 以数组 [85, 24, 63, 45, 17, 31, 96, 50] 为例： 第一步，选择中间的元素 45 作为”基准”。（基准值可以任意选择，但是选择中间的值比较容易理解。） 第二步，按照顺序，将每个元素与”基准”进行比较，形成两个子集，一个”小于45”，另一个”大于等于45”。 第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 实现123456789101112131415161718var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; // 取数组的中间元素作为基准 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 然而这种实现方式需要额外的空间用来储存左右子集，所以还有一种原地(in-place)排序的实现方式。 图示我们来看看原地排序的实现图示： 为了让大家看明白快速排序的原理，我调慢了执行速度。 在这张示意图里，基准的取值规则是取最左边的元素，黄色代表当前的基准，绿色代表小于基准的元素，紫色代表大于基准的元素。 我们会发现，绿色的元素会紧挨在基准的右边，紫色的元素会被移到后面，然后交换基准和绿色的最后一个元素，此时，基准处于正确的位置，即前面的元素都小于基准值，后面的元素都大于基准值。然后再对前面的和后面的多个元素取基准，做排序。 in-place 实现12345678910111213141516171819202122232425262728293031323334353637function quickSort(arr) &#123; // 交换元素 function swap(arr, a, b) &#123; var temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; function partition(arr, left, right) &#123; var pivot = arr[left]; var storeIndex = left; for (var i = left + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; pivot) &#123; swap(arr, ++storeIndex, i); &#125; &#125; swap(arr, left, storeIndex); return storeIndex; &#125; function sort(arr, left, right) &#123; if (left &lt; right) &#123; var storeIndex = partition(arr, left, right); sort(arr, left, storeIndex - 1); sort(arr, storeIndex + 1, right); &#125; &#125; sort(arr, 0, arr.length - 1); return arr;&#125;console.log(quickSort(6, 7, 3, 4, 1, 5, 9, 2, 8)) 稳定性快速排序是不稳定的排序。如果要证明一个排序是不稳定的，你只用举出一个实例就行。 所以我们举一个呗~ 就以数组 [1, 2, 3, 3, 4, 5] 为例，因为基准的选择不确定，假如选定了第三个元素(也就是第一个 3) 为基准，所有小于 3 的元素在前面，大于等于 3 的在后面，排序的结果没有问题。可是如果选择了第四个元素(也就是第二个 3 )，小于 3 的在基准前面，大于等于 3 的在基准后面，第一个 3 就会被移动到 第二个 3 后面，所以快速排序是不稳定的排序。 时间复杂度阮一峰老师的实现中，基准取的是中间元素，而原地排序中基准取最左边的元素。快速排序的关键点就在于基准的选择，选取不同的基准时，会有不同性能表现。 快速排序的时间复杂度最好为 O(nlogn)，可是为什么是 nlogn 呢？来一个并不严谨的证明： 在最佳情况下，每一次都平分整个数组。假设数组有 n 个元素，其递归的深度就为 log2n + 1，时间复杂度为 O(n)[(log2n + 1)]，因为时间复杂度考察当输入值大小趋近无穷时的情况，所以会忽略低阶项，时间复杂度为：o(nlog2n)。 如果一个程序的运行时间是对数级的，则随着 n 的增大程序会渐渐慢下来。如果底数是 10，lg1000 等于 3，如果 n 为 1000000，lgn 等于 6，仅为之前的两倍。如果底数为 2，log21000 的值约为 10，log21000000 的值约为 19，约为之前的两倍。我们可以发现任意底数的一个对数函数其实都相差一个常数倍而已。所以我们认为 O(logn)已经可以表达所有底数的对数了，所以时间复杂度最后为： O(nlogn)。 而在最差情况下，如果对一个已经排序好的数组，每次选择基准元素时总是选择第一个元素或者最后一个元素，那么每次都会有一个子集是空的，递归的层数将达到 n，最后导致算法的时间复杂度退化为 O(n²)。 这也充分说明了一个基准的选择是多么的重要，而 v8 为了提高性能，就对基准的选择做了很多优化。 v8 基准选择v8 选择基准的原理是从头和尾之外再选择一个元素，然后三个值排序取中间值。 当数组长度大于 10 但是小于 1000 的时候，取中间位置的元素，实现代码为： 123// 基准的下标// &gt;&gt; 1 相当于除以 2 (忽略余数)third_index = from + ((to - from) &gt;&gt; 1); 当数组长度大于 1000 的时候，每隔 200 ~ 215 个元素取一个值，然后将这些值进行排序，取中间值的下标，实现的代码为： 1234567891011121314151617181920212223// 简单处理过function GetThirdIndex(a, from, to) &#123; var t_array = new Array(); // &amp; 位运算符 var increment = 200 + ((to - from) &amp; 15); var j = 0; from += 1; to -= 1; for (var i = from; i &lt; to; i += increment) &#123; t_array[j] = [i, a[i]]; j++; &#125; // 对随机挑选的这些值进行排序 t_array.sort(function(a, b) &#123; return comparefn(a[1], b[1]); &#125;); // 取中间值的下标 var third_index = t_array[t_array.length &gt;&gt; 1][0]; return third_index;&#125; 也许你会好奇 200 + ((to - from) &amp; 15) 是什么意思？ &amp; 表示是按位与，对整数操作数逐位执行布尔与操作。只有两个操作数中相对应的位都是 1，结果中的这一位才是 1。 以 15 &amp; 127 为例： 15 二进制为： （0000 1111） 127 二进制为：（1111 1111） 按位与结果为：（0000 1111）＝ 15 所以 15 &amp; 127 的结果为 15。 注意 15 的二进制为： 1111，这就意味着任何和 15 按位与的结果都会小于或者等于 15，这才实现了每隔 200 ~ 215 个元素取一个值。 v8 源码终于到了看源码的时刻！源码地址为：https://github.com/v8/v8/blob/master/src/js/array.js#L758。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121function InsertionSort(a, from, to) &#123; for (var i = from + 1; i &lt; to; i++) &#123; var element = a[i]; for (var j = i - 1; j &gt;= from; j--) &#123; var tmp = a[j]; var order = comparefn(tmp, element); if (order &gt; 0) &#123; a[j + 1] = tmp; &#125; else &#123; break; &#125; &#125; a[j + 1] = element; &#125;&#125;;function QuickSort(a, from, to) &#123; var third_index = 0; while (true) &#123; // Insertion sort is faster for short arrays. if (to - from &lt;= 10) &#123; InsertionSort(a, from, to); return; &#125; if (to - from &gt; 1000) &#123; third_index = GetThirdIndex(a, from, to); &#125; else &#123; third_index = from + ((to - from) &gt;&gt; 1); &#125; // Find a pivot as the median of first, last and middle element. var v0 = a[from]; var v1 = a[to - 1]; var v2 = a[third_index]; var c01 = comparefn(v0, v1); if (c01 &gt; 0) &#123; // v1 &lt; v0, so swap them. var tmp = v0; v0 = v1; v1 = tmp; &#125; // v0 &lt;= v1. var c02 = comparefn(v0, v2); if (c02 &gt;= 0) &#123; // v2 &lt;= v0 &lt;= v1. var tmp = v0; v0 = v2; v2 = v1; v1 = tmp; &#125; else &#123; // v0 &lt;= v1 &amp;&amp; v0 &lt; v2 var c12 = comparefn(v1, v2); if (c12 &gt; 0) &#123; // v0 &lt;= v2 &lt; v1 var tmp = v1; v1 = v2; v2 = tmp; &#125; &#125; // v0 &lt;= v1 &lt;= v2 a[from] = v0; a[to - 1] = v2; var pivot = v1; var low_end = from + 1; // Upper bound of elements lower than pivot. var high_start = to - 1; // Lower bound of elements greater than pivot. a[third_index] = a[low_end]; a[low_end] = pivot; // From low_end to i are elements equal to pivot. // From i to high_start are elements that haven't been compared yet. partition: for (var i = low_end + 1; i &lt; high_start; i++) &#123; var element = a[i]; var order = comparefn(element, pivot); if (order &lt; 0) &#123; a[i] = a[low_end]; a[low_end] = element; low_end++; &#125; else if (order &gt; 0) &#123; do &#123; high_start--; if (high_start == i) break partition; var top_elem = a[high_start]; order = comparefn(top_elem, pivot); &#125; while (order &gt; 0); a[i] = a[high_start]; a[high_start] = element; if (order &lt; 0) &#123; element = a[i]; a[i] = a[low_end]; a[low_end] = element; low_end++; &#125; &#125; &#125; if (to - high_start &lt; low_end - from) &#123; QuickSort(a, high_start, to); to = low_end; &#125; else &#123; QuickSort(a, from, low_end); from = high_start; &#125; &#125;&#125;var arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];function comparefn(a, b) &#123; return a - b&#125;QuickSort(arr, 0, arr.length)console.log(arr) 我们以数组 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 为例，分析执行的过程。 1.执行 QuickSort 函数 参数 from 值为 0，参数 to 的值 11。 2.10 &lt; to - from &lt; 1000 第三个基准元素的下标为 (0 + 11 &gt;&gt; 1) = 5，基准值 a[5] 为 5。 3.比较 a[0] a[10] a[5] 的值，然后根据比较结果修改数组，数组此时为 [0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10] 4.将基准值和数组的第(from + 1)个即数组的第二个元素互换，此时数组为 [0, 5, 8, 7, 6, 9, 4, 3, 2, 1, 10]，此时在基准值 5 前面的元素肯定是小于 5 的，因为第三步已经做了一次比较。后面的元素是未排序的。 我们接下来要做的就是把后面的元素中小于 5 的全部移到 5 的前面。 5.然后我们进入 partition 循环，我们依然以这个数组为例，单独抽出来写个 demo 讲一讲 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 假设代码执行到这里，为了方便演示，我们直接设置 low_end 等变量的值// 可以直接复制到浏览器中查看数组变换效果var a = [0, 5, 8, 7, 6, 9, 4, 3, 2, 1, 10]var low_end = 1;var high_start = 10;var pivot = 5;console.log('起始数组为', a)partition: for (var i = low_end + 1; i &lt; high_start; i++) &#123; var element = a[i]; console.log('循环当前的元素为：', a[i]) var order = element - pivot; if (order &lt; 0) &#123; a[i] = a[low_end]; a[low_end] = element; low_end++; console.log(a) &#125; else if (order &gt; 0) &#123; do &#123; high_start--; if (high_start == i) break partition; var top_elem = a[high_start]; order = top_elem - pivot; &#125; while (order &gt; 0); a[i] = a[high_start]; a[high_start] = element; console.log(a) if (order &lt; 0) &#123; element = a[i]; a[i] = a[low_end]; a[low_end] = element; low_end++; &#125; console.log(a) &#125;&#125;console.log('最后的结果为', a)console.log(low_end)console.log(high_start) 6.此时数组为 [0, 5, 8, 7, 6, 9, 4, 3, 2, 1, 10]，循环从第三个元素开始，a[i] 的值为 8，因为大于基准值 5，即 order &gt; 0，开始执行 do while 循环，do while 循环的目的在于倒序查找元素，找到第一个小于基准值的元素，然后让这个元素跟 a[i] 的位置交换。第一个小于基准值的元素为 1，然后 1 与 8 交换，数组变成 [0, 5, 1, 7, 6, 9, 4, 3, 2, 8, 10]。high_start 的值是为了记录倒序查找到哪里了。 7.此时 a[i] 的值变成了 1，然后让 1 跟 基准值 5 交换，数组变成了 [0, 1, 5, 7, 6, 9, 4, 3, 2, 8, 10]，low_end 的值加 1，low_end 的值是为了记录基准值的所在位置。 8.循环接着执行，遍历第四个元素 7，跟第 6、7 的步骤一致，数组先变成 [0, 1, 5, 2, 6, 9, 4, 3, 7, 8, 10]，再变成 [0, 1, 2, 5, 6, 9, 4, 3, 7, 8, 10] 9.遍历第五个元素 6，跟第 6、7 的步骤一致，数组先变成 [0, 1, 2, 5, 3, 9, 4, 6, 7, 8, 10]，再变成 [0, 1, 2, 3, 5, 9, 4, 6, 7, 8, 10] 10.遍历第六个元素 9，跟第 6、7 的步骤一致，数组先变成 [0, 1, 2, 3, 5, 4, 9, 6, 7, 8, 10]，再变成 [0, 1, 2, 3, 4, 5, 9, 6, 7, 8, 10] 11.在下一次遍历中，因为 i == high_start，意味着正序和倒序的查找终于找到一起了，后面的元素肯定都是大于基准值的，此时退出循环 12.遍历后的结果为 [0, 1, 2, 3, 4, 5, 9, 6, 7, 8, 10]，在基准值 5 前面的元素都小于 5，后面的元素都大于 5，然后我们分别对两个子集进行 QuickSort 13.此时 low_end 值为 5，high_start 值为 6，to 的值依然是 10，from 的值依然是 0，to - high_start &lt; low_end - from 的结果为 true，我们对 QuickSort(a, 6, 10)，即对后面的元素进行排序，但是注意，在新的 QuickSort 中，因为 from - to 的值小于 10，所以这一次其实是采用了插入排序。所以准确的说，当数组长度大于 10 的时候，v8 采用了快速排序和插入排序的混合排序方法。 14.然后 to = low_end 即设置 to 为 5，因为 while(true) 的原因，会再执行一遍，to - from 的值为 5，执行 InsertionSort(a, 0, 5)，即对基准值前面的元素执行一次插入排序。 15.因为在 to - from &lt;= 10 的判断中，有 return 语句，所以 while 循环结束。 16.v8 在对数组进行了一次快速排序后，然后对两个子集分别进行了插入排序，最终修改数组为正确排序后的数组。 比较最后来张示意图感受下插入排序和快速排序： 图片来自于 https://www.toptal.com/developers/sorting-algorithms 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之参数按值传递","date":"2019-04-13T07:27:41.301Z","updated":"2019-04-13T07:27:41.301Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之参数按值传递/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之参数按值传递/","excerpt":"JavaScript深入之参数按值传递 JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value) // 1","text":"JavaScript深入之参数按值传递 JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value) // 1 很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。 引用传递拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所以还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o.value = 2; console.log(o.value); //2&#125;foo(obj);console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按引用传递成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o = 2; console.log(o); //2&#125;foo(obj);console.log(obj.value) // 1 如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递是指，在传递对象的时候，传递对象的引用的副本。 注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！ 所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。 所以，高程，谁叫你是红宝书嘞！ 下一篇文章JavaScript深入之call和apply的模拟实现 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之跟着underscore学节流","date":"2019-04-13T07:27:41.297Z","updated":"2019-04-13T07:27:41.297Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之跟着underscore学节流/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之跟着underscore学节流/","excerpt":"JavaScript专题之跟着 underscore 学节流前言在《JavaScript专题之跟着underscore学防抖》中，我们了解了为什么要限制事件的频繁触发，以及如何做限制： debounce 防抖 throttle 节流 今天重点讲讲节流的实现。","text":"JavaScript专题之跟着 underscore 学节流前言在《JavaScript专题之跟着underscore学防抖》中，我们了解了为什么要限制事件的频繁触发，以及如何做限制： debounce 防抖 throttle 节流 今天重点讲讲节流的实现。 节流节流的原理很简单： 如果你持续触发事件，每隔一段时间，只执行一次事件。 根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。 使用时间戳让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 看了这个表述，是不是感觉已经可以写出代码了…… 让我们来写第一版的代码： 123456789101112131415// 第一版function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 例子依然是用讲 debounce 中的例子，如果你要使用： 1container.onmousemove = throttle(getUserAction, 1000); 效果演示如下： 我们可以看到：当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。 使用定时器接下来，我们讲讲第二种实现方式，使用定时器。 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。 1234567891011121314151617// 第二版function throttle(func, wait) &#123; var timeout; var previous = 0; return function() &#123; context = this; args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 为了让效果更加明显，我们设置 wait 的时间为 3s，效果演示如下： 我们可以看到：当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。 所以比较两个方法： 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 双剑合璧那我们想要一个什么样的呢？ 有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！ 所以我们综合两者的优势，然后双剑合璧，写一版代码： 12345678910111213141516171819202122232425262728293031// 第三版function throttle(func, wait) &#123; var timeout, context, args, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; func.apply(context, args) &#125;; var throttled = function() &#123; var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 效果演示如下： 我们可以看到：鼠标移入，事件立刻执行，晃了 3s，事件再一次执行，当数字变成 3 的时候，也就是 6s 后，我们立刻移出鼠标，停止触发事件，9s 的时候，依然会再执行一次事件。 优化但是我有时也希望无头有尾，或者有头无尾，这个咋办？ 那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定: leading：false 表示禁用第一次执行trailing: false 表示禁用停止触发的回调 我们来改一下代码： 123456789101112131415161718192021222324252627282930313233// 第四版function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 取消在 debounce 的实现中，我们加了一个 cancel 方法，throttle 我们也加个 cancel 方法： 12345678// 第五版 非完整代码，完整代码请查看最后的演示代码链接...throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null;&#125;... 注意我们要注意 underscore 的实现中有这样一个问题： 那就是 leading：false 和 trailing: false 不能同时设置。 如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了，所以，这个 throttle 只有三种用法： 1234567container.onmousemove = throttle(getUserAction, 1000);container.onmousemove = throttle(getUserAction, 1000, &#123; leading: false&#125;);container.onmousemove = throttle(getUserAction, 1000, &#123; trailing: false&#125;); 至此我们已经完整实现了一个 underscore 中的 throttle 函数，恭喜，撒花！ 演示代码相关的代码可以在 Github 博客仓库 中找到 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之继承的多种方式和优缺点","date":"2019-04-13T07:27:41.293Z","updated":"2019-04-13T07:27:41.293Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之继承的多种方式和优缺点/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之继承的多种方式和优缺点/","excerpt":"JavaScript深入之继承的多种方式和优缺点 JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面本文讲解JavaScript各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！","text":"JavaScript深入之继承的多种方式和优缺点 JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面本文讲解JavaScript各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！ 1.原型链继承1234567891011121314151617function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向Parent传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 1234567891011121314151617181920212223242526272829303132function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之new的模拟实现》 《JavaScript深入之创建对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之乱序","date":"2019-04-13T07:27:41.290Z","updated":"2019-04-13T07:27:41.290Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之乱序/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之乱序/","excerpt":"","text":"JavaScript专题之乱序乱序乱序的意思就是将数组打乱。 嗯，没有了，直接看代码吧。 Math.random一个经常会遇见的写法是使用 Math.random()： 1234567var values = [1, 2, 3, 4, 5];&lt;!-- more --&gt;values.sort(function()&#123; return Math.random() - 0.5;&#125;);console.log(values) Math.random() - 0.5 随机得到一个正数、负数或是 0，如果是正数则降序排列，如果是负数则升序排列，如果是 0 就不变，然后不断的升序或者降序，最终得到一个乱序的数组。 看似很美好的一个方案，实际上，效果却不尽如人意。不信我们写个 demo 测试一下： 12345678910111213var times = [0, 0, 0, 0, 0];for (var i = 0; i &lt; 100000; i++) &#123; let arr = [1, 2, 3, 4, 5]; arr.sort(() =&gt; Math.random() - 0.5); times[arr[4]-1]++;&#125;console.log(times) 测试原理是：将 [1, 2, 3, 4, 5] 乱序 10 万次，计算乱序后的数组的最后一个元素是 1、2、3、4、5 的次数分别是多少。 一次随机的结果为： 1[30636, 30906, 20456, 11743, 6259] 该结果表示 10 万次中，数组乱序后的最后一个元素是 1 的情况共有 30636 次，是 2 的情况共有 30906 次，其他依此类推。 我们会发现，最后一个元素为 5 的次数远远低于为 1 的次数，所以这个方案是有问题的。 可是我明明感觉这个方法还不错呐？初见时还有点惊艳的感觉，为什么会有问题呢？ 是的！我很好奇！ 插入排序如果要追究这个问题所在，就必须了解 sort 函数的原理，然而 ECMAScript 只规定了效果，没有规定实现的方式，所以不同浏览器实现的方式还不一样。 为了解决这个问题，我们以 v8 为例，v8 在处理 sort 方法时，当目标数组长度小于 10 时，使用插入排序；反之，使用快速排序和插入排序的混合排序。 所以我们来看看 v8 的源码，因为是用 JavaScript 写的，大家也是可以看懂的。 源码地址：https://github.com/v8/v8/blob/master/src/js/array.js 为了简化篇幅，我们对 [1, 2, 3] 这个数组进行分析，数组长度为 3，此时采用的是插入排序。 插入排序的源码是： 123456789101112131415function InsertionSort(a, from, to) &#123; for (var i = from + 1; i &lt; to; i++) &#123; var element = a[i]; for (var j = i - 1; j &gt;= from; j--) &#123; var tmp = a[j]; var order = comparefn(tmp, element); if (order &gt; 0) &#123; a[j + 1] = tmp; &#125; else &#123; break; &#125; &#125; a[j + 1] = element; &#125;&#125;; 其原理在于将第一个元素视为有序序列，遍历数组，将之后的元素依次插入这个构建的有序序列中。 我们来个简单的示意图： 具体分析明白了插入排序的原理，我们来具体分析下 [1, 2, 3] 这个数组乱序的结果。 演示代码为： 12345var values = [1, 2, 3];values.sort(function()&#123; return Math.random() - 0.5;&#125;); 注意此时 sort 函数底层是使用插入排序实现，InsertionSort 函数的 from 的值为 0，to 的值为 3。 我们开始逐步分析乱序的过程： 因为插入排序视第一个元素为有序的，所以数组的外层循环从 i = 1 开始，a[i] 值为 2，此时内层循环遍历，比较 compare(1, 2)，因为 Math.random() - 0.5 的结果有 50% 的概率小于 0 ，有 50% 的概率大于 0，所以有 50% 的概率数组变成 [2, 1, 3]，50% 的结果不变，数组依然为 [1, 2, 3]。 假设依然是 [1, 2, 3]，我们再进行一次分析，接着遍历，i = 2，a[i] 的值为 3，此时内层循环遍历，比较 compare(2, 3)： 有 50% 的概率数组不变，依然是 [1, 2, 3]，然后遍历结束。 有 50% 的概率变成 [1, 3, 2]，因为还没有找到 3 正确的位置，所以还会进行遍历，所以在这 50% 的概率中又会进行一次比较，compare(1, 3)，有 50% 的概率不变，数组为 [1, 3, 2]，此时遍历结束，有 50% 的概率发生变化，数组变成 [3, 1, 2]。 综上，在 [1, 2, 3] 中，有 50% 的概率会变成 [1, 2, 3]，有 25% 的概率会变成 [1, 3, 2]，有 25% 的概率会变成 [3, 1, 2]。 另外一种情况 [2, 1, 3] 与之分析类似，我们将最终的结果汇总成一个表格： 数组 i = 1 i = 2 总计 [1, 2, 3] 50% [1, 2, 3] 50% [1, 2, 3] 25% [1, 2, 3] 25% [1, 3, 2] 12.5% [1, 3, 2] 25% [3, 1, 2] 12.5% [3, 1, 2] 50% [2, 1, 3] 50% [2, 1, 3] 25% [2, 1, 3] 25% [2, 3, 1] 12.5% [2, 3, 1] 25% [3, 2, 1] 12.5% [3, 2, 1] 为了验证这个推算是否准确，我们写个 demo 测试一下： 123456789101112131415161718var times = 100000;var res = &#123;&#125;;for (var i = 0; i &lt; times; i++) &#123; var arr = [1, 2, 3]; arr.sort(() =&gt; Math.random() - 0.5); var key = JSON.stringify(arr); res[key] ? res[key]++ : res[key] = 1;&#125;// 为了方便展示，转换成百分比for (var key in res) &#123; res[key] = res[key] / times * 100 + '%'&#125;console.log(res) 这是一次随机的结果： 我们会发现，乱序后，3 还在原位置(即 [1, 2, 3] 和 [2, 1, 3]) 的概率有 50% 呢。 所以根本原因在于什么呢？其实就在于在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底。 那么如何实现真正的乱序呢？而这就要提到经典的 Fisher–Yates 算法。 Fisher–Yates为什么叫 Fisher–Yates 呢？ 因为这个算法是由 Ronald Fisher 和 Frank Yates 首次提出的。 话不多说，我们直接看 JavaScript 的实现： 12345678910function shuffle(a) &#123; var j, x, i; for (i = a.length; i; i--) &#123; j = Math.floor(Math.random() * i); x = a[i - 1]; a[i - 1] = a[j]; a[j] = x; &#125; return a;&#125; 原理很简单，就是遍历数组元素，然后将当前元素与以后随机位置的元素进行交换，从代码中也可以看出，这样乱序的就会更加彻底。 如果利用 ES6，代码还可以简化成： 1234567function shuffle(a) &#123; for (let i = a.length; i; i--) &#123; let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; &#125; return a;&#125; 还是再写个 demo 测试一下吧： 12345678910111213141516var times = 100000;var res = &#123;&#125;;for (var i = 0; i &lt; times; i++) &#123; var arr = shuffle([1, 2, 3]); var key = JSON.stringify(arr); res[key] ? res[key]++ : res[key] = 1;&#125;// 为了方便展示，转换成百分比for (var key in res) &#123; res[key] = res[key] / times * 100 + '%'&#125;console.log(res) 这是一次随机的结果： 真正的实现了乱序的效果！ 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之数组去重","date":"2019-04-13T07:27:41.281Z","updated":"2019-04-13T07:27:41.281Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之数组去重/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之数组去重/","excerpt":"","text":"JavaScript专题之数组去重前言数组去重方法老生常谈，既然是常谈，我也来谈谈。 双层循环也许我们首先想到的是使用 indexOf 来循环判断一遍，但在这个方法之前，让我们先看看最原始的方法： 1234567891011121314151617181920var array = [1, 1, '1', '1'];&lt;!-- more --&gt;function unique(array) &#123; // res用来存储结果 var res = []; for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) &#123; for (var j = 0, resLen = res.length; j &lt; resLen; j++ ) &#123; if (array[i] === res[j]) &#123; break; &#125; &#125; // 如果array[i]是唯一的，那么执行完循环，j等于resLen if (j === resLen) &#123; res.push(array[i]) &#125; &#125; return res;&#125;console.log(unique(array)); // [1, \"1\"] 在这个方法中，我们使用循环嵌套，最外层循环 array，里面循环 res，如果 array[i] 的值跟 res[j] 的值相等，就跳出循环，如果都不等于，说明元素是唯一的，这时候 j 的值就会等于 res 的长度，根据这个特点进行判断，将值添加进 res。 看起来很简单吧，之所以要讲一讲这个方法，是因为——————兼容性好！ indexOf我们可以用 indexOf 简化内层的循环： 1234567891011121314var array = [1, 1, '1'];function unique(array) &#123; var res = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i]; if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125;console.log(unique(array)); 排序后去重试想我们先将要去重的数组使用 sort 方法排序后，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，相同就说明重复，不相同就添加进 res，让我们写个 demo： 1234567891011121314151617var array = [1, 1, '1'];function unique(array) &#123; var res = []; var sortedArray = array.concat().sort(); var seen; for (var i = 0, len = sortedArray.length; i &lt; len; i++) &#123; // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) &#123; res.push(sortedArray[i]) &#125; seen = sortedArray[i]; &#125; return res;&#125;console.log(unique(array)); 如果我们对一个已经排好序的数组去重，这种方法效率肯定高于使用 indexOf。 unique API知道了这两种方法后，我们可以去尝试写一个名为 unique 的工具函数，我们根据一个参数 isSorted 判断传入的数组是否是已排序的，如果为 true，我们就判断相邻元素是否相同，如果为 false，我们就使用 indexOf 进行判断 12345678910111213141516171819202122232425var array1 = [1, 2, '1', 2, 1];var array2 = [1, 1, '1', 2, 2];// 第一版function unique(array, isSorted) &#123; var res = []; var seen = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var value = array[i]; if (isSorted) &#123; if (!i || seen !== value) &#123; res.push(value) &#125; seen = value; &#125; else if (res.indexOf(value) === -1) &#123; res.push(value); &#125; &#125; return res;&#125;console.log(unique(array1)); // [1, 2, \"1\"]console.log(unique(array2, true)); // [1, \"1\", 2] 优化尽管 unqique 已经可以试下去重功能，但是为了让这个 API 更加强大，我们来考虑一个需求： 新需求：字母的大小写视为一致，比如’a’和’A’，保留一个就可以了！ 虽然我们可以先处理数组中的所有数据，比如将所有的字母转成小写，然后再传入unique函数，但是有没有方法可以省掉处理数组的这一遍循环，直接就在去重的循环中做呢？让我们去完成这个需求： 123456789101112131415161718192021222324252627282930313233var array3 = [1, 1, 'a', 'A', 2, 2];// 第二版// iteratee 英文释义：迭代 重复function unique(array, isSorted, iteratee) &#123; var res = []; var seen = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var value = array[i]; var computed = iteratee ? iteratee(value, i, array) : value; if (isSorted) &#123; if (!i || seen !== value) &#123; res.push(value) &#125; seen = value; &#125; else if (iteratee) &#123; if (seen.indexOf(computed) === -1) &#123; seen.push(computed); res.push(value); &#125; &#125; else if (res.indexOf(value) === -1) &#123; res.push(value); &#125; &#125; return res;&#125;console.log(unique(array3, false, function(item)&#123; return typeof item == 'string' ? item.toLowerCase() : item&#125;)); // [1, \"a\", 2] 在这一版也是最后一版的实现中，函数传递三个参数： array：表示要去重的数组，必填 isSorted：表示函数传入的数组是否已排过序，如果为 true，将会采用更快的方法进行去重 iteratee：传入一个函数，可以对每个元素进行重新的计算，然后根据处理的结果进行去重 至此，我们已经仿照着 underscore 的思路写了一个 unique 函数，具体可以查看 Github。 filterES5 提供了 filter 方法，我们可以用来简化外层循环： 比如使用 indexOf 的方法： 12345678910var array = [1, 2, 1, 1, '1'];function unique(array) &#123; var res = array.filter(function(item, index, array)&#123; return array.indexOf(item) === index; &#125;) return res;&#125;console.log(unique(array)); 排序去重的方法： 123456789var array = [1, 2, 1, 1, '1'];function unique(array) &#123; return array.concat().sort().filter(function(item, index, array)&#123; return !index || item !== array[index - 1] &#125;)&#125;console.log(unique(array)); Object 键值对去重的方法众多，尽管我们已经跟着 underscore 写了一个 unqiue API，但是让我们看看其他的方法拓展下视野： 这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。示例代码如下： 12345678910var array = [1, 2, 1, 1, '1'];function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(item) ? false : (obj[item] = true) &#125;)&#125;console.log(unique(array)); // [1, 2] 我们可以发现，是有问题的，因为 1 和 ‘1’ 是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所以我们可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题： 12345678910var array = [1, 2, 1, 1, '1'];function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125;console.log(unique(array)); // [1, 2, \"1\"] 然而，即便如此，我们依然无法正确区分出两个对象，比如 {value: 1} 和 {value: 2}，因为 typeof item + item 的结果都会是 object[object Object]，不过我们可以使用 JSON.stringify 将对象序列化： 1234567891011var array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;];function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; console.log(typeof item + JSON.stringify(item)) return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;console.log(unique(array)); // [&#123;value: 1&#125;, &#123;value: 2&#125;] ES6随着 ES6 的到来，去重的方法又有了进展，比如我们可以使用 Set 和 Map 数据结构，以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 是不是感觉就像是为去重而准备的？让我们来写一版： 1234567var array = [1, 2, 1, 1, '1'];function unique(array) &#123; return Array.from(new Set(array));&#125;console.log(unique(array)); // [1, 2, \"1\"] 甚至可以再简化下： 123function unique(array) &#123; return [...new Set(array)];&#125; 还可以再简化下： 1var unique = (a) =&gt; [...new Set(a)] 此外，如果用 Map 的话： 1234function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125; JavaScript 的进化我们可以看到，去重方法从原始的 14 行代码到 ES6 的 1 行代码，其实也说明了 JavaScript 这门语言在不停的进步，相信以后的开发也会越来越高效。 特殊类型比较去重的方法就到此结束了，然而要去重的元素类型可能是多种多样，除了例子中简单的 1 和 ‘1’ 之外，其实还有 null、undefined、NaN、对象等，那么对于这些元素，之前的这些方法的去重结果又是怎样呢？ 在此之前，先让我们先看几个例子： 1234567891011121314151617181920var str1 = '1';var str2 = new String('1');console.log(str1 == str2); // trueconsole.log(str1 === str2); // falseconsole.log(null == null); // trueconsole.log(null === null); // trueconsole.log(undefined == undefined); // trueconsole.log(undefined === undefined); // trueconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(/a/ == /a/); // falseconsole.log(/a/ === /a/); // falseconsole.log(&#123;&#125; == &#123;&#125;); // falseconsole.log(&#123;&#125; === &#123;&#125;); // false 那么，对于这样一个数组 1var array = [1, 1, '1', '1', null, null, undefined, undefined, new String('1'), new String('1'), /a/, /a/, NaN, NaN]; 以上各种方法去重的结果到底是什么样的呢？ 我特地整理了一个列表，我们重点关注下对象和 NaN 的去重情况： 方法 结果 说明 for循环 [1, “1”, null, undefined, String, String, /a/, /a/, NaN, NaN] 对象和 NaN 不去重 indexOf [1, “1”, null, undefined, String, String, /a/, /a/, NaN, NaN] 对象和 NaN 不去重 sort [/a/, /a/, “1”, 1, String, 1, String, NaN, NaN, null, undefined] 对象和 NaN 不去重 数字 1 也不去重 filter + indexOf [1, “1”, null, undefined, String, String, /a/, /a/] 对象不去重 NaN 会被忽略掉 filter + sort [/a/, /a/, “1”, 1, String, 1, String, NaN, NaN, null, undefined] 对象和 NaN 不去重 数字 1 不去重 优化后的键值对方法 [1, “1”, null, undefined, String, /a/, NaN] 全部去重 Set [1, “1”, null, undefined, String, String, /a/, /a/, NaN] 对象不去重 NaN 去重 想了解为什么会出现以上的结果，看两个 demo 便能明白： 123// demo1var arr = [1, 2, NaN];arr.indexOf(NaN); // -1 indexOf 底层还是使用 === 进行判断，因为 NaN ==== NaN的结果为 false，所以使用 indexOf 查找不到 NaN 元素 12345// demo2function unique(array) &#123; return Array.from(new Set(array));&#125;console.log(unique([NaN, NaN])) // [NaN] Set 认为尽管 NaN === NaN 为 false，但是这两个元素是重复的。 写在最后虽然去重的结果有所不同，但更重要的是让我们知道在合适的场景要选择合适的方法。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之函数记忆","date":"2019-04-13T07:27:41.278Z","updated":"2019-04-13T07:27:41.279Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之函数记忆/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之函数记忆/","excerpt":"JavaScript 专题之函数记忆定义函数记忆是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据。 举个例子：","text":"JavaScript 专题之函数记忆定义函数记忆是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据。 举个例子：123456789function add(a, b) &#123; return a + b;&#125;// 假设 memorize 可以实现函数记忆var memoizedAdd = memorize(add);memoizedAdd(1, 2) // 3memoizedAdd(1, 2) // 相同的参数，第二次调用时，从缓存中取出数据，而非重新计算一次 原理实现这样一个 memorize 函数很简单，原理上只用把参数和对应的结果数据存到一个对象中，调用时，判断参数对应的数据是否存在，存在就返回对应的结果数据。 第一版我们来写一版： 1234567891011// 第一版 (来自《JavaScript权威指南》)function memoize(f) &#123; var cache = &#123;&#125;; return function()&#123; var key = arguments.length + Array.prototype.join.call(arguments, \",\"); if (key in cache) &#123; return cache[key] &#125; else return cache[key] = f.apply(this, arguments) &#125;&#125; 我们来测试一下： 1234567891011121314151617var add = function(a, b, c) &#123; return a + b + c&#125;var memoizedAdd = memorize(add)console.time('use memorize')for(var i = 0; i &lt; 100000; i++) &#123; memoizedAdd(1, 2, 3)&#125;console.timeEnd('use memorize')console.time('not use memorize')for(var i = 0; i &lt; 100000; i++) &#123; add(1, 2, 3)&#125;console.timeEnd('not use memorize') 在 Chrome 中，使用 memorize 大约耗时 60ms，如果我们不使用函数记忆，大约耗时 1.3 ms 左右。 注意什么，我们使用了看似高大上的函数记忆，结果却更加耗时，这个例子近乎有 60 倍呢！ 所以，函数记忆也并不是万能的，你看这个简单的场景，其实并不适合用函数记忆。 需要注意的是，函数记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端 JavaScript 中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。 第二版因为第一版使用了 join 方法，我们很容易想到当参数是对象的时候，就会自动调用 toString 方法转换成 [Object object]，再拼接字符串作为 key 值。我们写个 demo 验证一下这个问题： 12345678var propValue = function(obj)&#123; return obj.value&#125;var memoizedAdd = memorize(propValue)console.log(memoizedAdd(&#123;value: 1&#125;)) // 1console.log(memoizedAdd(&#123;value: 2&#125;)) // 1 两者都返回了 1，显然是有问题的，所以我们看看 underscore 的 memoize 函数是如何实现的： 12345678910111213// 第二版 (来自 underscore 的实现)var memorize = function(func, hasher) &#123; var memoize = function(key) &#123; var cache = memoize.cache; var address = '' + (hasher ? hasher.apply(this, arguments) : key); if (!cache[address]) &#123; cache[address] = func.apply(this, arguments); &#125; return cache[address]; &#125;; memoize.cache = &#123;&#125;; return memoize;&#125;; 从这个实现可以看出，underscore 默认使用 function 的第一个参数作为 key，所以如果直接使用 12345678var add = function(a, b, c) &#123; return a + b + c&#125;var memoizedAdd = memorize(add)memoizedAdd(1, 2, 3) // 6memoizedAdd(1, 2, 4) // 6 肯定是有问题的，如果要支持多参数，我们就需要传入 hasher 函数，自定义存储的 key 值。所以我们考虑使用 JSON.stringify： 1234567var memoizedAdd = memorize(add, function()&#123; var args = Array.prototype.slice.call(arguments) return JSON.stringify(args)&#125;)console.log(memoizedAdd(1, 2, 3)) // 6console.log(memoizedAdd(1, 2, 4)) // 7 如果使用 JSON.stringify，参数是对象的问题也可以得到解决，因为存储的是对象序列化后的字符串。 适用场景我们以斐波那契数列为例： 12345678910var count = 0;var fibonacci = function(n)&#123; count++; return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);&#125;;for (var i = 0; i &lt;= 10; i++)&#123; fibonacci(i)&#125;console.log(count) // 453 我们会发现最后的 count 数为 453，也就是说 fibonacci 函数被调用了 453 次！也许你会想，我只是循环到了 10，为什么就被调用了这么多次，所以我们来具体分析下： 123456789101112131415161718192021当执行 fib(0) 时，调用 1 次当执行 fib(1) 时，调用 1 次当执行 fib(2) 时，相当于 fib(1) + fib(0) 加上 fib(2) 本身这一次，共 1 + 1 + 1 = 3 次当执行 fib(3) 时，相当于 fib(2) + fib(1) 加上 fib(3) 本身这一次，共 3 + 1 + 1 = 5 次当执行 fib(4) 时，相当于 fib(3) + fib(2) 加上 fib(4) 本身这一次，共 5 + 3 + 1 = 9 次当执行 fib(5) 时，相当于 fib(4) + fib(3) 加上 fib(5) 本身这一次，共 9 + 5 + 1 = 15 次当执行 fib(6) 时，相当于 fib(5) + fib(4) 加上 fib(6) 本身这一次，共 15 + 9 + 1 = 25 次当执行 fib(7) 时，相当于 fib(6) + fib(5) 加上 fib(7) 本身这一次，共 25 + 15 + 1 = 41 次当执行 fib(8) 时，相当于 fib(7) + fib(6) 加上 fib(8) 本身这一次，共 41 + 25 + 1 = 67 次当执行 fib(9) 时，相当于 fib(8) + fib(7) 加上 fib(9) 本身这一次，共 67 + 41 + 1 = 109 次当执行 fib(10) 时，相当于 fib(9) + fib(8) 加上 fib(10) 本身这一次，共 109 + 67 + 1 = 177 次 所以执行的总次数为：177 + 109 + 67 + 41 + 25 + 15 + 9 + 5 + 3 + 1 + 1 = 453 次！ 如果我们使用函数记忆呢？ 12345678910111213var count = 0;var fibonacci = function(n) &#123; count++; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;;fibonacci = memorize(fibonacci)for (var i = 0; i &lt;= 10; i++) &#123; fibonacci(i)&#125;console.log(count) // 12 我们会发现最后的总次数为 12 次，因为使用了函数记忆，调用次数从 453 次降低为了 12 次! 兴奋的同时不要忘记思考：为什么会是 12 次呢？ 从 0 到 10 的结果各储存一遍，应该是 11 次呐？咦，那多出来的一次是从哪里来的？ 所以我们还需要认真看下我们的写法，在我们的写法中，其实我们用生成的 fibonacci 函数覆盖了原本了 fibonacci 函数，当我们执行 fibonacci(0) 时，执行一次函数，cache 为 {0: 0}，但是当我们执行 fibonacci(2) 的时候，执行 fibonacci(1) + fibonacci(0)，因为 fibonacci(0) 的值为 0，!cache[address] 的结果为 true，又会执行一次 fibonacci 函数。原来，多出来的那一次是在这里！ 多说一句也许你会觉得在日常开发中又用不到 fibonacci，这个例子感觉实用价值不高呐，其实，这个例子是用来表明一种使用的场景，也就是如果需要大量重复的计算，或者大量计算又依赖于之前的结果，便可以考虑使用函数记忆。而这种场景，当你遇到的时候，你就会知道的。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之如何判断两个对象相等","date":"2019-04-13T07:27:41.276Z","updated":"2019-04-13T07:27:41.276Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之如何判断两个对象相等/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之如何判断两个对象相等/","excerpt":"JavaScript专题之如何判断两个对象相等前言虽然标题写的是如何判断两个对象相等，但本篇我们不仅仅判断两个对象相等，实际上，我们要做到的是如何判断两个参数相等，而这必然会涉及到多种类型的判断。 相等什么是相等？在《JavaScript专题之去重》中，我们认为只要 === 的结果为 true，两者就相等，然而今天我们重新定义相等： 我们认为：","text":"JavaScript专题之如何判断两个对象相等前言虽然标题写的是如何判断两个对象相等，但本篇我们不仅仅判断两个对象相等，实际上，我们要做到的是如何判断两个参数相等，而这必然会涉及到多种类型的判断。 相等什么是相等？在《JavaScript专题之去重》中，我们认为只要 === 的结果为 true，两者就相等，然而今天我们重新定义相等： 我们认为： NaN 和 NaN 是相等 [1] 和 [1] 是相等 {value: 1} 和 {value: 1} 是相等 不仅仅是这些长得一样的，还有 1 和 new Number(1) 是相等 ‘Curly’ 和 new String(‘Curly’) 是相等 true 和 new Boolean(true) 是相等 更复杂的我们会在接下来的内容中看到。 目标我们的目标是写一个 eq 函数用来判断两个参数是否相等，使用效果如下： 12345function eq(a, b) &#123; ... &#125;var a = [1];var b = [1];console.log(eq(a, b)) // true 在写这个看似很简单的函数之前，我们首先了解在一些简单的情况下是如何判断的？ +0 与 -0如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。 JavaScript “处心积虑”的想抹平两者的差异： 12345678910// 表现1console.log(+0 === -0); // true// 表现2(-0).toString() // '0'(+0).toString() // '0'// 表现3-0 &lt; +0 // false+0 &lt; -0 // false 即便如此，两者依然是不同的： 12341 / +0 // Infinity1 / -0 // -Infinity1 / +0 === 1 / -0 // false 也许你会好奇为什么要有 +0 和 -0 呢？ 这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。 也许你会好奇什么时候会产生 -0 呢？ 1Math.round(-0.1) // -0 那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做： 1234567function eq(a, b)&#123; if (a === b) return a !== 0 || 1 / a === 1 / b; return false;&#125;console.log(eq(0, 0)) // trueconsole.log(eq(0, -0)) // false NaN在本篇，我们认为 NaN 和 NaN 是相等的，那又该如何判断出 NaN 呢？ 1console.log(NaN === NaN); // false 利用 NaN 不等于自身的特性，我们可以区别出 NaN，那么这个 eq 函数又该怎么写呢？ 12345function eq(a, b) &#123; if (a !== a) return b !== b;&#125;console.log(eq(NaN, NaN)); // true eq 函数现在，我们已经可以去写 eq 函数的第一版了。 1234567891011121314151617181920// eq 第一版// 用来过滤掉简单的类型比较，复杂的对象使用 deepEq 函数进行处理function eq(a, b) &#123; // === 结果为 true 的区别出 +0 和 -0 if (a === b) return a !== 0 || 1 / a === 1 / b; // typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数 if (a == null || b == null) return false; // 判断 NaN if (a !== a) return b !== b; // 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false var type = typeof a; if (type !== 'function' &amp;&amp; type !== 'object' &amp;&amp; typeof b != 'object') return false; // 更复杂的对象使用 deepEq 函数进行深度比较 return deepEq(a, b);&#125;; 也许你会好奇是不是少了一个 typeof b !== function? 试想如果我们添加上了这句，当 a 是基本类型，而 b 是函数的时候，就会进入 deepEq 函数，而去掉这一句，就会进入直接进入 false，实际上 基本类型和函数肯定是不会相等的，所以这样做代码又少，又可以让一种情况更早退出。 String 对象现在我们开始写 deepEq 函数，一个要处理的重大难题就是 ‘Curly’ 和 new String(‘Curly’) 如何判断成相等？ 两者的类型都不一样呐！不信我们看 typeof 的操作结果： 12console.log(typeof 'Curly'); // stringconsole.log(typeof new String('Curly')); // object 可是我们在《JavaScript专题之类型判断上》中还学习过更多的方法判断类型，比如 Object.prototype.toString： 123var toString = Object.prototype.toString;toString.call('Curly'); // \"[object String]\"toString.call(new String('Curly')); // \"[object String]\" 神奇的是使用 toString 方法两者判断的结果却是一致的，可是就算知道了这一点，还是不知道如何判断字符串和字符串包装对象是相等的呢？ 那我们利用隐式类型转换呢？ 1console.log('Curly' + '' === new String('Curly') + ''); // true 看来我们已经有了思路：如果 a 和 b 的 Object.prototype.toString的结果一致，并且都是”[object String]”，那我们就使用 ‘’ + a === ‘’ + b 进行判断。 可是不止有 String 对象呐，Boolean、Number、RegExp、Date呢？ 更多对象跟 String 同样的思路，利用隐式类型转换。 Boolean 1234var a = true;var b = new Boolean(true);console.log(+a === +b) // true Date 1234var a = new Date(2009, 9, 25);var b = new Date(2009, 9, 25);console.log(+a === +b) // true RegExp 1234var a = /a/i;var b = new RegExp(/a/i);console.log('' + a === '' + b) // true Number 1234var a = 1;var b = new Number(1);console.log(+a === +b) // true 嗯哼？你确定 Number 能这么简单的判断？ 1234var a = Number(NaN);var b = Number(NaN);console.log(+a === +b); // false 可是 a 和 b 应该被判断成 true 的呐~ 那么我们就改成这样： 12345678910var a = Number(NaN);var b = Number(NaN);function eq() &#123; // 判断 Number(NaN) Object(NaN) 等情况 if (+a !== +a) return +b !== +b; // 其他判断 ...&#125;console.log(eq(a, b)); // true deepEq 函数现在我们可以写一点 deepEq 函数了。 1234567891011121314151617181920var toString = Object.prototype.toString;function deepEq(a, b) &#123; var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) &#123; case '[object RegExp]': case '[object String]': return '' + a === '' + b; case '[object Number]': if (+a !== +a) return +b !== +b; return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': return +a === +b; &#125; // 其他判断&#125; 构造函数实例我们看个例子： 123456789101112function Person() &#123; this.name = name;&#125;function Animal() &#123; this.name = name&#125;var person = new Person('Kevin');var animal = new Animal('Kevin');eq(person, animal) // ??? 虽然 person 和 animal 都是 {name: &#39;Kevin&#39;}，但是 person 和 animal 属于不同构造函数的实例，为了做出区分，我们认为是不同的对象。 如果两个对象所属的构造函数对象不同，两个对象就一定不相等吗？ 并不一定，我们再举个例子： 123var attrs = Object.create(null);attrs.name = \"Bob\";eq(attrs, &#123;name: \"Bob\"&#125;); // ??? 尽管 attrs 没有原型，{name: &quot;Bob&quot;} 的构造函数是 Object，但是在实际应用中，只要他们有着相同的键值对，我们依然认为是相等。 从函数设计的角度来看，我们不应该让他们相等，但是从实践的角度，我们让他们相等，所以相等就是一件如此随意的事情吗？！对啊，我也在想：undersocre，你怎么能如此随意呢！！！ 哎，吐槽完了，我们还是要接着写这个相等函数，我们可以先做个判断，对于不同构造函数下的实例直接返回 false。 123456789101112131415161718192021function isFunction(obj) &#123; return toString.call(obj) === '[object Function]'&#125;function deepEq(a, b) &#123; // 接着上面的内容 var areArrays = className === '[object Array]'; // 不是数组 if (!areArrays) &#123; // 过滤掉两个函数的情况 if (typeof a != 'object' || typeof b != 'object') return false; var aCtor = a.constructor, bCtor = b.constructor; // aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦 if (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; // 下面还有好多判断&#125; 数组相等现在终于可以进入我们期待已久的数组和对象的判断，不过其实这个很简单，就是递归遍历一遍…… 1234567891011121314151617181920212223242526function deepEq(a, b) &#123; // 再接着上面的内容 if (areArrays) &#123; length = a.length; if (length !== b.length) return false; while (length--) &#123; if (!eq(a[length], b[length])) return false; &#125; &#125; else &#123; var keys = Object.keys(a), key; length = keys.length; if (Object.keys(b).length !== length) return false; while (length--) &#123; key = keys[length]; if (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key]))) return false; &#125; &#125; return true;&#125; 循环引用如果觉得这就结束了，简直是太天真，因为最难的部分才终于要开始，这个问题就是循环引用！ 举个简单的例子： 123456a = &#123;abc: null&#125;;b = &#123;abc: null&#125;;a.abc = a;b.abc = b;eq(a, b) 再复杂一点的，比如： 123456a = &#123;foo: &#123;b: &#123;foo: &#123;c: &#123;foo: null&#125;&#125;&#125;&#125;&#125;;b = &#123;foo: &#123;b: &#123;foo: &#123;c: &#123;foo: null&#125;&#125;&#125;&#125;&#125;;a.foo.b.foo.c.foo = a;b.foo.b.foo.c.foo = b;eq(a, b) 为了给大家演示下循环引用，大家可以把下面这段已经精简过的代码复制到浏览器中尝试： 123456789101112131415161718192021222324252627282930313233343536// demovar a, b;a = &#123; foo: &#123; b: &#123; foo: &#123; c: &#123; foo: null &#125; &#125; &#125; &#125; &#125;;b = &#123; foo: &#123; b: &#123; foo: &#123; c: &#123; foo: null &#125; &#125; &#125; &#125; &#125;;a.foo.b.foo.c.foo = a;b.foo.b.foo.c.foo = b;function eq(a, b, aStack, bStack) &#123; if (typeof a == 'number') &#123; return a === b; &#125; return deepEq(a, b)&#125;function deepEq(a, b) &#123; var keys = Object.keys(a); var length = keys.length; var key; while (length--) &#123; key = keys[length] // 这是为了让你看到代码其实一直在执行 console.log(a[key], b[key]) if (!eq(a[key], b[key])) return false; &#125; return true;&#125;eq(a, b) 嗯，以上的代码是死循环。 那么，我们又该如何解决这个问题呢？underscore 的思路是 eq 的时候，多传递两个参数为 aStack 和 bStack，用来储存 a 和 b 递归比较过程中的 a 和 b 的值，咋说的这么绕口呢？我们直接看个精简的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var a, b;a = &#123; foo: &#123; b: &#123; foo: &#123; c: &#123; foo: null &#125; &#125; &#125; &#125; &#125;;b = &#123; foo: &#123; b: &#123; foo: &#123; c: &#123; foo: null &#125; &#125; &#125; &#125; &#125;;a.foo.b.foo.c.foo = a;b.foo.b.foo.c.foo = b;function eq(a, b, aStack, bStack) &#123; if (typeof a == 'number') &#123; return a === b; &#125; return deepEq(a, b, aStack, bStack)&#125;function deepEq(a, b, aStack, bStack) &#123; aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; if (aStack[length] === a) &#123; return bStack[length] === b; &#125; &#125; aStack.push(a); bStack.push(b); var keys = Object.keys(a); var length = keys.length; var key; while (length--) &#123; key = keys[length] console.log(a[key], b[key], aStack, bStack) if (!eq(a[key], b[key], aStack, bStack)) return false; &#125; // aStack.pop(); // bStack.pop(); return true;&#125;console.log(eq(a, b)) 之所以注释掉 aStack.pop()和bStack.pop()这两句，是为了方便大家查看 aStack bStack的值。 最终的 eq 函数最终的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122var toString = Object.prototype.toString;function isFunction(obj) &#123; return toString.call(obj) === '[object Function]'&#125;function eq(a, b, aStack, bStack) &#123; // === 结果为 true 的区别出 +0 和 -0 if (a === b) return a !== 0 || 1 / a === 1 / b; // typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数 if (a == null || b == null) return false; // 判断 NaN if (a !== a) return b !== b; // 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false var type = typeof a; if (type !== 'function' &amp;&amp; type !== 'object' &amp;&amp; typeof b != 'object') return false; // 更复杂的对象使用 deepEq 函数进行深度比较 return deepEq(a, b, aStack, bStack);&#125;;function deepEq(a, b, aStack, bStack) &#123; // a 和 b 的内部属性 [[class]] 相同时 返回 true var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) &#123; case '[object RegExp]': case '[object String]': return '' + a === '' + b; case '[object Number]': if (+a !== +a) return +b !== +b; return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': return +a === +b; &#125; var areArrays = className === '[object Array]'; // 不是数组 if (!areArrays) &#123; // 过滤掉两个函数的情况 if (typeof a != 'object' || typeof b != 'object') return false; var aCtor = a.constructor, bCtor = b.constructor; // aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，aCtor 不等于 bCtor， 那这两个对象就真的不相等啦 if (aCtor == bCtor &amp;&amp; !(isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; aStack = aStack || []; bStack = bStack || []; var length = aStack.length; // 检查是否有循环引用的部分 while (length--) &#123; if (aStack[length] === a) &#123; return bStack[length] === b; &#125; &#125; aStack.push(a); bStack.push(b); // 数组判断 if (areArrays) &#123; length = a.length; if (length !== b.length) return false; while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; // 对象判断 else &#123; var keys = Object.keys(a), key; length = keys.length; if (Object.keys(b).length !== length) return false; while (length--) &#123; key = keys[length]; if (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; aStack.pop(); bStack.pop(); return true;&#125;console.log(eq(0, 0)) // trueconsole.log(eq(0, -0)) // falseconsole.log(eq(NaN, NaN)); // trueconsole.log(eq(Number(NaN), Number(NaN))); // trueconsole.log(eq('Curly', new String('Curly'))); // trueconsole.log(eq([1], [1])); // trueconsole.log(eq(&#123; value: 1 &#125;, &#123; value: 1 &#125;)); // truevar a, b;a = &#123; foo: &#123; b: &#123; foo: &#123; c: &#123; foo: null &#125; &#125; &#125; &#125; &#125;;b = &#123; foo: &#123; b: &#123; foo: &#123; c: &#123; foo: null &#125; &#125; &#125; &#125; &#125;;a.foo.b.foo.c.foo = a;b.foo.b.foo.c.foo = b;console.log(eq(a, b)) // true 真让人感叹一句：eq 不愧是 underscore 中实现代码行数最多的函数了！ 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之深浅拷贝","date":"2019-04-13T07:27:41.273Z","updated":"2019-04-13T07:27:41.274Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之深浅拷贝/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之深浅拷贝/","excerpt":"JavaScript专题之深浅拷贝前言拷贝也是面试经典呐！ 数组的浅拷贝如果是数组，我们可以利用数组的一些方法比如：slice、concat 返回一个新数组的特性来实现拷贝。","text":"JavaScript专题之深浅拷贝前言拷贝也是面试经典呐！ 数组的浅拷贝如果是数组，我们可以利用数组的一些方法比如：slice、concat 返回一个新数组的特性来实现拷贝。比如： 12345678var arr = ['old', 1, true, null, undefined];var new_arr = arr.concat();new_arr[0] = 'new';console.log(arr) // [\"old\", 1, true, null, undefined]console.log(new_arr) // [\"new\", 1, true, null, undefined] 用 slice 可以这样做： 1var new_arr = arr.slice(); 但是如果数组嵌套了对象或者数组的话，比如： 123456789var arr = [&#123;old: 'old'&#125;, ['old']];var new_arr = arr.concat();arr[0].old = 'new';arr[1][0] = 'new';console.log(arr) // [&#123;old: 'new'&#125;, ['new']]console.log(new_arr) // [&#123;old: 'new'&#125;, ['new']] 我们会发现，无论是新数组还是旧数组都发生了变化，也就是说使用 concat 方法，克隆的并不彻底。 如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。 所以我们可以看出使用 concat 和 slice 是一种浅拷贝。 数组的深拷贝那如何深拷贝一个数组呢？这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： 12345var arr = ['old', 1, true, ['old1', 'old2'], &#123;old: 1&#125;]var new_arr = JSON.parse( JSON.stringify(arr) );console.log(new_arr); 是一个简单粗暴的好方法，就是有一个问题，不能拷贝函数，我们做个试验： 1234567891011var arr = [function()&#123; console.log(a)&#125;, &#123; b: function()&#123; console.log(b) &#125;&#125;]var new_arr = JSON.parse(JSON.stringify(arr));console.log(new_arr); 我们会发现 new_arr 变成了： 浅拷贝的实现以上三个方法 concat、slice、JSON.stringify 都算是技巧类，可以根据实际项目情况选择使用，接下来我们思考下如何实现一个对象或者数组的浅拷贝。 想一想，好像很简单，遍历对象，然后把属性和属性值都放在一个新的对象不就好了~ 嗯，就是这么简单，注意几个小点就可以了： 12345678910111213var shallowCopy = function(obj) &#123; // 只拷贝对象 if (typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 深拷贝的实现那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~ 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125; 性能问题尽管使用深拷贝会完全的克隆一个新对象，不会产生副作用，但是深拷贝因为使用递归，性能会不如浅拷贝，在开发中，还是要根据实际情况进行选择。 下期预告难道到这里就结束了？是的。然而本篇实际上是一个铺垫，我们真正要看的是 jquery 的 extend 函数的实现，下一篇，我们会讲一讲如何从零实现一个 jquery 的 extend 函数。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之类型判断(上)","date":"2019-04-13T07:27:41.271Z","updated":"2019-04-13T07:27:41.271Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之类型判断(上)/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之类型判断(上)/","excerpt":"JavaScript专题之类型判断(上)前言类型判断在 web 开发中有非常广泛的应用，简单的有判断数字还是字符串，进阶一点的有判断数组还是对象，再进阶一点的有判断日期、正则、错误类型，再再进阶一点还有比如判断 plainObject、空对象、Window 对象等等。 以上都会讲，今天是上半场。","text":"JavaScript专题之类型判断(上)前言类型判断在 web 开发中有非常广泛的应用，简单的有判断数字还是字符串，进阶一点的有判断数组还是对象，再进阶一点的有判断日期、正则、错误类型，再再进阶一点还有比如判断 plainObject、空对象、Window 对象等等。 以上都会讲，今天是上半场。 typeof我们最最常用的莫过于 typeof，注意，尽管我们会看到诸如： 1console.log(typeof('yayu')) // string 的写法，但是 typeof 可是一个正宗的运算符，就跟加减乘除一样！这就能解释为什么下面这种写法也是可行的： 1console.log(typeof 'yayu') // string 引用《JavaScript权威指南》中对 typeof 的介绍： typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。 那我们都知道，在 ES6 前，JavaScript 共六种数据类型，分别是： Undefined、Null、Boolean、Number、String、Object 然而当我们使用 typeof 对这些数据类型的值进行操作的时候，返回的结果却不是一一对应，分别是： undefined、object、boolean、number、string、object 注意以上都是小写的字符串。Null 和 Object 类型都返回了 object 字符串。 尽管不能一一对应，但是 typeof 却能检测出函数类型： 123function a() &#123;&#125;console.log(typeof a); // function 所以 typeof 能检测出六种类型的值，但是，除此之外 Object 下还有很多细分的类型呐，如 Array、Function、Date、RegExp、Error 等。 如果用 typeof 去检测这些类型，举个例子： 1234var date = new Date();var error = new Error();console.log(typeof date); // objectconsole.log(typeof error); // object 返回的都是 object 呐，这可怎么区分~ 所以有没有更好的方法呢？ Obejct.prototype.toString是的，当然有！这就是 Object.prototype.toString！ 那 Object.protototype.toString 究竟是一个什么样的方法呢？ 为了更加细致的讲解这个函数，让我先献上 ES5 规范地址：https://es5.github.io/#x15.2.4.2。 在第 15.2.4.2 节讲的就是 Object.prototype.toString()，为了不误导大家，我先奉上英文版： When the toString method is called, the following steps are taken: If the this value is undefined, return “[object Undefined]“. If the this value is null, return “[object Null]“. Let O be the result of calling ToObject passing the this value as the argument. Let class be the value of the [[Class]] internal property of O. Return the String value that is the result of concatenating the three Strings “[object “, class, and “]“. 凡是规范上加粗或者斜体的，在这里我也加粗或者斜体了，就是要让大家感受原汁原味的规范！ 如果没有看懂，就不妨看看我理解的： 当 toString 方法被调用的时候，下面的步骤会被执行： 如果 this 值是 undefined，就返回 [object Undefined] 如果 this 的值是 null，就返回 [object Null] 让 O 成为 ToObject(this) 的结果 让 class 成为 O 的内部属性 [[Class]] 的值 最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串 通过规范，我们至少知道了调用 Object.prototype.toString 会返回一个由 “[object “ 和 class 和 “]” 组成的字符串，而 class 是要判断的对象的内部属性。 让我们写个 demo: 12345console.log(Object.prototype.toString.call(undefined)) // [object Undefined]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date();console.log(Object.prototype.toString.call(date)) // [object Date] 由此我们可以看到这个 class 值就是识别对象类型的关键！ 正是因为这种特性，我们可以用 Object.prototype.toString 方法识别出更多类型！ 那到底能识别多少种类型呢？ 至少 12 种！ 你咋知道的？ 我数的！ …… 让我们看个 demo: 1234567891011121314151617181920// 以下是11种：var number = 1; // [object Number]var string = '123'; // [object String]var boolean = true; // [object Boolean]var und = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123;a: 1&#125; // [object Object]var array = [1, 2, 3]; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a()&#123;&#125;; // [object Function]function checkType() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])) &#125;&#125;checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func) 除了以上 11 种之外，还有： 12console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON] 除了以上 13 种之外，还有： 1234function a() &#123; console.log(Object.prototype.toString.call(arguments)); // [object Arguments]&#125;a(); 所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。 type API既然有了 Object.prototype.toString 这个神器！那就让我们写个 type 函数帮助我们以后识别各种类型的值吧！ 我的设想： 写一个 type 函数能检测各种类型的值，如果是基本类型，就使用 typeof，引用类型就使用 toString。此外鉴于 typeof 的结果是小写，我也希望所有的结果都是小写。 考虑到实际情况下并不会检测 Math 和 JSON，所以去掉这两个类型的检测。 我们来写一版代码： 12345678910111213// 第一版var class2type = &#123;&#125;;// 生成class2type映射\"Boolean Number String Function Array Date RegExp Object Error Null Undefined\".split(\" \").map(function(item, index) &#123; class2type[\"[object \" + item + \"]\"] = item.toLowerCase();&#125;)function type(obj) &#123; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] || \"object\" : typeof obj;&#125; 嗯，看起来很完美的样子~~ 但是注意，在 IE6 中，null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]！ 我去，竟然还有这个兼容性！有什么简单的方法可以解决吗？那我们再改写一版，绝对让你惊艳！ 1234567891011121314151617// 第二版var class2type = &#123;&#125;;// 生成class2type映射\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \").map(function(item, index) &#123; class2type[\"[object \" + item + \"]\"] = item.toLowerCase();&#125;)function type(obj) &#123; // 一箭双雕 if (obj == null) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] || \"object\" : typeof obj;&#125; isFunction有了 type 函数后，我们可以对常用的判断直接封装，比如 isFunction: 123function isFunction(obj) &#123; return type(obj) === \"function\";&#125; 数组jQuery 判断数组类型，旧版本是通过判断 Array.isArray 方法是否存在，如果存在就使用该方法，不存在就使用 type 函数。 123var isArray = Array.isArray || function( obj ) &#123; return type(obj) === \"array\";&#125; 但是在 jQuery v3.0 中已经完全采用了 Array.isArray。 结语到此，类型判断的上篇就结束了，我们已经可以判断日期、正则、错误类型啦，但是还有更复杂的判断比如 plainObject、空对象、Window对象、类数组对象等，路漫漫其修远兮，吾将上下而求索。 哦， 对了，这个 type 函数抄的 jQuery，点击查看 type 源码。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之跟着underscore学防抖","date":"2019-04-13T07:27:41.268Z","updated":"2019-04-13T07:27:41.268Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之跟着underscore学防抖/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之跟着underscore学防抖/","excerpt":"JavaScript专题之跟着underscore学防抖前言在前端开发中会遇到一些频繁的事件触发，比如： window 的 resize、scroll mousedown、mousemove keyup、keydown…… 为此，我们举个示例代码来了解事件如何频繁的触发：","text":"JavaScript专题之跟着underscore学防抖前言在前端开发中会遇到一些频繁的事件触发，比如： window 的 resize、scroll mousedown、mousemove keyup、keydown…… 为此，我们举个示例代码来了解事件如何频繁的触发：我们写个 index.html 文件： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"x-ua-compatible\" content=\"IE=edge, chrome=1\"&gt; &lt;title&gt;debounce&lt;/title&gt; &lt;style&gt; #container&#123; width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script src=\"debounce.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; debounce.js 文件的代码如下： 12345678var count = 1;var container = document.getElementById('container');function getUserAction() &#123; container.innerHTML = count++;&#125;;container.onmousemove = getUserAction; 我们来看看效果： 从左边滑到右边就触发了 165 次 getUserAction 函数！ 因为这个例子很简单，所以浏览器完全反应的过来，可是如果是复杂的回调函数或是 ajax 请求呢？假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。 为了解决这个问题，一般有两种解决方案： debounce 防抖 throttle 节流 今天重点讲讲防抖的实现。 防抖防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。 这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。 总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐! 第一版根据这段表述，我们可以轻松写出第一版的代码： 12345678// 第一版function debounce(func, wait) &#123; var timeout; return function () &#123; clearTimeout(timeout) timeout = setTimeout(func, wait); &#125;&#125; 如果我们要使用它，以最一开始的例子为例： 1container.onmousemove = debounce(getUserAction, 1000); 现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果： 顿时就从 165 次降低成了 1 次! 棒棒哒，我们接着完善它。 this如果我们在 getUserAction 函数中 console.log(this)，在不使用 debounce 函数的时候，this 的值为： 1&lt;div id=\"container\"&gt;&lt;/div&gt; 但是如果使用我们的 debounce 函数，this 就会指向 Window 对象！ 所以我们需要将 this 指向正确的对象。 我们修改下代码： 12345678910111213// 第二版function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context) &#125;, wait); &#125;&#125; 现在 this 已经可以正确指向了。让我们看下个问题： event 对象JavaScript 在事件处理函数中会提供事件对象 event，我们修改下 getUserAction 函数： 1234function getUserAction(e) &#123; console.log(e); container.innerHTML = count++;&#125;; 如果我们不使用 debouce 函数，这里会打印 MouseEvent 对象，如图所示： 但是在我们实现的 debounce 函数中，却只会打印 undefined! 所以我们再修改一下代码： 1234567891011121314// 第三版function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 到此为止，我们修复了两个小问题： this 指向 event 对象 立刻执行这个时候，代码已经很是完善了，但是为了让这个函数更加完善，我们接下来思考一个新的需求。 这个需求就是： 我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。 想想这个需求也是很有道理的嘛，那我们加个 immediate 参数判断是否是立刻执行。 12345678910111213141516171819202122232425// 第四版function debounce(func, wait, immediate) &#123; var timeout, result; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 再来看看使用效果： 返回值此时注意一点，就是 getUserAction 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果。 1234567891011121314151617181920212223242526// 第五版function debounce(func, wait, immediate) &#123; var timeout, result; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;&#125; 取消最后我们再思考一个小需求，我希望能取消 debounce 函数，比如说我 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦，是不是很开心？ 为了这个需求，我们写最后一版的代码： 123456789101112131415161718192021222324252627282930313233// 第六版function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 那么该如何使用这个 cancel 函数呢？依然是以上面的 demo 为例： 1234567891011121314var count = 1;var container = document.getElementById('container');function getUserAction(e) &#123; container.innerHTML = count++;&#125;;var setUseAction = debounce(getUserAction, 10000, true);container.onmousemove = setUseAction;document.getElementById(\"button\").addEventListener('click', function()&#123; setUseAction.cancel();&#125;) 演示效果如下： 至此我们已经完整实现了一个 underscore 中的 debounce 函数，恭喜，撒花！ 演示代码相关的代码可以在 Github 博客仓库 中找到 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之call和apply的模拟实现","date":"2019-04-13T07:27:41.265Z","updated":"2019-04-13T07:27:41.265Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之call和apply的模拟实现/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之call和apply的模拟实现/","excerpt":"JavaScript深入之call和apply的模拟实现 JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1","text":"JavaScript深入之call和apply的模拟实现 JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']');&#125;// 执行后 args为 [\"arguments[1]\", \"arguments[2]\", \"arguments[3]\"] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) &#123; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + args +')'); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 12345678var value = 1;function bar() &#123; console.log(this.value);&#125;bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 2.函数是可以有返回值的！ 举个例子： 12345678910111213141516171819var obj = &#123; value: 1&#125;function bar(name, age) &#123; return &#123; value: this.value, name: name, age: age &#125;&#125;console.log(bar.call(obj, 'kevin', 18));// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 下一篇文章JavaScript深入之bind的模拟实现 重要参考知乎问题 不能使用call、apply、bind，如何用 js 实现 call 或者 apply 的功能？ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之函数柯里化","date":"2019-04-13T07:27:41.262Z","updated":"2019-04-13T07:27:41.262Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之函数柯里化/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之函数柯里化/","excerpt":"JavaScript专题之函数柯里化定义维基百科中对柯里化 (Currying) 的定义为： In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. 翻译成中文： 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。","text":"JavaScript专题之函数柯里化定义维基百科中对柯里化 (Currying) 的定义为： In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. 翻译成中文： 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。举个例子： 12345678910function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2) // 3 用途我们会讲到如何写出这个 curry 函数，并且会将这个 curry 函数写的很强大，但是在编写之前，我们需要知道柯里化到底有什么用？ 举个例子： 12345678910111213141516171819202122// 示意而已function ajax(type, url, data) &#123; var xhr = new XMLHttpRequest(); xhr.open(type, url, true); xhr.send(data);&#125;// 虽然 ajax 这个函数非常通用，但在重复调用的时候参数冗余ajax('POST', 'www.test.com', \"name=kevin\")ajax('POST', 'www.test2.com', \"name=kevin\")ajax('POST', 'www.test3.com', \"name=kevin\")// 利用 curryvar ajaxCurry = curry(ajax);// 以 POST 类型请求数据var post = ajaxCurry('POST');post('www.test.com', \"name=kevin\");// 以 POST 类型请求来自于 www.test.com 的数据var postFromTest = post('www.test.com');postFromTest(\"name=kevin\"); 想想 jQuery 虽然有 $.ajax 这样通用的方法，但是也有 $.get 和 $.post 的语法糖。(当然 jQuery 底层是否是这样做的，我就没有研究了)。 curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。 可是即便如此，是不是依然感觉没什么用呢？ 如果我们仅仅是把参数一个一个传进去，意义可能不大，但是如果我们是把柯里化后的函数传给其他函数比如 map 呢？ 举个例子： 比如我们有这样一段数据： 1var person = [&#123;name: 'kevin'&#125;, &#123;name: 'daisy'&#125;] 如果我们要获取所有的 name 值，我们可以这样做： 123var name = person.map(function (item) &#123; return item.name;&#125;) 不过如果我们有 curry 函数： 12345var prop = curry(function (key, obj) &#123; return obj[key]&#125;);var name = person.map(prop('name')) 我们为了获取 name 属性还要再编写一个 prop 函数，是不是又麻烦了些？ 但是要注意，prop 函数编写一次后，以后可以多次使用，实际上代码从原本的三行精简成了一行，而且你看代码是不是更加易懂了？ person.map(prop(&#39;name&#39;)) 就好像直白的告诉你：person 对象遍历(map)获取(prop) name 属性。 是不是感觉有点意思了呢？ 第一版未来我们会接触到更多有关柯里化的应用，不过那是未来的事情了，现在我们该编写这个 curry 函数了。 一个经常会看到的 curry 函数的实现为： 12345678// 第一版var curry = function (fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var newArgs = args.concat([].slice.call(arguments)); return fn.apply(this, newArgs); &#125;;&#125;; 我们可以这样使用： 123456789101112function add(a, b) &#123; return a + b;&#125;var addCurry = curry(add, 1, 2);addCurry() // 3//或者var addCurry = curry(add, 1);addCurry(2) // 3//或者var addCurry = curry(add);addCurry(1, 2) // 3 已经有柯里化的感觉了，但是还没有达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数。 第二版1234567891011121314151617181920212223// 第二版function sub_curry(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; return fn.apply(this, args.concat([].slice.call(arguments))); &#125;;&#125;function curry(fn, length) &#123; length = length || fn.length; var slice = Array.prototype.slice; return function() &#123; if (arguments.length &lt; length) &#123; var combined = [fn].concat(slice.call(arguments)); return curry(sub_curry.apply(this, combined), length - arguments.length); &#125; else &#123; return fn.apply(this, arguments); &#125; &#125;;&#125; 我们验证下这个函数： 12345678var fn = curry(function(a, b, c) &#123; return [a, b, c];&#125;);fn(\"a\", \"b\", \"c\") // [\"a\", \"b\", \"c\"]fn(\"a\", \"b\")(\"c\") // [\"a\", \"b\", \"c\"]fn(\"a\")(\"b\")(\"c\") // [\"a\", \"b\", \"c\"]fn(\"a\")(\"b\", \"c\") // [\"a\", \"b\", \"c\"] 效果已经达到我们的预期，然而这个 curry 函数的实现好难理解呐…… 为了让大家更好的理解这个 curry 函数，我给大家写个极简版的代码： 12345678910111213141516171819202122232425function sub_curry(fn)&#123; return function()&#123; return fn() &#125;&#125;function curry(fn, length)&#123; length = length || 4; return function()&#123; if (length &gt; 1) &#123; return curry(sub_curry(fn), --length) &#125; else &#123; return fn() &#125; &#125;&#125;var fn0 = function()&#123; console.log(1)&#125;var fn1 = curry(fn0)fn1()()()() // 1 大家先从理解这个 curry 函数开始。 当执行 fn1() 时，函数返回： 12345curry(sub_curry(fn0))// 相当于curry(function()&#123; return fn0()&#125;) 当执行 fn1()() 时，函数返回： 12345678910111213curry(sub_curry(function()&#123; return fn0()&#125;))// 相当于curry(function()&#123; return (function()&#123; return fn0() &#125;)()&#125;)// 相当于curry(function()&#123; return fn0()&#125;) 当执行 fn1()()() 时，函数返回： 1234// 跟 fn1()() 的分析过程一样curry(function()&#123; return fn0()&#125;) 当执行 fn1()()()() 时，因为此时 length &gt; 2 为 false，所以执行 fn()： 12345678fn()// 相当于(function()&#123; return fn0()&#125;)()// 相当于fn0()// 执行 fn0 函数，打印 1 再回到真正的 curry 函数，我们以下面的例子为例： 1234567var fn0 = function(a, b, c, d) &#123; return [a, b, c, d];&#125;var fn1 = curry(fn0);fn1(\"a\", \"b\")(\"c\")(\"d\") 当执行 fn1(“a”, “b”) 时： 12345678910fn1(\"a\", \"b\")// 相当于curry(fn0)(\"a\", \"b\")// 相当于curry(sub_curry(fn0, \"a\", \"b\"))// 相当于// 注意 ... 只是一个示意，表示该函数执行时传入的参数会作为 fn0 后面的参数传入curry(function(...)&#123; return fn0(\"a\", \"b\", ...)&#125;) 当执行 fn1(“a”, “b”)(“c”) 时，函数返回： 1234567891011curry(sub_curry(function(...)&#123; return fn0(\"a\", \"b\", ...)&#125;), \"c\")// 相当于curry(function(...)&#123; return (function(...) &#123;return fn0(\"a\", \"b\", ...)&#125;)(\"c\")&#125;)// 相当于curry(function(...)&#123; return fn0(\"a\", \"b\", \"c\", ...)&#125;) 当执行 fn1(“a”, “b”)(“c”)(“d”) 时，此时 arguments.length &lt; length 为 false ，执行 fn(arguments)，相当于： 12345(function(...)&#123; return fn0(\"a\", \"b\", \"c\", ...)&#125;)(\"d\")// 相当于fn0(\"a\", \"b\", \"c\", \"d\") 函数执行结束。 所以，其实整段代码又很好理解： sub_curry 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 fn0(…)(…) 的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 再包裹原函数，然后将新的参数混合旧的参数再传入原函数，直到函数参数的数目达到要求为止。 如果要明白 curry 函数的运行原理，大家还是要动手写一遍，尝试着分析执行步骤。 更易懂的实现当然了，如果你觉得还是无法理解，你可以选择下面这种实现方式，可以实现同样的效果： 123456789101112131415161718192021222324252627282930313233343536function curry(fn, args) &#123; length = fn.length; args = args || []; return function() &#123; var _args = args.slice(0), arg, i; for (i = 0; i &lt; arguments.length; i++) &#123; arg = arguments[i]; _args.push(arg); &#125; if (_args.length &lt; length) &#123; return curry.call(this, fn, _args); &#125; else &#123; return fn.apply(this, _args); &#125; &#125;&#125;var fn = curry(function(a, b, c) &#123; console.log([a, b, c]);&#125;);fn(\"a\", \"b\", \"c\") // [\"a\", \"b\", \"c\"]fn(\"a\", \"b\")(\"c\") // [\"a\", \"b\", \"c\"]fn(\"a\")(\"b\")(\"c\") // [\"a\", \"b\", \"c\"]fn(\"a\")(\"b\", \"c\") // [\"a\", \"b\", \"c\"] 或许大家觉得这种方式更好理解，又能实现一样的效果，为什么不直接就讲这种呢？ 因为想给大家介绍各种实现的方法嘛，不能因为难以理解就不给大家介绍呐~ 第三版curry 函数写到这里其实已经很完善了，但是注意这个函数的传参顺序必须是从左到右，根据形参的顺序依次传入，如果我不想根据这个顺序传呢？ 我们可以创建一个占位符，比如这样： 12345var fn = curry(function(a, b, c) &#123; console.log([a, b, c]);&#125;);fn(\"a\", _, \"c\")(\"b\") // [\"a\", \"b\", \"c\"] 我们直接看第三版的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 第三版function curry(fn, args, holes) &#123; length = fn.length; args = args || []; holes = holes || []; return function() &#123; var _args = args.slice(0), _holes = holes.slice(0), argsLen = args.length, holesLen = holes.length, arg, i, index = 0; for (i = 0; i &lt; arguments.length; i++) &#123; arg = arguments[i]; // 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标 if (arg === _ &amp;&amp; holesLen) &#123; index++ if (index &gt; holesLen) &#123; _args.push(arg); _holes.push(argsLen - 1 + index - holesLen) &#125; &#125; // 处理类似 fn(1)(_) 这种情况 else if (arg === _) &#123; _args.push(arg); _holes.push(argsLen + i); &#125; // 处理类似 fn(_, 2)(1) 这种情况 else if (holesLen) &#123; // fn(_, 2)(_, 3) if (index &gt;= holesLen) &#123; _args.push(arg); &#125; // fn(_, 2)(1) 用参数 1 替换占位符 else &#123; _args.splice(_holes[index], 1, arg); _holes.splice(index, 1) &#125; &#125; else &#123; _args.push(arg); &#125; &#125; if (_holes.length || _args.length &lt; length) &#123; return curry.call(this, fn, _args, _holes); &#125; else &#123; return fn.apply(this, _args); &#125; &#125;&#125;var _ = &#123;&#125;;var fn = curry(function(a, b, c, d, e) &#123; console.log([a, b, c, d, e]);&#125;);// 验证 输出全部都是 [1, 2, 3, 4, 5]fn(1, 2, 3, 4, 5);fn(_, 2, 3, 4, 5)(1);fn(1, _, 3, 4, 5)(2);fn(1, _, 3)(_, 4)(2)(5);fn(1, _, _, 4)(_, 3)(2)(5);fn(_, 2)(_, _, 4)(1)(3)(5) 写在最后至此，我们已经实现了一个强大的 curry 函数，可是这个 curry 函数符合柯里化的定义吗？柯里化可是将一个多参数的函数转换成多个单参数的函数，但是现在我们不仅可以传入一个参数，还可以一次传入两个参数，甚至更多参数……这看起来更像一个柯里化 (curry) 和偏函数 (partial application) 的综合应用，可是什么又是偏函数呢？下篇文章会讲到。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之如何求数组的最大值和最小值","date":"2019-04-13T07:27:41.258Z","updated":"2019-04-13T07:27:41.259Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之如何求数组的最大值和最小值/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之如何求数组的最大值和最小值/","excerpt":"JavaScript专题之如何求数组的最大值和最小值前言取出数组中的最大值或者最小值是开发中常见的需求，但你能想出几种方法来实现这个需求呢？ Math.maxJavaScript 提供了 Math.max 函数返回一组数中的最大值，用法是： 1Math.max([value1[,value2, ...]])","text":"JavaScript专题之如何求数组的最大值和最小值前言取出数组中的最大值或者最小值是开发中常见的需求，但你能想出几种方法来实现这个需求呢？ Math.maxJavaScript 提供了 Math.max 函数返回一组数中的最大值，用法是： 1Math.max([value1[,value2, ...]]) 值得注意的是： 如果有任一参数不能被转换为数值，则结果为 NaN。 max 是 Math 的静态方法，所以应该像这样使用：Math.max()，而不是作为 Math 实例的方法 (简单的来说，就是不使用 new ) 如果没有参数，则结果为 -Infinity (注意是负无穷大) 而我们需要分析的是： 1.如果任一参数不能被转换为数值，这就意味着如果参数可以被转换成数字，就是可以进行比较的，比如： 1234Math.max(true, 0) // 1Math.max(true, '2', null) // 2Math.max(1, undefined) // NaNMath.max(1, &#123;&#125;) // NaN 2.如果没有参数，则结果为 -Infinity，对应的，Math.min 函数，如果没有参数，则结果为 Infinity，所以： 123var min = Math.min();var max = Math.max();console.log(min &gt; max); 了解了 Math.max 方法，我们以求数组最大值的为例，思考有哪些方法可以实现这个需求。 原始方法最最原始的方法，莫过于循环遍历一遍： 1234567var arr = [6, 4, 1, 8, 2, 11, 23];var result = arr[0];for (var i = 1; i &lt; arr.length; i++) &#123; result = Math.max(result, arr[i]);&#125;console.log(result); reduce既然是通过遍历数组求出一个最终值，那么我们就可以使用 reduce 方法： 123456var arr = [6, 4, 1, 8, 2, 11, 23];function max(prev, next) &#123; return Math.max(prev, next);&#125;console.log(arr.reduce(max)); 排序如果我们先对数组进行一次排序，那么最大值就是最后一个值： 1234var arr = [6, 4, 1, 8, 2, 11, 23];arr.sort(function(a,b)&#123;return a - b;&#125;);console.log(arr[arr.length - 1]) evalMath.max 支持传多个参数来进行比较，那么我们如何将一个数组转换成参数传进 Math.max 函数呢？eval 便是一种 1234var arr = [6, 4, 1, 8, 2, 11, 23];var max = eval(\"Math.max(\" + arr + \")\");console.log(max) apply使用 apply 是另一种。 12var arr = [6, 4, 1, 8, 2, 11, 23];console.log(Math.max.apply(null, arr)) ES6 …使用 ES6 的扩展运算符： 12var arr = [6, 4, 1, 8, 2, 11, 23];console.log(Math.max(...arr)) 有更多的方法欢迎留言哈~ 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之bind的模拟实现","date":"2019-04-13T07:27:41.255Z","updated":"2019-04-13T07:27:41.255Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之bind的模拟实现/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之bind的模拟实现/","excerpt":"JavaScript深入之bind的模拟实现 JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数","text":"JavaScript深入之bind的模拟实现 JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现 从第一个特点开始，我们举个例子： 123456789101112var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript深入之call和apply的模拟实现》。我们来写第一版的代码： 12345678// 第一版Function.prototype.bind2 = function (context) &#123; var self = this; return function () &#123; return self.apply(context); &#125;&#125; 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = &#123; value: 1&#125;;function bar() &#123; return this.value;&#125;var bindFoo = bar.bind(foo);console.log(bindFoo()); // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 12345678910111213141516var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = bar.bind(foo, 'daisy');bindFoo('18');// 1// daisy// 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： 1234567891011121314// 第二版Function.prototype.bind2 = function (context) &#123; var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;&#125; 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript深入系列之new的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// 第三版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;&#125; 如果对原型链稍有困惑，可以查看《JavaScript深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 1234567891011121314151617// 第四版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： 12self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2;var foo = &#123; value: 1, bar: bar.bind(null)&#125;;function bar() &#123; console.log(this.value);&#125;foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ 123if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");&#125; 3.我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 下一篇文章《JavaScript深入系列之new的模拟实现》 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入系列之new的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之作用域链","date":"2019-04-13T07:27:41.251Z","updated":"2019-04-13T07:27:41.252Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之作用域链/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之作用域链/","excerpt":"JavaScript深入之作用域链 JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。","text":"JavaScript深入之作用域链 JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456 function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 123456789foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 12Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = \"global scope\";function checkscope()&#123; var scope2 = 'local scope'; return scope2;&#125;checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 12345678checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;&#125; 5.第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: 'local scope' &#125;, Scope: [AO, [[Scope]]]&#125; 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 下一篇文章《JavaScript深入之从ECMAScript规范解读this》 本文相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之new的模拟实现","date":"2019-04-13T07:27:41.247Z","updated":"2019-04-13T07:27:41.247Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之new的模拟实现/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之new的模拟实现/","excerpt":"JavaScript深入之new的模拟实现 JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子：","text":"JavaScript深入之new的模拟实现 JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子：12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () &#123; ……&#125;// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们可以尝试着写第一版了： 1234567891011121314// 第一版代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;; 在这一版中，我们： 用new Object() 的方式新建了一个对象 obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj 更多关于： 原型与原型链，可以看《JavaScript深入之从原型到原型链》 apply，可以看《JavaScript深入之call和apply的模拟实现》 经典继承，可以看《JavaScript深入之继承》 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;;var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin []~(￣▽￣)~** 返回值效果实现接下来我们再来看一种情况，假如构造函数有返回值，举个例子： 12345678910111213141516function Otaku (name, age) &#123; this.strength = 60; this.age = age; return &#123; name: name, habit: 'Games' &#125;&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku (name, age) &#123; this.strength = 60; this.age = age; return 'handsome boy';&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再来看第二版的代码，也是最后一版的代码： 1234567891011121314// 第二版的代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj;&#125;; 下一篇文章JavaScript深入之类数组对象与arguments 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之继承》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之惰性函数","date":"2019-04-13T07:27:41.244Z","updated":"2019-04-13T07:27:41.245Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之惰性函数/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之惰性函数/","excerpt":"JavaScript专题之惰性函数需求我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次。 解决一：普通方法123456var t;function foo() &#123; if (t) return t; t = new Date() return t;&#125; 问题有两个，一是污染了全局变量，二是每次调用 foo 的时候都需要进行一次判断。 解决二：闭包","text":"JavaScript专题之惰性函数需求我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次。 解决一：普通方法123456var t;function foo() &#123; if (t) return t; t = new Date() return t;&#125; 问题有两个，一是污染了全局变量，二是每次调用 foo 的时候都需要进行一次判断。 解决二：闭包 我们很容易想到用闭包避免污染全局变量。 12345678var foo = (function() &#123; var t; return function() &#123; if (t) return t; t = new Date(); return t; &#125;&#125;)(); 然而还是没有解决调用时都必须进行一次判断的问题。 解决三：函数对象函数也是一种对象，利用这个特性，我们也可以解决这个问题。 12345function foo() &#123; if (foo.t) return foo.t; foo.t = new Date(); return foo.t;&#125; 依旧没有解决调用时都必须进行一次判断的问题。 解决四：惰性函数不错，惰性函数就是解决每次都要进行判断的这个问题，解决原理很简单，重写函数。 1234567var foo = function() &#123; var t = new Date(); foo = function() &#123; return t; &#125;; return foo();&#125;; 更多应用DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断： 123456789// 简化写法function addEvent (type, el, fn) &#123; if (window.addEventListener) &#123; el.addEventListener(type, fn, false); &#125; else if(window.attachEvent)&#123; el.attachEvent('on' + type, fn); &#125;&#125; 问题在于我们每当使用一次 addEvent 时都会进行一次判断。 利用惰性函数，我们可以这样做： 123456789101112function addEvent (type, el, fn) &#123; if (window.addEventListener) &#123; addEvent = function (type, el, fn) &#123; el.addEventListener(type, fn, false); &#125; &#125; else if(window.attachEvent)&#123; addEvent = function (type, el, fn) &#123; el.attachEvent('on' + type, fn); &#125; &#125;&#125; 当然我们也可以使用闭包的形式： 123456789101112var addEvent = (function()&#123; if (window.addEventListener) &#123; return function (type, el, fn) &#123; el.addEventListener(type, fn, false); &#125; &#125; else if(window.attachEvent)&#123; return function (type, el, fn) &#123; el.attachEvent('on' + type, fn); &#125; &#125;&#125;)(); 当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会发生改变的时候，想想是否可以考虑使用惰性函数。 重要参考Lazy Function Definition Pattern 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之从原型到原型链","date":"2019-04-13T07:27:41.242Z","updated":"2019-04-13T07:27:41.242Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之从原型到原型链/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之从原型到原型链/","excerpt":"JavaScript深入之从原型到原型链 JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin","text":"JavaScript深入之从原型到原型链 JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123;&#125;Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 下一篇文章JavaScript深入之词法作用域和动态作用域 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之递归","date":"2019-04-13T07:27:41.236Z","updated":"2019-04-13T07:27:41.236Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之递归/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之递归/","excerpt":"JavaScript专题之递归定义程序调用自身的编程技巧称为递归(recursion)。 阶乘以阶乘为例： 123456function factorial(n) &#123; if (n == 1) return n; return n * factorial(n - 1)&#125;console.log(factorial(5)) // 5 * 4 * 3 * 2 * 1 = 120","text":"JavaScript专题之递归定义程序调用自身的编程技巧称为递归(recursion)。 阶乘以阶乘为例： 123456function factorial(n) &#123; if (n == 1) return n; return n * factorial(n - 1)&#125;console.log(factorial(5)) // 5 * 4 * 3 * 2 * 1 = 120 示意图(图片来自 wwww.penjee.com)： 斐波那契数列在《JavaScript专题之函数记忆》中讲到过的斐波那契数列也使用了递归： 12345function fibonacci(n)&#123; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;console.log(fibonacci(5)) // 1 1 2 3 5 递归条件从这两个例子中，我们可以看出： 构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 n == 1 和 斐波那契数列中的 n &lt; 2 都是边界条件。 总结一下递归的特点： 子问题须与原始问题为同样的事，且更为简单； 不能无限制地调用本身，须有个出口，化简为非递归状况处理。 了解这些特点可以帮助我们更好的编写递归函数。 执行上下文栈在《JavaScript深入之执行上下文栈》中，我们知道： 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 试着对阶乘函数分析执行的过程，我们会发现，JavaScript 会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文也是一笔不小的开销呐！那么，我们该如何优化呢？ 答案就是尾调用。 尾调用尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。 举个例子： 1234// 尾调用function f(x)&#123; return g(x);&#125; 然而 1234// 非尾调用function f(x)&#123; return g(x) + 1;&#125; 并不是尾调用，因为 g(x) 的返回值还需要跟 1 进行计算后，f(x)才会返回值。 两者又有什么区别呢？答案就是执行上下文栈的变化不一样。 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = []; 我们模拟下第一个尾调用函数执行时的执行上下文栈变化： 12345678// 伪代码ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.push(&lt;g&gt; functionContext);ECStack.pop(); 我们再来模拟一下第二个非尾调用函数执行时的执行上下文栈变化： 1234567ECStack.push(&lt;f&gt; functionContext);ECStack.push(&lt;g&gt; functionContext);ECStack.pop();ECStack.pop(); 也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 所以我们只用把阶乘函数改造成一个尾递归形式，就可以避免创建那么多的执行上下文。但是我们该怎么做呢？ 阶乘函数优化我们需要做的就是把所有用到的内部变量改写成函数的参数，以阶乘函数为例： 123456function factorial(n, res) &#123; if (n == 1) return res; return factorial2(n - 1, n * res)&#125;console.log(factorial(4, 1)) // 24 然而这个很奇怪呐……我们计算 4 的阶乘，结果函数要传入 4 和 1，我就不能只传入一个 4 吗？ 这个时候就要用到我们在《JavaScript专题之柯里化》中编写的 curry 函数了： 123var newFactorial = curry(factorial, _, 1)newFactorial(5) // 24 应用如果你看过 JavaScript 专题系列的文章，你会发现递归有着很多的应用。 作为专题系列的第十八篇，我们来盘点下之前的文章中都有哪些涉及到了递归： 1.《JavaScript 专题之数组扁平化》： 12345function flatten(arr) &#123; return arr.reduce(function(prev, next)&#123; return prev.concat(Array.isArray(next) ? flatten(next) : next) &#125;, [])&#125; 2.《JavaScript 专题之深浅拷贝》： 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125; 3.JavaScript 专题之从零实现 jQuery 的 extend： 12345678910111213141516171819202122232425262728293031// 非完整版本，完整版本请点击查看具体的文章function extend() &#123; ... // 循环遍历要复制的对象们 for (; i &lt; length; i++) &#123; // 获取当前对象 options = arguments[i]; // 要求不能为空 避免extend(a,,b)这种情况 if (options != null) &#123; for (name in options) &#123; // 目标属性值 src = target[name]; // 要复制的对象的属性值 copy = options[name]; if (deep &amp;&amp; copy &amp;&amp; typeof copy == 'object') &#123; // 递归调用 target[name] = extend(deep, src, copy); &#125; else if (copy !== undefined)&#123; target[name] = copy; &#125; &#125; &#125; &#125; ...&#125;; 4.《JavaScript 专题之如何判断两个对象相等》： 12345678910111213141516171819202122232425262728293031323334353637383940// 非完整版本，完整版本请点击查看具体的文章// 属于间接调用function eq(a, b, aStack, bStack) &#123; ... // 更复杂的对象使用 deepEq 函数进行深度比较 return deepEq(a, b, aStack, bStack);&#125;;function deepEq(a, b, aStack, bStack) &#123; ... // 数组判断 if (areArrays) &#123; length = a.length; if (length !== b.length) return false; while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; // 对象判断 else &#123; var keys = Object.keys(a), key; length = keys.length; if (Object.keys(b).length !== length) return false; while (length--) &#123; key = keys[length]; if (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125;&#125; 5.《JavaScript 专题之函数柯里化》： 123456789101112131415161718192021222324252627// 非完整版本，完整版本请点击查看具体的文章function curry(fn, args) &#123; length = fn.length; args = args || []; return function() &#123; var _args = args.slice(0), arg, i; for (i = 0; i &lt; arguments.length; i++) &#123; arg = arguments[i]; _args.push(arg); &#125; if (_args.length &lt; length) &#123; return curry.call(this, fn, _args); &#125; else &#123; return fn.apply(this, _args); &#125; &#125;&#125; 写在最后递归的内容远不止这些，比如还有汉诺塔、二叉树遍历等递归场景，本篇就不过多展开，真希望未来能写个算法系列。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之闭包","date":"2019-04-13T07:27:41.231Z","updated":"2019-04-13T07:27:41.231Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之闭包/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之闭包/","excerpt":"JavaScript深入之闭包 JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量","text":"JavaScript深入之闭包 JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量举个例子： 1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动： 1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 下一篇文章JavaScript深入之参数按值传递 相关链接如果想了解执行上下文的具体变化，不妨循序渐进，阅读这六篇： 《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之词法作用域和动态作用域","date":"2019-04-13T07:27:41.229Z","updated":"2019-04-13T07:27:41.229Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之词法作用域和动态作用域/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之词法作用域和动态作用域/","excerpt":"JavaScript深入之词法作用域和动态作用域 JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。","text":"JavaScript深入之词法作用域和动态作用域 JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 这个文件也可以在github博客仓库中找到。 思考题最后，让我们看一个《JavaScript权威指南》中的例子： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript深入之执行上下文栈》。 下一篇文章JavaScript深入之执行上下文栈 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"深入系列文章/JavaScript深入之执行上下文栈","date":"2019-04-13T07:27:41.225Z","updated":"2019-04-13T07:27:41.225Z","comments":true,"path":"2019/04/13/深入系列文章/JavaScript深入之执行上下文栈/","link":"","permalink":"https://qccs.github.io/2019/04/13/深入系列文章/JavaScript深入之执行上下文栈/","excerpt":"JavaScript深入之执行上下文栈 JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：","text":"JavaScript深入之执行上下文栈 JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 然而去看这段代码： 12345678910111213141516function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 打印的结果却是两个 foo2。 刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。 下一篇文章《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"","slug":"专题系列文章/JavaScript专题之在数组中查找指定元素","date":"2019-04-13T07:24:53.709Z","updated":"2019-04-13T07:24:53.709Z","comments":true,"path":"2019/04/13/专题系列文章/JavaScript专题之在数组中查找指定元素/","link":"","permalink":"https://qccs.github.io/2019/04/13/专题系列文章/JavaScript专题之在数组中查找指定元素/","excerpt":"JavaScript专题之学underscore在数组中查找指定元素前言在开发中，我们经常会遇到在数组中查找指定元素的需求，可能大家觉得这个需求过于简单，然而如何优雅的去实现一个 findIndex 和 findLastIndex、indexOf 和 lastIndexOf 方法却是很少人去思考的。本文就带着大家一起参考着 underscore 去实现这些方法。 在实现前，先看看 ES6 的 findIndex 方法，让大家了解 findIndex 的使用方法。","text":"JavaScript专题之学underscore在数组中查找指定元素前言在开发中，我们经常会遇到在数组中查找指定元素的需求，可能大家觉得这个需求过于简单，然而如何优雅的去实现一个 findIndex 和 findLastIndex、indexOf 和 lastIndexOf 方法却是很少人去思考的。本文就带着大家一起参考着 underscore 去实现这些方法。 在实现前，先看看 ES6 的 findIndex 方法，让大家了解 findIndex 的使用方法。 findIndexES6 对数组新增了 findIndex 方法，它会返回数组中满足提供的函数的第一个元素的索引，否则返回 -1。 举个例子： 12345function isBigEnough(element) &#123; return element &gt;= 15;&#125;[12, 5, 8, 130, 44].findIndex(isBigEnough); // 3 findIndex 会找出第一个大于 15 的元素的下标，所以最后返回 3。 是不是很简单，其实，我们自己去实现一个 findIndex 也很简单。 实现findIndex思路自然很明了，遍历一遍，返回符合要求的值的下标即可。 12345678910function findIndex(array, predicate, context) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (predicate.call(context, array[i], i, array)) return i; &#125; return -1;&#125;console.log(findIndex([1, 2, 3, 4], function(item, i, array)&#123; if (item == 3) return true;&#125;)) // 2 findLastIndexfindIndex 是正序查找，但正如 indexOf 还有一个对应的 lastIndexOf 方法，我们也想写一个倒序查找的 findLastIndex 函数。实现自然也很简单，只要修改下循环即可。 1234567891011function findLastIndex(array, predicate, context) &#123; var length = array.length; for (var i = length; i &gt;= 0; i--) &#123; if (predicate.call(context, array[i], i, array)) return i; &#125; return -1;&#125;console.log(findLastIndex([1, 2, 3, 4], function(item, index, array)&#123; if (item == 1) return true;&#125;)) // 0 createIndexFinder然而问题在于，findIndex 和 findLastIndex 其实有很多重复的部分，如何精简冗余的内容呢？这便是我们要学习的地方，日后面试问到此类问题，也是加分的选项。 underscore 的思路就是利用传参的不同，返回不同的函数。这个自然是简单，但是如何根据参数的不同，在同一个循环中，实现正序和倒序遍历呢？ 让我们直接模仿 underscore 的实现： 12345678910111213141516function createIndexFinder(dir) &#123; return function(array, predicate, context) &#123; var length = array.length; var index = dir &gt; 0 ? 0 : length - 1; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (predicate.call(context, array[index], index, array)) return index; &#125; return -1; &#125;&#125;var findIndex = createIndexFinder(1);var findLastIndex = createIndexFinder(-1); sortedIndexfindIndex 和 findLastIndex 的需求算是结束了，但是又来了一个新需求：在一个排好序的数组中找到 value 对应的位置，保证插入数组后，依然保持有序的状态。 假设该函数命名为 sortedIndex，效果为： 1sortedIndex([10, 20, 30], 25); // 2 也就是说如果，注意是如果，25 按照此下标插入数组后，数组变成 [10, 20, 25, 30]，数组依然是有序的状态。 那么这个又该如何实现呢？ 既然是有序的数组，那我们就不需要遍历，大可以使用二分查找法，确定值的位置。让我们尝试着去写一版： 123456789101112131415// 第一版function sortedIndex(array, obj) &#123; var low = 0, high = array.length; while (low &lt; high) &#123; var mid = Math.floor((low + high) / 2); if (array[mid] &lt; obj) low = mid + 1; else high = mid; &#125; return high;&#125;;console.log(sortedIndex([10, 20, 30, 40, 50], 35)) // 3 现在的方法虽然能用，但通用性不够，比如我们希望能处理这样的情况： 12345678// stooges 配角 比如 三个臭皮匠 The Three Stoogesvar stooges = [&#123;name: 'stooge1', age: 10&#125;, &#123;name: 'stooge2', age: 30&#125;];var result = sortedIndex(stooges, &#123;name: 'stooge3', age: 20&#125;, function(stooge)&#123; return stooge.age&#125;);console.log(result) // 1 所以我们还需要再加上一个参数 iteratee 函数对数组的每一个元素进行处理，一般这个时候，还会涉及到 this 指向的问题，所以我们再传一个 context 来让我们可以指定 this，那么这样一个函数又该如何写呢？ 12345678910111213141516171819// 第二版function cb(fn, context) &#123; return function(obj) &#123; return fn ? fn.call(context, obj) : obj; &#125;&#125;function sortedIndex(array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context) var low = 0, high = array.length; while (low &lt; high) &#123; var mid = Math.floor((low + high) / 2); if (iteratee(array[mid]) &lt; iteratee(obj)) low = mid + 1; else high = mid; &#125; return high;&#125;; indexOfsortedIndex 也完成了，现在我们尝试着去写一个 indexOf 和 lastIndexOf 函数，学习 findIndex 和 FindLastIndex 的方式，我们写一版： 123456789101112131415161718// 第一版function createIndexOfFinder(dir) &#123; return function(array, item)&#123; var length = array.length; var index = dir &gt; 0 ? 0 : length - 1; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (array[index] === item) return index; &#125; return -1; &#125;&#125;var indexOf = createIndexOfFinder(1);var lastIndexOf = createIndexOfFinder(-1);var result = indexOf([1, 2, 3, 4, 5], 2);console.log(result) // 1 fromIndex但是即使是数组的 indexOf 方法也可以多传递一个参数 fromIndex，从 MDN 中看到 fromIndex 的讲究可有点多： 设定开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于 0，则整个数组都将会被查询。其默认值为 0。 再看看 lastIndexOf 的 fromIndex： 从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 按照这么多的规则，我们尝试着去写第二版： 12345678910111213141516171819202122232425// 第二版function createIndexOfFinder(dir) &#123; return function(array, item, idx)&#123; var length = array.length; var i = 0; if (typeof idx == \"number\") &#123; if (dir &gt; 0) &#123; i = idx &gt;= 0 ? idx : Math.max(length + idx, 0); &#125; else &#123; length = idx &gt;= 0 ? Math.min(idx + 1, length) : idx + length + 1; &#125; &#125; for (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123; if (array[idx] === item) return idx; &#125; return -1; &#125;&#125;var indexOf = createIndexOfFinder(1);var lastIndexOf = createIndexOfFinder(-1); 优化到此为止，已经很接近原生的 indexOf 函数了，但是 underscore 在此基础上还做了两点优化。 第一个优化是支持查找 NaN。 因为 NaN 不全等于 NaN，所以原生的 indexOf 并不能找出 NaN 的下标。 1[1, NaN].indexOf(NaN) // -1 那么我们该如何实现这个功能呢？ 就是从数组中找到符合条件的值的下标嘛，不就是我们最一开始写的 findIndex 吗？ 我们来写一下： 1234567891011121314151617181920// 第三版function createIndexOfFinder(dir, predicate) &#123; return function(array, item, idx)&#123; if () &#123; ... &#125; // 判断元素是否是 NaN if (item !== item) &#123; // 在截取好的数组中查找第一个满足isNaN函数的元素的下标 idx = predicate(array.slice(i, length), isNaN) return idx &gt;= 0 ? idx + i: -1; &#125; for () &#123; ... &#125; &#125;&#125;var indexOf = createIndexOfFinder(1, findIndex);var lastIndexOf = createIndexOfFinder(-1, findLastIndex); 第二个优化是支持对有序的数组进行更快的二分查找。 如果 indexOf 第三个参数不传开始搜索的下标值，而是一个布尔值 true，就认为数组是一个排好序的数组，这时候，就会采用更快的二分法进行查找，这个时候，可以利用我们写的 sortedIndex 函数。 在这里直接给最终的源码： 123456789101112131415161718192021222324252627282930313233343536// 第四版function createIndexOfFinder(dir, predicate, sortedIndex) &#123; return function(array, item, idx)&#123; var length = array.length; var i = 0; if (typeof idx == \"number\") &#123; if (dir &gt; 0) &#123; i = idx &gt;= 0 ? idx : Math.max(length + idx, 0); &#125; else &#123; length = idx &gt;= 0 ? Math.min(idx + 1, length) : idx + length + 1; &#125; &#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123; idx = sortedIndex(array, item); // 如果该插入的位置的值正好等于元素的值，说明是第一个符合要求的值 return array[idx] === item ? idx : -1; &#125; // 判断是否是 NaN if (item !== item) &#123; idx = predicate(array.slice(i, length), isNaN) return idx &gt;= 0 ? idx + i: -1; &#125; for (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123; if (array[idx] === item) return idx; &#125; return -1; &#125;&#125;var indexOf = createIndexOfFinder(1, findIndex, sortedIndex);var lastIndexOf = createIndexOfFinder(-1, findLastIndex); 值得注意的是：在 underscore 的实现中，只有 indexOf 是支持有序数组使用二分查找，lastIndexOf 并不支持。 专题系列JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[],"tags":[]},{"title":"浅谈正则表达式中的分组和引用","slug":"z/2016-05-06-regular-expression-group","date":"2016-05-06T03:40:18.000Z","updated":"2019-04-14T09:29:00.623Z","comments":true,"path":"2016/05/06/z/2016-05-06-regular-expression-group/","link":"","permalink":"https://qccs.github.io/2016/05/06/z/2016-05-06-regular-expression-group/","excerpt":"content{:toc} 由正则表达式如何匹配相同字符出发，讲讲正则表达式中的选择、分组和引用。 问题在外刊君读者群中看到有人提出这样的一个需求： 把字符串切成连续相同字符的正则怎么写？比如abbcccdddd切成a,bb,ccc,dddd 之前我对正则表达式也是略有研究，想尝试一下。其实我对正则表达式的学习基本完全来源于犀牛书的第10章，真正看懂这一章，我觉得操作正则表达式应该不在话下。","text":"content{:toc} 由正则表达式如何匹配相同字符出发，讲讲正则表达式中的选择、分组和引用。 问题在外刊君读者群中看到有人提出这样的一个需求： 把字符串切成连续相同字符的正则怎么写？比如abbcccdddd切成a,bb,ccc,dddd 之前我对正则表达式也是略有研究，想尝试一下。其实我对正则表达式的学习基本完全来源于犀牛书的第10章，真正看懂这一章，我觉得操作正则表达式应该不在话下。 我的答案先给出我的答案吧： 1'abbccddd'.match(/(\\w)\\1*/g) // [\"a\", \"bb\", \"cc\", \"ddd\"] 说明拿到这个问题，首先要匹配字符[a-zA-Z0-9]，这里直接使用\\w。然后是全局匹配，在最后加上g。难点在于怎么判断重复。 翻看了犀牛书后，又读了一遍分组和引用的部分。使用小括号()将字符作为一个最小单元，同时小括号还能记忆这个组合相匹配的字符串。再使用反斜杠\\引用前面分组的表达式，数字1表示第一个小括号。这时完成了2个字符重复的要求。最后再使用*来匹配出现0次或n次。这个正则表达式就写完了。 下面详细说说分组和引用。 正则表达式的选择、分组和引用字符表 字符 含义 ` ` 选择，匹配的是该符号左边的子表达式或右边的子表达式 (...) 组合，将几个项组合为一个单元，这个单元可通过* + ? ` ` 等符号加以修饰，而且可以记住和这个组合相匹配的字符串以提供伺候的引用使用 (?:...) 只组合，把项组合到一个段元，但不记忆与该组相匹配的字符 \\n 和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式（也有可能是嵌套的），组索引是从左到右的左括号数，(?:形式的分组不编码","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"正则 分组 Regular","slug":"正则-分组-Regular","permalink":"https://qccs.github.io/tags/正则-分组-Regular/"}]},{"title":"前端处理动态 url 和 pushStatus 的使用","slug":"z/2015-12-31-History-API","date":"2015-12-31T15:06:05.000Z","updated":"2019-04-14T09:29:00.620Z","comments":true,"path":"2015/12/31/z/2015-12-31-History-API/","link":"","permalink":"https://qccs.github.io/2015/12/31/z/2015-12-31-History-API/","excerpt":"content{:toc} 起因起因是这样的，在尝试前后端分离的这条道路上，我自己也在不断摸索，感觉要把大部分的坑都踩踩了。目前我用的技术是： webpack 自动构建 AMD 模块化 js Sass 预处理 CSS 使用前端模板引擎 handlebars 解决动态操作将 html 拼接在 js 中的问题 但最近写了一个项目类似知乎这样的多页网站。前端 url 的处理让我觉得不够优雅。我使用的是 hash 的方式处理动态 url 的，为此我专门在知乎上提了一个问题：前端如何处理动态url？","text":"content{:toc} 起因起因是这样的，在尝试前后端分离的这条道路上，我自己也在不断摸索，感觉要把大部分的坑都踩踩了。目前我用的技术是： webpack 自动构建 AMD 模块化 js Sass 预处理 CSS 使用前端模板引擎 handlebars 解决动态操作将 html 拼接在 js 中的问题 但最近写了一个项目类似知乎这样的多页网站。前端 url 的处理让我觉得不够优雅。我使用的是 hash 的方式处理动态 url 的，为此我专门在知乎上提了一个问题：前端如何处理动态url？ 这里我将问题描述如下： 前后端彻底分离的情况下，页面跳转页全部由前端控制。那么如何更好的处理动态url地址？例如本问题的url为https://www.zhihu.com/question/38802932这肯定是用后台路由处理的url 纯前端怎么处理？用hash吗，如下:https://www.zhihu.com/question#38802932那如果本页跳转，只改变hash的话，页面不会刷新。使用location.reload()倒是可以解决。 但总觉得这样处理不够优雅。大家在工作中是如何处理此类场景的？还是用传统的后台路由来提供动态url？ 感谢郑海波和剧中人的热心回答。都提到了history对象中的pushState，这是我第一次接触到这方面的内容（顿时觉得自己真是才疏学浅）。 同时也有人提到了pjax，这个就是pushState+Ajax的封装，也很有意思。 下面就来研究和实践一下吧。 Historywindow对象通过history对象提供对浏览器历史记录的访问能力。它暴露了一些非常有用的方法和属性，让你在历史记录中自由前进和后退，而在 HTML5 中，更可以操纵历史记录中的数据。 back(), forward(), go(), length浏览器的历史记录就好像一个栈，最新的在最上面，较早之前看过的在下面。 如下图，Chrome的历史记录： 下面介绍怎么在这些历史记录中跳转，但要注意，上图中的浏览器历史记录和本文说的 history 还不太同。 back() 在历史记录中后退 history.back(); forward() 在历史记录中前进 history.forward(); go() 移动到指定的历史记录点 history.go(-1); 通过指定一个相对于当前页面位置的数值，你可以使用go()方法从当前会话的历史记录中加载页面（当前页面位置索引值为0，上一页就是-1，下一页为1）。 go()不填参数或参数为go(0)时，页面会刷新，即history.go()或history.go(0)相当于location.reload() length length为history的属性，显示history长度。 本节在线demo见：History &amp; pjax demo 源代码： 经过亲自测试，history对象只记录同一个 tab 页内的历史。如果是在新窗口打开的，则无效。如：在a标签中添加target=&quot;_blank&quot;，或按住ctrl点击，这类场景下，在新的tab页中，history对象也是新的。 且history对象记录的信息与是否同源也无关，所以唯一要满足的就是同一个标签页。 pushState(), replaceState()HTML5 引进了history.pushState()方法和history.replaceState()方法，它们允许你逐条地添加和修改历史记录条目，能够在不加载新页面的情况下没改变浏览器的URL。这些方法可以协同window.onpopstate事件一起工作。 使用history.pushState()会改变referrer的值，而在你调用方法后创建的 XMLHttpRequest 对象会在 HTTP 请求头中使用这个值。referrer的值则是创建 XMLHttpRequest 对象时所处的窗口的 URL。 pushState(any data, string title, [string url]) 第一个参数为history对象的state属性值，可以放任意数据，记录历史状态。第二个参数是新状态的标题，目前浏览器基本不支持。第三个参数为可选的相对url。 执行pushState后，可以在不加载新页面的情况下，更改url。同时history栈中新增一条数据。 例如，我们有这样一段代码： &lt;button id=&quot;push1&quot;&gt;pushState()&lt;/button&gt; document.querySelector(&apos;#push1&apos;).addEventListener(&apos;click&apos;, function() { history.pushState(&apos;abc&apos;,&apos;pushStatePageTitle&apos;,&apos;pushState.html&apos;); document.querySelector(&apos;#length&apos;).innerHTML = history.length;//重新读取历史长度 }); 当点击按钮的时候，页面不会刷新，但url地址的最后已经变为pushState.html。这一点非常像hash的作用，但比hash更优雅。 replaceState(any data, string title, [string url]) 与pushState()类似，只是在history栈中不是新增记录，而是替换一条记录。 需要注意的是：pushState()和replaceState()方法存在安全方面的限制，本地测试是无效的，会报错，可以简单放到任何服务端测试，或者使用http-server开启简单服务器，通过访问localhost来查看效果。 本节demo见：History &amp; pjax demo - pushState pjax现在再看本文一开始提出的问题，如何让前端优雅的控制 url，这里就可以考虑 pjax 技术了。我们把 pushState + ajax 进行封装，合起来简称为 pjax。虽然不是什么新的技术，但概念已然不同。 如果不使用 pjax。我们依然可以使用hash来实现文本开始的需求。但会不利于 SEO，看着也不够优雅。 Pjax的原理十分简单。 拦截 a 标签的默认跳转动作或某些按钮的点击事件。 使用 Ajax 请求新页面。 将返回的 Html 替换到页面中。 使用 HTML5 的pushState()修改Url。 个人理解3中也可以仅仅请求数据，再由浏览器渲染。 每当同一个文档的浏览历史（即history对象）出现变化时，会触发window.onpopstate事件。 window.onpopstate = function(event) { console.log(event.state); console.log(location); }; 这样在用户点击前进后退时也可以很好的监听url，来做相应的页面渲染。 若用户刷新了页面，但没有相应的页面资源，这时页面就会显示不存在。所以我认为较好的方法是在写pushState()第三个参数的时候，写为?a=1这样的参数形式。History.js 也是这么写的。但是这样应该会多一次请求。也许使用 nodeJS 作为中间层会好一些吧。 对于上述的探索，不知道是不是我还不够深入，总觉得还是不够完美。 参考 MDN History MDN 操纵浏览器的历史记录 pjax 是如何工作的？ 知乎 PJAX的实现与应用 小胡子哥 URL的井号-阮一峰 history对象 JavaScript 标准参考教程（alpha） 阮一峰 Pjax(pushState and Ajax) 黯羽轻扬 操纵历史，利用HTML5 History API实现无刷新跳转 蓝飞 前端：将网站打造成单页面应用SPA（一） Coffce coffce-pjax History.js defunkt/jquery-pjax GitHub welefen/pjax","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript Ajax URL HistoryApi pushState pjax","slug":"JavaScript-Ajax-URL-HistoryApi-pushState-pjax","permalink":"https://qccs.github.io/tags/JavaScript-Ajax-URL-HistoryApi-pushState-pjax/"}]},{"title":"Weinre --WebApp 调试工具","slug":"z/2015-06-18-weinre","date":"2015-06-17T16:06:05.000Z","updated":"2019-04-14T09:29:00.571Z","comments":true,"path":"2015/06/18/z/2015-06-18-weinre/","link":"","permalink":"https://qccs.github.io/2015/06/18/z/2015-06-18-weinre/","excerpt":"content{:toc} 什么是 weinre？weinre官网 上有两句有意思的介绍： weinre is WEb INspector REmote. Pronounced like the word “winery”. Or maybe like the word “weiner”. Who knows, really. weinre is a debugger for web pages, like FireBug (for FireFox) and Web Inspector (for WebKit-based browsers), except it’s designed to work remotely, and in particular, to allow you debug web pages on a mobile device such as a phone. 上面说 weinre 是一个远程 web 调试器。说到了它的发音，还挺幽默，哈哈。 远程 web 调试器。先说调试器，就像火狐中的 FireBug，Chrome 中的调试器一样。就是在浏览器中按下 F12 出现的那个工具。但是在手机上，你没办法按 F12，而这个 weinre 就是在手机上的 F12，与传统的不同的是，它是在手机上浏览你的 web 页面，在 PC 上查看调试工具，非常方便，这就是所谓的远程。","text":"content{:toc} 什么是 weinre？weinre官网 上有两句有意思的介绍： weinre is WEb INspector REmote. Pronounced like the word “winery”. Or maybe like the word “weiner”. Who knows, really. weinre is a debugger for web pages, like FireBug (for FireFox) and Web Inspector (for WebKit-based browsers), except it’s designed to work remotely, and in particular, to allow you debug web pages on a mobile device such as a phone. 上面说 weinre 是一个远程 web 调试器。说到了它的发音，还挺幽默，哈哈。 远程 web 调试器。先说调试器，就像火狐中的 FireBug，Chrome 中的调试器一样。就是在浏览器中按下 F12 出现的那个工具。但是在手机上，你没办法按 F12，而这个 weinre 就是在手机上的 F12，与传统的不同的是，它是在手机上浏览你的 web 页面，在 PC 上查看调试工具，非常方便，这就是所谓的远程。 为什么用 weinre？现代浏览器中调试工具都非常强大了，可以直接模拟手机设备，为什么还要用 weinre 这么麻烦的东西呢？ 我觉得 PC 端的浏览器虽说可以模拟，但模拟毕竟还是模拟，还只是鼠标长按滑来滑去。在开发过程中，使用手机或平板直接来感受是多么的酷，指尖在移动设备的屏幕上摩擦摩擦！给人的直观感受绝对秒杀浏览器的模拟。 原理使用一种工具之前，了解它的原理和结构是很有帮助的。weinre 作为一种远程调试工具，在结构上分为三层： 目标页面（target）：被调试的页面，页面已嵌入 weinre 的远程 js，下文会介绍； Debug客户端（client）：本地的 Web Inspector 调试客户端； Debug服务端（agent）：一个 HTTP Server，为目标页面与 Debug 客户端建立通信。 三层结构如下图所示： weinre 的 debug 客户端是基于 Web Inspector 开发，而 Web Inspector 只与以 WebKit 为核心的浏览器兼容，所以 Weinre 的客户端只能用 Chrome 或者 Safari 打开。 官网上也有相应的平台支持说明： Platforms supported - debug server 服务端 任何支持 node.js 的平台。 Platforms supported - debug client 客户端（跑 debugger 界面的浏览器） Google Chrome Apple Safari Other recent-ish WebKit-based browsers 其他基于 webkit 内核的现代浏览器 Platforms supported - debug target 目标页面（在移动设备中调试运行的目标页面） Android Browser application iOS Mobile Safari application PhoneGap/Cordova other 安装 weinre 是 nodeJS 的一个应用，首先要 安装 nodeJS 运行环境 使用 npm 命令，安装 weinre npm -g install weinre 安装成功后会有类似的信息： C:\\Users\\haoyang\\AppData\\Roaming\\npm\\weinre -&gt; C:\\Users\\haoyang\\AppData\\Roaming\\npm\\node_modules\\weinre\\weinre weinre@2.0.0-pre-I0Z7U9OV C:\\Users\\haoyang\\AppData\\Roaming\\npm\\node_modules\\weinre ├── underscore@1.7.0 ├── nopt@3.0.2 (abbrev@1.0.7) └── express@2.5.11 (mime@1.2.4, qs@0.4.2, mkdirp@0.3.0, connect@1.9.2) 使用 启动服务 weinre --boundHost -all- --httpPort 8081 –boundHost [hostname | ip address | -all-] The ip address to bind the server to. –httpPort [portNumber] The port to run the HTTP server on. 更多配置项参考 官网的说明。 启动成功后看到如下界面： 给目标页面添加一行脚本 可以看到 2.中的 Target Script 说要添加一行脚本到要调试的 web 页面中。 Target Script You can use this script to inject the weinre target code into your web page. http://localhost:8081/target/target-script-min.js#anonymous Example: &lt;script src=&quot;http://localhost:8081/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 这里要说明一下，要把上面的 localhost 换为本机的 ip 地址。 我们可以在命令行中 使用 ipconfig 得到 ip 地址，如下（当然你的可能和我的不一样）： IPv4 地址 . . . . . . . . . . . . : 192.168.1.107 即插入如下代码： &lt;script src=&quot;http://192.168.1.107:8081/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 进入调试页面 PC 端访问这个地址： debug client user interface: http://localhost:8081/client/#anonymous 此时 target 为 none，如下图： 现在我们要用手机访问同一个局域网下的这个目标页面。我们可以把要调试的页面放到这个路径下： C:\\Users\\haoyang\\AppData\\Roaming\\npm\\node_modules\\weinre\\web 通过 http://192.168.1.107:8081/FILE_NAME 在手机上访问，就可以看到了。当然前提是同一个局域网。 但是这样可能不太灵活，每次都要把目标页面放到指定的目录下。所以我们可以另外开一个服务器。 我使用了基于 node.js 的 http-server 工具。将要调试的页面发布。这样我就能通过 ip 地址加端口号在手机上访问到了。 我在手机上访问 http://192.168.1.107:8080 打开要调试的页面，此时 debug client user interface 中自动检测到 target。就可以进行调试了！ 如下图： 参考 Web移动应用调试工具——Weinre weinre - WEb INspector REmote webapp开发调试环境–weinre配置","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"Weinre WebApp 调试工具 JavaScript HTML CSS","slug":"Weinre-WebApp-调试工具-JavaScript-HTML-CSS","permalink":"https://qccs.github.io/tags/Weinre-WebApp-调试工具-JavaScript-HTML-CSS/"}]},{"title":"Web App 相关技术","slug":"z/2015-06-17-web-app","date":"2015-06-17T06:06:05.000Z","updated":"2019-04-14T09:29:00.587Z","comments":true,"path":"2015/06/17/z/2015-06-17-web-app/","link":"","permalink":"https://qccs.github.io/2015/06/17/z/2015-06-17-web-app/","excerpt":"content{:toc} 往前推2到3年，前端工程师还在忧心忡忡地想，移动互联网时代下，前端是不是没有生存空间了。但今天一看，在我们团队，前端工程师超过一半的工作都是在做移动端的Web或者APP的开发。移动Web或者APP在技术本质上是和做桌面端Web没有本质区别，但是移动端的坑那是非常的多，通过学习这部分内容，让你成为一名桌面移动通吃的前端开发工程师。","text":"content{:toc} 往前推2到3年，前端工程师还在忧心忡忡地想，移动互联网时代下，前端是不是没有生存空间了。但今天一看，在我们团队，前端工程师超过一半的工作都是在做移动端的Web或者APP的开发。移动Web或者APP在技术本质上是和做桌面端Web没有本质区别，但是移动端的坑那是非常的多，通过学习这部分内容，让你成为一名桌面移动通吃的前端开发工程师。 概念 参考： 移动 Web 开发入门 上面这个 slide 资料讲的非常好，算是一个入门的介绍吧。带我们建立基本的移动 web 开发知识体系和常见问题的实践。包含以下几个方面： 基本概念 Native 本地应用 使用 Java \\ Objective-C \\ Swift 开发 WebApp 网页应用 html5 开发 Hybrid 混合应用 ooxx(native, web) 对比 视觉 设备的像素 文字单位使用 rem viewport 属性 横屏竖屏 Flex 伸缩布局 响应式设计 软键盘 隐藏地址栏 苹果设备添加到主屏图标 交互 Touch click 延迟 Scroll Gestures(hammer –A javascript library for multi-touch gestures) 手指友好设计 HTML5 APIS（图像，摇动，声音等） 实践 屏蔽点击元素时的阴影 图像（像素、矢量图标、base64 减少请求、lazyload） CSS3（合理使用渐变/圆角/阴影、代替 js 动画、translate3d、解决动画闪烁） localStorage 避免（iframe、fixed + input） SPA 或 Multi page can I use 压缩合并 @G/3G 下建立连接时间 调试 浏览器自己的调试工具，模拟手机设备 weinre 关于 weinre 我写了一篇博客介绍它。Weinre –WebApp 调试工具 head 标签参考： 移动前端不得不了解的html5 head 头标签 上面的链接详细的讲解了： DOCTYPE charset lang属性 优先使用 IE 最新版本和 Chrome 360 使用Google Chrome Frame SEO 优化部分：页面标题标签(head 头部必须)，页面关键词 keywords，页面描述内容 description，定义网页作者 author，网页搜索引擎索引方式 为移动设备添加 viewport viewport 可以让布局在移动浏览器上显示的更好。 通常会写 12&lt;meta name =\"viewport\" content =\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; content 参数： width viewport 宽度(数值/device-width) height viewport 高度(数值/device-height) initial-scale 初始缩放比例 maximum-scale 最大缩放比例 minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) ios 设备，iOS 图标，Android，Windows 8 总结： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=\"zh-cmn-Hans\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset='utf-8'&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=\"description\" content=\"不超过150个字符\"/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=\"MobileOptimized\" content=\"320\"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=\"browsermode\" content=\"application\"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=\"x5-page-mode\" content=\"app\"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面切换动画 移动端重构系列13——页面切换 CSS3 3D Transform 关于 HammerJS 的一个中文文档 Hammer.js CSS Processing CSS语言由于其自身语言设计的问题，加上一些浏览器兼容性问题，往往会使得我们在写它的时候，要写很多冗余代码，或者为了兼容性对同一个样式设定写好几遍。针对这些问题，诞生了CSS预处理和后处理的概念及相关方法、工具。 这些工具和方法帮助我们能够更加高效地书写可维护性更强的CSS代码。 这里我尝试使用了 Sass，果然很好用。下面记录几个 sass 教程。 Sass入门-w3cplus SASS用法指南-阮一峰 安装首先要有 ruby 环境。 由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了。 $ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org $ gem install sass 编译sass --watch style.scss:style.css --style expanded 补充rem 字体单位使用 rem，用户在手机上设置了字体大小时，不会打破布局，造成混乱。 CSS3的REM设置字体大小-w3cplus 响应式十日谈第一日：使用 rem 设置文字大小-一丝 安全 安全是大家经常容易忽视，但其实一旦出现影响会非常大的问题，尤其对于没有经历过企业开发，或者没有踩过坑的同学，如果等到公司工作，做实际项目后非常容易发生安全问题。 分类WEB基本攻击大致可以分为三大类：“资源枚举”、“参数操纵” 和 “其它攻击” 资源枚举 参数操纵 SQL注入 XPath注入 cgi命令执行 XXS（cross-site scripting跨域脚本攻击）其重点是“跨域”和“客户端执行” Reflected XSS ——基于反射的XSS攻击。主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。 DOM-based or local XSS——基于DOM或本地的XSS攻击 Stored XSS——基于存储的XSS攻击 会话劫持 其它攻击 CSRF（cross-site request forgery）跨站请求伪造 钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。 拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。 关于 XSS 跨网站脚本（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 ——维基百科 XSS 防护 浏览器解析顺序： HTML Parser &gt;&gt; CSS Parser &gt;&gt; JavaScript Parser 浏览器解码顺序： HTML Decoding &gt;&gt; URL Decoding &gt;&gt; JavaScript Decoding 具体的防护方式： 验证输入并且基于语境和按照正确的顺序转义不可信数据 HTML 中的字符串 HTML 属性中的字符串 事件句柄属性和 JavaScript 中的字符串 HTML 属性中的 URL 路径 HTML 风格属性和 CSS 中的字符串 JavaScript 中的 HTML 始终遵循白名单优于黑名单的做法 使用 UTF-8 为默认的字符编码以及设置 content 为 text/html 不要将用户可以控制的文本放在标签前。通过使用不同的字符集注射可以导致 XSS。 使用 &lt;!DOCTYPE html&gt; 使用推荐的 HTTP 响应头进行 XSS 防护 防止 CRLF 注入/HTTP 响应拆分 禁止 TRACE 和其他非必要方法 对于 innerHTML 的方式输出的，我们可以采用如下的方式转码 1234567891011121314/** * 转码 XSS 防护 * @param &#123;String&#125; str 用户输入的字符串 * @return &#123;String&#125; 转码后的字符串 */function changeCode(str) &#123; str = str.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\") .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;#x27;\") .replace(/\\//g, \"&amp;#x2f;\"); return str;&#125; 参考： 浅谈WEB安全性（前端向） XSS的原理分析与解剖 原创翻译：给开发者的终极XSS防护备忘录 性能优化 在自己做一些小项目时，可能是学校的一些网站项目，流量可能日均都不超过500，而且大多是校园局域网内访问；或者是开发一些实验室的MIS系统，这辈子你都不会去使用你开发的这个系统。在这样一些项目中，性能优化往往会被你忽略。 但是如果你是做一个日均PV数万、数十万、甚至更大的量级，开发的页面会被全国各地，不同网络条件的用户来进行访问。这个时候，性能问题就无法忽视了。在当今的网络条件下，如果你的页面3秒都无法完成首屏渲染，一定会让你的网站流失很多用户。 整个网站的性能优化有很多的环节和工作，大多数时候，不是前端工程师单独就能完成的，尤其在职能划分明确的公司中，往往需要前后端、运维、DBA等多个职位协同完成。所以，在我们的课程中，主要让你了解整个性能优化都涉及哪些方面的工作，同时，我们会专注介绍一些在前端领域可以重点关注的技术点。 这里就是网页的打开速度，如果你的网页打开速度很慢，那么一定会有用户的流失。所以性能优化很重要。 网页内容 减少http请求次数 减少DNS查询次数 避免页面跳转 缓存Ajax 延迟加载 提前加载 减少DOM元素数量 根据域名划分内容 减少iframe数量 避免404 服务器 使用CDN 添加Expires 或Cache-Control报文头 Gzip压缩传输文件 配置ETags 尽早flush输出 使用GET Ajax请求 避免空的图片src Cookie 减少Cookie大小 页面内容使用无cookie域名 CSS 将样式表置顶 避免CSS表达式 用\\&lt;link>代替@import 避免使用Filters Javascript 将脚本置底 使用外部Javascirpt和CSS文件 精简Javascript和CSS 去除重复脚本 减少DOM访问 使用智能事件处理 图片 优化图像 优化CSS Sprite 不要在HTML中缩放图片 使用小且可缓存的favicon.ico 移动客户端 保持单个内容小于25KB 打包组建成符合文档 具体细节参考文章： 毫秒必争，前端网页性能最佳实践 我在 ToDo 这个任务中主要使用了 CDN 来加载静态资源。比如我使用了 百度静态资源公共库。引用了里面的 fontawesome，速度果然比在 GitHub 仓库里快很多。下一步是压缩我自己写的静态资源。 其他参考资料： 给网页设计师和前端开发者看的前端性能优化 梳理：提高前端性能方面的处理以及不足 css sprite原理优缺点及使用 CSS Sprites：鱼翅还是三鹿？ 大型网站的灵魂——性能 编写高效的 CSS 选择器 模块化 对于一个复杂项目，特别是多人协作的复杂项目，如何合理划分模块，如何更加方便地进行模块加载，如何管理模块之间的依赖，是一个项目团队都会面临的问题，目前业界已经有了一些较为普遍的解决方案，如AMD。这个部分希望你能够通过学习JavaScript的模块化，学习如何合理地规划项目模块，合理使用模块化工具来优化你的项目代码结构。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 根据AMD规范，我们可以使用 define 定义模块，使用 require 调用模块。 目前，通行的 js 模块规范主要有两种：CommonJS 和 AMD。 AMD规范AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是 CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 详细 API 如下： AMD（中文版）) CommonJS规范CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。Node.JS 首先采用了 js 模块化的概念。 根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。 输出模块变量的最好方法是使用 module.exports 对象。 为什么要用 requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 requireJS requireJS 官网 requireJS 中文网 AMD和CMDCMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CMD 模块定义规范 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） 参考 Javascript模块化编程（一）：模块的写法–阮一峰 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 详解 JavaScript 模块开发 浅谈模块化的JavaScript 再谈 SeaJS 与 RequireJS 的差异 玩转AMD系列 by erik@EFE 玩转AMD - 写在前面 玩转AMD - 设计思路 玩转AMD - 应用实践 玩转AMD - Loader 前端工程化 业界目前有非常多的前端开发工具，完成一些开发过程中可以自动化完成的工作，提高研发效率，并且可以提高多人协作时的开发过程一致性，提高整个项目的运维效率。 在EFE日常工作中，我们是基于EDP，完成项目开发过程中的项目构建、包管理、调试、单测、静态检测、打包、压缩、优化、项目部署等一系列所有工作。 注： 如果网络不好，可以使用 淘宝 NPM 镜像。 参考 前端工程与模块化框架 手机百度前端工程化之路 对话百度前端工程师张云龙：F.I.S与前端工业化 EDP Grunt教程——初涉Grunt gulp入门指南 Gulp开发教程（翻译） Gulp 中文网 npm的package.json中文文档 最终作品在任务三中，做了一个 PC 端的 ToDo 应用。任务四是将它优化，以适应移动端设备。 ToDo WebApp Version 任务四要求 源代码 在线 demo 手机查看 ↓ 二维码 ↓ 我的博客 HyG Details 数据存储 以 JSON 模拟数据表的形式存储于 LocalStorage 中 使用数据库的思想，构建3张表。 cateJson 分类 childCateJson 子分类 taskJson 任务 分类表 cate ---------------------- id* | name | child(FK) ---------------------- 子分类表 childCate -------------------------------- id* | pid(FK) | name | child(FK) -------------------------------- 任务表 task ---------------------------------------------- id* | pid(FK) | finish | name | date | content ---------------------------------------------- 使用 Sass 重构了 CSS 代码 使用分块、继承等方式，使得代码更加清晰明了。 响应式布局 针对手机端细节做了很多调整，更符合手机上的视觉交互习惯。 加入页面切换效果 使用 translate3d()，纯 CSS3 切换动画效果。 处理了 XSS 防护 对可能造成破坏的字符进行转码。 性能优化 使用 CDN 处理静态资源 fontAwesome，压缩静态资源等 模块化 使用 requireJS 模块化 JavaScript 代码。重构 JavaScript 代码。优化之前写的耦合性高的绑定事件，重新绑定事件，降低耦合性。期间根据具体需求重写了事件代理的代码。 前端工程化 使用 gulp，自动编译 Sass，压缩 CSS 和 JavaScript 代码。并且配置了自动流程。 其他-webkit-tap-highlight-color 属性感谢 fiona 指出。 safari移动端点击的时候会闪一下加上 -webkit-tap-highlight-color: transparent; 就不会闪了。 参考： -webkit-tap-highlight-color css88 -webkit-tap-highlight-color 属性 textarea 标签 disabled 颜色 为什么用 disabled 属性？ 因为我发现仅仅使用 readonly 属性，在 IE 下是显示光标的。于是使用 disabled。 出现的问题 各家浏览器对于 disabled 属性有自己的样式设定，比如 IE 下是灰色的。苹果设备下也是。改变这些样式的方法也不是统一的。如果要兼容 Safari 必须加上 123background: #fff;-webkit-text-fill-color: rgba(0, 0, 0, 1);-webkit-opacity: 1; 于是最终代码如下： 123456textarea:disabled &#123; color:#000; background: #fff; -webkit-text-fill-color: rgba(0, 0, 0, 1); -webkit-opacity: 1;&#125; 参考：Disabled input text color 中的评论","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript HTML CSS Sass 移动端 XSS AMD requireJS CommonJS 性能优化 WebApp","slug":"JavaScript-HTML-CSS-Sass-移动端-XSS-AMD-requireJS-CommonJS-性能优化-WebApp","permalink":"https://qccs.github.io/tags/JavaScript-HTML-CSS-Sass-移动端-XSS-AMD-requireJS-CommonJS-性能优化-WebApp/"}]},{"title":"JavaScript 面向对象","slug":"z/2015-06-15-JavaScript-Object-Oriented","date":"2015-06-15T06:06:05.000Z","updated":"2019-04-14T09:29:00.590Z","comments":true,"path":"2015/06/15/z/2015-06-15-JavaScript-Object-Oriented/","link":"","permalink":"https://qccs.github.io/2015/06/15/z/2015-06-15-JavaScript-Object-Oriented/","excerpt":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 面向对象笔记。 概念 面向对象程序设计（Object-oriented programming，OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 ——维基百科 一般面向对象包含：继承，封装，多态，抽象","text":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 面向对象笔记。 概念 面向对象程序设计（Object-oriented programming，OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 ——维基百科 一般面向对象包含：继承，封装，多态，抽象 基于原型的继承function Foo() { this.y = 2; } console.log(typeof Foo.prototype); //object Foo.prototype.x = 1; var obj3 = new Foo(); console.log(obj3.y); //2 console.log(obj3.x); //1 创建函数 Foo 的时候，就会有一个内置的 Foo.prototype 属性，并且这个属性是对象。 在使用 new Foo(); 创建对象实例时。this 会指向一个对象，并且这个对象的原型会指向 Foo.prototype 属性。this.y = 2 给这个对象赋值，并把这个对象返回。把这个对象赋值给 obj3。 y 是 obj3 上的，x 是 obj3 的原型 Foo.prototype 上的。 prototype 属性与原型prototype 是函数对象上预设的对象属性。 原型是对象上的原型，通常是构造器的 prototype 属性。 例function Person(name, age) { this.name = name; this.age = age; } Person.prototype.LEGS_NUM = 2; Person.prototype.ARMS_NUM = 2; Person.prototype.hi = function() { console.log(&apos;Hi, my name is &apos; + this.name + &quot;. I&apos;m &quot; + this.age + &apos; years old now&apos;); }; Person.prototype.walking = function() { console.log(this.name + &apos; is walking...&apos;); }; function Student(name, age, className) { Person.call(this, name, age); //使 Person 中的 this 指向 Student this.className = className; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.hi = function() { console.log(&apos;Hi, my name is &apos; + this.name + &quot;. I&apos;m &quot; + this.age + &apos; years old now, and from &apos; + this.className + &quot;.&quot;); }; Student.prototype.learn = function(subject) { console.log(this.name + &apos; is learning &apos; + subject + &apos; at &apos; + this.className + &apos;.&apos;); } //test var gao = new Student(&apos;Gao&apos;, &apos;24&apos;, &apos;Class 3123&apos;); console.log(gao); // 这个对象的具体内容见下图 gao.hi(); //Hi, my name is Gao. I&apos;m 24 years old now, and from Class 3123. gao.LEGS_NUM; //2 gao.walking(); //Gao is walking... gao.learn(&apos;JavaScript&apos;); //Gao is learning JavaScript at Class 3123. Object.create(arg) 创建一个空对象，并且这个对象的原型指向参数 arg。 Student.prototype.constructor = Student 为了保证一致性，否则 constructor 指向 Person。 原型链gao 对象的原型链： 下面通过图形展示原型链： Object.create(null) &amp; .bind(null)这两种算是特例。 Object.create(null) 和 .bind(null) 这两种方式创建出来的对象是没有 prototype 属性的，为 undefined。 prototype 属性改变 prototypeJavaScript 中的 prototype 是对象，在运行的时候可以修改。 给 prototype 添加或删除一些属性，是会影响到已经创建好的实例对象的。 但是，直接修改 prototype 属性，是不会影响到已经创建好的实例对象的。但是会影响到新的实例对象。如下代码： // 上接上面的代码 // 给 prototype 添加或删除一些属性 Student.prototype.x = 101; console.log(gao.x); //101 // 直接修改 prototype 属性 Student.prototype = { y: 2 }; // 不会影响到已创建好的实例对象 console.log(gao.x); //101 console.log(gao.y); //undefined // 会影响到新创建的实例对象 var ying = new Student(&apos;Ying&apos;, 24, &apos;UI&apos;); console.log(ying.x); //undefined console.log(ying.y); //2 内置构造器的 prototype 属性修改内置构造器的 prototype 属性后，在实例化这个对象后，枚举其属性时，会把修改的内置构造器的 prototype 属性也枚举出来，有时候这是要避免的。可用 defineProperty 方法解决。如下代码： Object.prototype.x = 1; var obj = {}; console.log(obj.x); //1 console.log(obj); for (var k in obj) { console.log(&apos;result---&gt;&apos; + k); } // result---&gt;x 使用 defineProperty 后： Object.defineProperty(Object.prototype, &apos;x&apos;, { writable: true, value: 1 }); var obj = {}; console.log(obj.x);//1 console.log(obj); for (var k in obj) { console.log(&apos;result---&gt;&apos; + k); } // nothing output here 其实也可以这样枚举，使用 hasOwnProperty 方法： for (var key in obj) { if (obj.hasOwnProperty(key)) { console.log(&quot;result---&gt;&quot; + key); } } 创建对象-new/原型链 instanceofconsole.log([1, 2] instanceof Array); //true console.log([1, 2] instanceof Object); //true console.log(new Object() instanceof Array); //false 左边要求是对象，右边要求是构造器或函数。它会判断：右边的构造器中的 prototype 属性是否出现在左边的对象的原型链上。 注意：不同的 window 或 iframe 间的对象类型检测不能使用 instanceof！ 实现继承的方式function Person() {} function Student() {} Student.prototype = Person.prototype; //1 Student.prototype = new Person(); //2 Student.prototype = Object.create(Person.prototype); //3 Student.prototype.constructor = Student; 注释中： 1 是错误的。如果改变了 Student 就会改变 Person 2 可以实现继承，但是其调用了构造函数，若父类构造函数中有形参，那么传值就会比较奇怪。 3 是最好的方法。创建了一个空对象，并且对象的原型指向参数 Person.prototype。这样便实现了继承。同时原型链写，不向上查找。但是 Object.create 是ES5 中的方法，所以可以使用下列代码做兼容： if (!Object.create) { Object.create = function(proto) { function F() {} F.prototype = proto; return new F; }; } 模拟重载function Person() { var args = arguments; if (typeof args[0] === &apos;object&apos; &amp;&amp; args[0]) { if (args[0].name) { this.name = args[0].name; } if(args[0].age){ this.age = args[0].age; } } else { if (args[0]) { this.name = args[0]; } if (args[1]) { this.age = args[1]; } } } //重写 toString 方法 Person.prototype.toString = function() { console.log(&apos;name=&apos;+this.name+&apos;, age=&apos;+this.age); }; var gao = new Person({name:&apos;Gao&apos;,age:24}); gao.toString(); // name=Gao, age=24 var ying = new Person(&apos;Ying&apos;,25); ying.toString(); // name=Ying, age=25 对参数进行判断，模拟实现重载。 调用子类方法function Person(name) { this.name = name; } function Student(name, className) { this.className = className; Person.call(this, name); // 调用基类的构造器 } var gao = new Student(&apos;Gao&apos;, &apos;3123&apos;); console.log(gao); // Student {className: &quot;3123&quot;, name: &quot;Gao&quot;} Person.prototype.init = function() {}; Student.prototype.init = function() { // do sth... Person.prototype.init.apply(this, arguments); // 同时也想调用父类被覆盖的方法 }; 主要是两种：调用父类的构造器，调用原型链上父类被覆盖的方法。 链式调用function ClassManager() {} ClassManager.prototype.addClass = function(str) { console.log(&apos;Class: &apos; + str + &apos; added&apos;); return this; }; var manager = new ClassManager(); manager.addClass(&apos;classA&apos;).addClass(&apos;classB&apos;).addClass(&apos;classC&apos;); // Class: classA added // Class: classB added // Class: classC added 重点在于 return this。返回这个 ClassManager 的实例。这样这个实例又可以继续调用方法。 抽象类在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用。 function DetectorBase() { throw new Error(&apos;Abstract class can not be invoked directly!&apos;); } DetectorBase.detect = function() { console.log(&apos;Detection starting...&apos;); } DetectorBase.stop = function() { console.log(&apos;Detection stopped.&apos;); }; DetectorBase.init = function() { throw new Error(&apos;Error&apos;); } var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly! function LinkDetector() {} LinkDetector.prototype = Object.create(DetectorBase.prototype); LinkDetector.prototype.constructor = LinkDetector; var l = new LinkDetector(); console.log(l); //LinkDetector {}__proto__: LinkDetector l.detect(); //Uncaught TypeError: l.detect is not a function l.init(); //Uncaught TypeError: l.init is not a function var d = new DetectorBase(); 是不能实例化的，会报错 l.detect(); 但是这个为什么报错我就不知道了。 已经在原课程下提问了，期待老师的讲解。 抽象类中子类为什么不能调用父类的非抽象方法？ 问题已经解决了，应该是老师当时的课件写错了，应该再基类中将这两个方法写在其原型 prototype 上。如下： function DetectorBase() { throw new Error(&apos;Abstract class can not be invoked directly!&apos;); } DetectorBase.prototype.detect = function() { console.log(&apos;Detection starting...&apos;); }; DetectorBase.prototype.stop = function() { console.log(&apos;Detection stopped.&apos;); }; DetectorBase.prototype.init = function() { throw new Error(&apos;Error&apos;); }; // var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly! function LinkDetector() {} LinkDetector.prototype = Object.create(DetectorBase.prototype); LinkDetector.prototype.constructor = LinkDetector; var l = new LinkDetector(); console.log(l); //LinkDetector {}__proto__: LinkDetector l.detect(); //Detection starting... l.init(); //Uncaught Error: Error 模块化var moduleA; moduleA = function() { var prop = 1; function func() {} return { func: func, prop: prop }; }(); // 立即执行匿名函数 prop，func 不会被泄露到全局作用域。 或者另一种写法，使用 new moduleA = new function() { var prop = 1; function func() {} this.func = func; this.prop = prop; } 更复杂的可以使用 Sea.js Kissy Require.js 模块化工具。 最后补充一点设计模式相关的资料，我还没有来得及看的： 学用 JavaScript 设计模式 常用的Javascript设计模式 JavaScript设计模式深入分析","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 面向对象 慕课网 ife","slug":"JavaScript-面向对象-慕课网-ife","permalink":"https://qccs.github.io/tags/JavaScript-面向对象-慕课网-ife/"}]},{"title":"JavaScript 中的闭包","slug":"z/2015-06-14-JavaScript-closure","date":"2015-06-14T06:06:05.000Z","updated":"2019-04-14T09:29:00.583Z","comments":true,"path":"2015/06/14/z/2015-06-14-JavaScript-closure/","link":"","permalink":"https://qccs.github.io/2015/06/14/z/2015-06-14-JavaScript-closure/","excerpt":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 中的闭包笔记。 闭包的例子function outer() { var localVal = 30; return localVal; } console.log(outer()); //30 function outer2() { var localVal = 30; return function() { return localVal; }; } var func = outer2(); console.log(func()); //30 对于第一个普通的函数，在执行过之后，它的局部变量就可以被释放。 对于第二个函数，localVal 是不能被释放的。因为调用 outer2() 后，返回的是匿名函数，匿名函数可以访问外部的 outer2() 中的局部变量，并返回了这个局部变量 localVal。当 outer2() 赋值给 func 后，再次调用 func()，仍能访问到局部变量 localVal。这种情况就是闭包。","text":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 中的闭包笔记。 闭包的例子function outer() { var localVal = 30; return localVal; } console.log(outer()); //30 function outer2() { var localVal = 30; return function() { return localVal; }; } var func = outer2(); console.log(func()); //30 对于第一个普通的函数，在执行过之后，它的局部变量就可以被释放。 对于第二个函数，localVal 是不能被释放的。因为调用 outer2() 后，返回的是匿名函数，匿名函数可以访问外部的 outer2() 中的局部变量，并返回了这个局部变量 localVal。当 outer2() 赋值给 func 后，再次调用 func()，仍能访问到局部变量 localVal。这种情况就是闭包。 应用 所谓闭包就是：子函数可以使用父函数中的局部变量。 ! function() { var localData = &quot;localData here&quot;; document.addEventListener(&apos;click&apos;, function() { console.log(localData); //这里访问外部数据 }); }(); ! function() { var localData = &quot;localData here&quot;; var url = &quot;http://www.baidu.com/&quot;; $.ajax({ url: url, success: function() { // do sth... console.log(localData); //这里访问外部数据 } }); }() 常见错误之循环闭包比如我们想循环绑定点击事件 document.body.innerHTML = &quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; for (var i = 1; i &lt; 4; i++) { document.getElementById(&apos;div&apos; + i). addEventListener(&apos;click&apos;, function() { alert(i); // all are 4! }); } 上面的代码，我们点击任何一个 div，弹出的都是 4 这是因为，for 循环中的 i 是一个全局变量。这里内函数的点击事件，访问到的是循环后的 i 值，所以是 4 document.body.innerHTML = &quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; for (var i = 1; i &lt; 4; i++) { ! function(i) { document.getElementById(&apos;div&apos; + i). addEventListener(&apos;click&apos;, function() { alert(i); // 1, 2, 3 }); }(i); } 这里使用了立即执行函数，并给匿名函数赋值 i，这样点击事件每一次就会访问到相应的 i。 封装(function() { var _userId = 9527; var _typeId = &quot;item&quot;; var exp = {}; function converter(userId) { return +userId; } exp.getUserId = function() { return converter(_userId); }; exp.getTypeId = function() { return _typeId; }; window.a = exp; })(); console.log(a.getUserId()); //9527 console.log(a.getTypeId()); //item console.log(a._userId); //undefined console.log(a._typeId); //undefined console.log(converter); //Uncaught ReferenceError: converter is not defined 上面的代码通过闭包实现了一个封装。 总结 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。 from 维基百科 闭包的优点 灵活和方便 封装 缺点 空间浪费 内存泄露 性能消耗","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 闭包 慕课网 ife","slug":"JavaScript-闭包-慕课网-ife","permalink":"https://qccs.github.io/tags/JavaScript-闭包-慕课网-ife/"}]},{"title":"JavaScript 中的 this","slug":"z/2015-06-12-JavaScript-this","date":"2015-06-12T06:06:05.000Z","updated":"2019-04-14T09:29:00.603Z","comments":true,"path":"2015/06/12/z/2015-06-12-JavaScript-this/","link":"","permalink":"https://qccs.github.io/2015/06/12/z/2015-06-12-JavaScript-this/","excerpt":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 中的 this笔记。 全局的 this全局 this 一般指向全局对象，浏览器中的全局对象就是 window。 例如：","text":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 中的 this笔记。 全局的 this全局 this 一般指向全局对象，浏览器中的全局对象就是 window。 例如： 12345console.log(this.document === document); //trueconsole.log(this === window); //truethis.a = 91;console.log(window.a); //91 一般函数的 this1234function f1 () &#123; return this;&#125;console.log(f1() === window);//true, global object 可以看到一般函数的 this 也指向 window，在 nodeJS 中为 global object 12345function f2 () &#123; \"use strict\";//使用严格模式 return this;&#125;console.log(f1() === undefined);//true 严格模式中，函数的 this 为 undefined 作为对象方法的函数的 this1234567var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // 37 上述代码通过字面量创建对象 o。 f 为对象 o 的方法。这个方法的 this 指向这个对象，在这里即对象 o。 123456789var o = &#123; prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // 37 上面的代码，创建了对象 o，但是没有给对象 o，添加方法。而是通过 o.f = independent 临时添加了方法属性。这样这个方法中的 this 同样也指向这个对象 o。 对象原型链上的 this123456789var o = &#123; f: function() &#123; return this.a + this.b; &#125;&#125;;var p = Object.create(o);p.a = 1;p.b = 2;console.log(p.f()); //3 通过 var p = Object.create(o) 创建的对象，p 是基于原型 o 创建出的对象。 p 的原型是 o，调用 f() 的时候是调用了 o 上的方法 f()，这里面的 this 是可以指向当前对象的，即对象 p。 get/set 方法与 this12345678910111213141516function modulus() &#123; return Math.sqrt(this.re * this.re + this.im * this.im);&#125;var o = &#123; re: 1, im: -1, get phase() &#123; return Math.atan2(this.im, this.re); &#125;&#125;;Object.defineProperty(o, 'modulus', &#123; get: modulus, enumerable: true, configurable: true&#125;);console.log(o.phase, o.modulus); // -0.78 1.4142 get/set 方法中的 this 也会指向 get/set 方法所在的对象的。 构造器中的 this12345function MyClass() &#123; this.a = 25;&#125;var o = new MyClass();console.log(o.a); //25 new MyClass() 的时候，MyClass()中的 this 会指向一个空对象，这个对象的原型会指向 MyClass.prototype。MyClass()没有返回值或者返回为基本类型时，默认将 this 返回。 123456789function C2() &#123; this.a = 26; return &#123; a: 24 &#125;;&#125;o = new C2();console.log(o.a); //24 因为返回了对象，将这个对象作为返回值 call/apply 方法与 this12345678910111213function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123; a: 1, b: 3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34function bar() &#123; console.log(Object.prototype.toString.call(this));&#125;bar.call(7); // \"[object Number]\" bind 方法与 this12345678910111213function f() &#123; return this.a;&#125;var g = f.bind(&#123; a: \"test\"&#125;);console.log(g()); // testvar o = &#123; a: 37, f: f, g: g&#125;;console.log(o.f(), o.g()); // 37, test 绑定之后再调用时，仍然会按绑定时的内容走，所以 o.g() 结果是 test","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 慕课网 this ife","slug":"JavaScript-慕课网-this-ife","permalink":"https://qccs.github.io/tags/JavaScript-慕课网-this-ife/"}]},{"title":"JavaScript 函数","slug":"z/2015-06-11-JavaScript-function","date":"2015-06-11T06:06:05.000Z","updated":"2019-04-13T07:32:25.000Z","comments":true,"path":"2015/06/11/z/2015-06-11-JavaScript-function/","link":"","permalink":"https://qccs.github.io/2015/06/11/z/2015-06-11-JavaScript-function/","excerpt":"","text":"content{:toc} 本文为慕课网 JavaScript深入浅出 JavaScript 函数笔记。 概念函数是一块JavaScript代码，被定义一次，但可执行和调用多次。 JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递。 所以我们也常叫JS中的函数为函数对象。 例如： 123456789function foo(x, y) &#123; if (typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return x + y; &#125; else &#123; return 0; &#125;&#125;foo(1, 2); // 3 一般由3部分组成： 函数名 参数列表 函数体 调用方式 直接调用 1foo(); 对象方法 1o.method(); 构造器 1new Foo(); call/apply/bind 1func.call(o); 函数声明与函数表达式函数声明就是对函数进行普通的声明 123function add(a, b) &#123; return a + b;&#125; 函数表达式 将函数赋值给变量 1234//function variablevar add = function(a, b) &#123; // body...&#125;; 立即执行函数 把匿名函数用括号括起来，再直接调用。 1234// IEF(Immediately Executed Function)(function() &#123; // body...&#125;)(); 函数对象作为返回值 123return function() &#123; // body...&#125;; 命名式函数表达式 1234//NFE(Named Function Expression)var add = function foo(a, b) &#123; // body...&#125;; 这里大家肯定会好奇，这个函数怎么调用？到底用哪个名字呢？ 做一个测试： 1234var func = function nfe() &#123;&#125;;console.log(func === nfe);// 在 IE6~8，得到 false// 在 IE9+ 及现代浏览器中 Uncaught ReferenceError: nfe is not defined 那么命名函数表达式有什么使用场景呢？ 一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。 或者在递归时，使用名字调用自己。 但是这两种用法都不常见。 变量 &amp; 函数的声明前置举两个例子 例1，函数声明： 123456var num = add(1,2);console.log(num);function add(a, b) &#123; return a + b;&#125; 例2，函数表达式： 123456var num = add(1, 2);console.log(num);var add = function(a, b) &#123; return a + b;&#125;; 例1中得到的结果是 3，而例2中是 Uncaught TypeError: add is not a function。 因为函数和变量在声明的时候，会被前置到当前作用域的顶端。例1将函数声明 function add(a, b) 前置到作用域前端，例2将声明 var add 前置到其作用域的前端了，并没有赋值。赋值的过程是在函数执行到响应位置的时候才进行的。 Function 构造器除了函数声明、函数表达式。还有一种创建函数对象的方式，是使用函数构造器。 12345var func = new Function('a','b','console.log(a+b);');func(1,2);//3var func2 = Function('a','b','console.log(a+b);');func2(1,2);//3 Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。 还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。 对比 函数属性 &amp; arguments函数属性 &amp; arguments1234567891011121314function foo(x, y, z) &#123; arguments.length; // 2 arguments[0]; // 1 arguments[0] = 10; x; // change to 10 arguments[2] = 100; z; // still undefined!!! arguments.callee === foo; // true&#125;foo(1, 2);foo.length; // 3foo.name; //\"foo\" foo.name 函数名 foo.length 形参个数 arguments.length 实参个数 未传参数时，arguments[i] 相应的位置仍然是 undefined。 严格模式下，代码中的改变实参失效。即 x 仍为 1。同时 callee 属性失效。 关于 callee callee 属性的初始值就是正被执行的 Function 对象。 callee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或者保证函数的封装性，例如下边示例的递归计算1到n的自然数之和。而该属性仅当相关函数正在执行时才可用。还有需要注意的是callee拥有length属性，这个属性有时用于验证还是比较好的。 arguments.length是实参长度，arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。 apply/call 方法（浏览器）12345678function foo(x, y) &#123; console.log(x, y, this);&#125;foo.call(100, 1, 2); //1 2 Number &#123;[[PrimitiveValue]]: 100&#125;foo.apply(true, [3, 4]); //3 4 Boolean &#123;[[PrimitiveValue]]: true&#125;foo.apply(null); //undefined undefined Windowfoo.apply(undefined); //undefined undefined Window call/apply 的作用：调用一个对象的一个方法，以另一个对象替换当前对象(其实就是更改对象的内部指针，即改变对象的this指向的内容)。 call/apply 的第一个参数为对象，即使不是对象，也会被包装为对象。 call 为扁平化传参，apply 后面的参数为数组 传入 null/undefined 时，实际为 Window 对象 在严格模式下：上述代码最后两行分别输出 null, undefined bind 方法bind 是 ES5 中提出的方法，所以浏览器支持为 IE9+ 及现代浏览器。 123456789101112131415this.x = 9;var module = &#123; x: 81, getX: function() &#123; return console.log(this.x); &#125;&#125;;module.getX(); //81var getX = module.getX;getX(); //9var boundGetX = getX.bind(module);boundGetX(); //81 bind 主要用于改变函数中的 this module.getX(); 直接通过对象调用自己的方法，结果是 81 var getX = module.getX; 将这个方法赋值给一个全局变量，这时 this 指向了 Window，所以结果为 9 var boundGetX = getX.bind(module); 使用 bind 绑定了自己的对象，这样 this 仍然指向 module 对象，所以结果为 81 bind 与 curryingbind 可以使函数柯里化，那么什么是柯里化？ 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。 123456789function add(a, b, c) &#123; return a + b + c;&#125;var func = add.bind(undefined, 100);func(1, 2); //103var func2 = func.bind(undefined, 200);func2(10); //310 add 函数拥有 3 个参数。我们想先传入一个参数，再去传其他参数。 var func = add.bind(undefined, 100); add 函数对象调用 bind 方法，由于不需要将 this 指向原来的 add 函数对象，所以第一个参数写为 undefined 或 null。第二个参数 100 传给了 add 函数中的形参 a，并赋值给一个新的函数对象 func。 这时，func(1, 2) 即相当于传入后两个参数，所以结果为 103。 同理，基于 func 可以创造一个函数 func2。它只用传最后一个参数。 bind 与 new12345678910111213function foo() &#123; this.b = 100; return this.a;&#125;console.log(foo()); //undefinedvar func = foo.bind(&#123; a: 1&#125;);console.log(func()); //1console.log(new func()); //foo &#123;b: 100&#125; 对于使用了 new func() 这种方式创建对象，其返回值为一个对象。 而原函数 foo 的返回值不是对象，所以会直接忽视这个 return 方法。而是变为 return this;。并且 this 会被初始化为一个空对象，这个空对象的原型指向 foo.prototype。所以后面的 bind 是不起作用的。 这里面这个 this 对象包含一个属性 b = 100。所以返回的是对象 {b: 100}。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 函数 慕课网 ife","slug":"JavaScript-函数-慕课网-ife","permalink":"https://qccs.github.io/tags/JavaScript-函数-慕课网-ife/"}]},{"title":"JavaScript 作用域和作用域链","slug":"z/2015-05-20-scope","date":"2015-05-20T06:06:05.000Z","updated":"2019-04-14T09:29:00.596Z","comments":true,"path":"2015/05/20/z/2015-05-20-scope/","link":"","permalink":"https://qccs.github.io/2015/05/20/z/2015-05-20-scope/","excerpt":"content{:toc} JavaScript 作用域作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。","text":"content{:toc} JavaScript 作用域作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域(Global Scope)在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下 3 种情形拥有全局作用域。 最外层函数和在最外层函数外面定义的变量拥有全局作用域 123456789101112var outVariable = \"我是最外层变量\"; //最外层变量function outFun() &#123; //最外层函数 var inVariable = \"内层变量\"; function innerFun() &#123; //内层函数 console.log(inVariable); &#125; innerFun();&#125;console.log(outVariable); //我是最外层变量outFun(); //内层变量console.log(inVariable); //inVariable is not definedinnerFun(); //innerFun is not defined 所有末定义直接赋值的变量自动声明为拥有全局作用域 1234567function outFun2() &#123; variable = \"未定义直接赋值的变量\"; var inVariable2 = \"内层变量2\";&#125;outFun2();//要先执行这个函数，否则根本不知道里面是啥console.log(variable); //未定义直接赋值的变量console.log(inVariable2); //inVariable2 is not defined 所有window对象的属性拥有全局作用域 window对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等。 局部作用域(Local Scope)和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。 如 1. 中的变量 inVariable 和函数 innerFun 都只拥有局部作用域。 再补充几个例子 全局作用域，函数作用域，eval作用域 123456789var a = 10; // 全局(function() &#123; var b = 20;// 函数&#125;)();console.log(a); // 10console.log(b); // error, b in not definedeval(\"var a = 1;\"); // eval JavaScript 中没有块作用域 1234567for (var item in &#123; a: 1, b: 2&#125;) &#123; console.log(item);&#125;console.log(item); // item still in scope 作用域链(Scope Chain)在 JavaScript 中，函数也是对象，实际上，JavaScript 里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是 [[Scope]]，由 ECMA-262 标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 在函数创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。 函数执行时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。 这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端。 当运行期上下文被销毁，活动对象也随之销毁。 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 例子举一个作用域链的例子。 123456789var outVariable = \"我是最外层变量\"; //最外层变量function outFun() &#123; //最外层函数 var inVariable = \"内层变量\"; function innerFun() &#123; //内层函数 console.log(inVariable); var tempVariable = inVariable; &#125; innerFun();&#125; 对最开始的代码稍加修改 其作用域链为： 123456window├──outVariable└──outFun() ├──inVariable └──innerFun() └──tempVariable 对于 innerFun()，其作用域链包含 3 个对象：innerFun() 自己的变量对象、outFun()的变量对象、全局变量对象。 特例-构造器创建的函数123456function outer() &#123; var i = 1; var func = new Function(\"console.log(typeof i);\"); func(); // undefined&#125;outer(); 通过构造器创建的函数是访问不到外层的局部变量的。 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。 try-catch 语句中的 catch 块 with 语句 对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 代码优化从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。 VO &amp; AO变量初始化阶段 JS解释器如何找到我们定义的函数和变量？ 变量对象 (Variable Object, 缩写为VO) 是一个抽象概念中的“对象”，它用于存储执行上下文中的： 变量 函数声明 函数参数 VO按照如下顺序填充: 函数参数 (若未传入，初始化该参数值为undefined) 函数声明 (若发生命名冲突，会覆盖) 变量声明 (初始化变量值为 undefined，若发生命名冲突，会忽略。) 12345678910111213141516171819202122232425function foo(x, y, z) &#123; function x() &#123;&#125;; console.log(x);&#125;foo(100); // funtion x()function foo2(x, y, z) &#123; var x = 50; console.log(x);&#125;foo2(110); // 50function foo3() &#123; function x() &#123;&#125;; var x = 100; console.log(x);&#125;foo3(); // 100function foo4() &#123; function x() &#123;&#125;; var x; console.log(x);&#125;foo4(); // funtion x() 注：函数表达式不会影响 VO 代码执行阶段给 VO 对象内的变量赋值。 VO 变为 AO （活动对象 activation object）。 例1234567891011121314151617alert(x); // functionvar x = 10;alert(x); // 10x = 20;function x() &#123;&#125;alert(x); // 20if (true) &#123; var a = 1;&#125; else &#123; var b = true;&#125;alert(a); // 1alert(b); // undefined 参考资料 鸟哥：Javascript作用域原理 理解 JavaScript 作用域和作用域链 JavaScript 深入浅出-慕课网","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 作用域 慕课网 ife","slug":"JavaScript-作用域-慕课网-ife","permalink":"https://qccs.github.io/tags/JavaScript-作用域-慕课网-ife/"}]},{"title":"前端的一些资料和工具","slug":"z/2015-05-18-front-end-tools","date":"2015-05-18T06:06:05.000Z","updated":"2019-04-14T09:29:00.607Z","comments":true,"path":"2015/05/18/z/2015-05-18-front-end-tools/","link":"","permalink":"https://qccs.github.io/2015/05/18/z/2015-05-18-front-end-tools/","excerpt":"content{:toc} 这里记录一些我用到的或者见到的比较好用方便的前端开发相关的工具吧。 色彩与图标CSS滤镜 Filter Effects 界面： 有各种各样的滤镜效果，可以直接调节参数观察变化。 值得一提的是，这个网站还有很多其他 css 生成器。 比如：Border Image, Border Radius, Box Shadow, Filter Effects, Multi-Column, Outline Border, Overflow(x,y), RGBa, Text Rotate, Text Shadow, Textarea Resize, Transform 可以访问这里去使用这些 css 生成器：CSS Generators","text":"content{:toc} 这里记录一些我用到的或者见到的比较好用方便的前端开发相关的工具吧。 色彩与图标CSS滤镜 Filter Effects 界面： 有各种各样的滤镜效果，可以直接调节参数观察变化。 值得一提的是，这个网站还有很多其他 css 生成器。 比如：Border Image, Border Radius, Box Shadow, Filter Effects, Multi-Column, Outline Border, Overflow(x,y), RGBa, Text Rotate, Text Shadow, Textarea Resize, Transform 可以访问这里去使用这些 css 生成器：CSS Generators 渐变CSS代码生成器 Ultimate CSS Gradient Generator 界面如下图： 目前 css 写渐变还很复杂，但是用了这个工具简直太方便了，直接生成 css 代码，还能兼容 ie。 QQ截图取色-16进制在按下 Ctrl+Shift+A 后，再按一下 Ctrl 就可以看到截图框下面的颜色代码变成16进制的代码了。 如下图： 普通截图： 按住 Ctrl： 可以看到第一幅图中的 51, 51, 51 变成了 #333333。 配色 nipponcolors 日本的一个配色网站。罗列了很多不饱和经典的颜色，当然，自己选配还是很重要的。 Adobe Color CC Adobe 出的在线配色工具，里面有些现成的配色方案还是很不错的。 paletton 提供了各种预览模式，可以在模板网站中预览，在色块中预览。 图标 easyicon 对中文的搜索支持很好。实际上它是先把中文翻译为英文再搜索的。 Font-Awesome 比上面介绍的那个好用的多，字体图标，不需要考虑像素大小，全部是矢量图。并且图标精美。如果不使用 BootStrap，单独添加图标的话，这一套图标在合适不过了。 iconfont.cn 阿里巴巴制作的图标库。 数据处理Json json editor 将json数据输入进去，会生成一个树形的结构，方便查看每个节点。 展示reveal.js reveal.js 在网页上展示 slides 幻灯片，太酷了。针对不会代码的人还有一个在线编辑器：http://slides.com 还有一个新手入门教程：Reveal.js Tutorial-Reveal.js for Beginners 本文不定期更新。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://qccs.github.io/categories/Tools/"}],"tags":[{"name":"tools CSS reveal 配色","slug":"tools-CSS-reveal-配色","permalink":"https://qccs.github.io/tags/tools-CSS-reveal-配色/"}]},{"title":"百度Web前端技术学院(2)-JavaScript 基础","slug":"z/2015-04-22-baidu-ife-2-javascript","date":"2015-04-22T11:06:05.000Z","updated":"2019-04-14T09:29:00.633Z","comments":true,"path":"2015/04/22/z/2015-04-22-baidu-ife-2-javascript/","link":"","permalink":"https://qccs.github.io/2015/04/22/z/2015-04-22-baidu-ife-2-javascript/","excerpt":"content{:toc} 百度前端学院的第二次任务笔记，JavaScript 基础。主要有JavaScript的定义，数据类型，对象，数组，字符串，正则表达式，DOM，事件，BOM，Ajax 等知识。 任务掌握JavaScript基础知识，能够使用JavaScript编写一些复杂度不大的交互功能。","text":"content{:toc} 百度前端学院的第二次任务笔记，JavaScript 基础。主要有JavaScript的定义，数据类型，对象，数组，字符串，正则表达式，DOM，事件，BOM，Ajax 等知识。 任务掌握JavaScript基础知识，能够使用JavaScript编写一些复杂度不大的交互功能。任务： JavaScript基础 做完任务一的时候深深地感觉到自己的基础非常的薄弱，在这里再次感谢一下百度前端技术学院，做任务的时候深刻理解了自己平时掌握不牢固的内容，比如浮动、BFC、等高布局等。继续加油吧！ 像上一篇文章一样，写些东西记录一下。 第一个页面交互按照任务中的代码，在IE8下提示：对象不支持“addEventListener”属性或方法我猜是IE8浏览器没有这个方法吧。 参考资料：JavaScript 指南-MDN 了解JavaScript是什么来自MDN的解释 JavaScript 是一种跨平台，面向对象的脚本语言。作为一种小巧且轻量级的语言，JavaScript 无意于独立运行，而是被设计为可以轻易嵌入到其它的产品和应用中，比如 Web 浏览器。在宿主环境中，JavaScript 可以被连接到环境中的对象之上，以提供对其的编程控制。 核心的 JavaScript 中包含有一组核心的对象，包括 Array，Date 和 Math，以及一组核心的语言要素，包括操作符，控制结构和语句。出于多种目的，可以通过为其增补附加的对象，对核心 JavaScript 加以扩展；例如： 客户端 JavaScript 提供了用于控制浏览器（Navigator 或者其它浏览器）以及其中的文档对象模型（DOM）的对象，从而扩展了核心 JavaScript。例如，客户端扩展允许应用程序在 HTML 的表单中加入元素，以便响应用户事件，比如鼠标点击，表单输入和页面导航。 服务器端 JavaScript 提供了服务于在服务器上运行 JavaScript 的对象，从而扩展了核心 JavaScript。例如，服务器端扩展可以允许应用程序访问关系型数据库，在应用程序的不同调用间提供信息的连续性，甚至于处理服务器之上的文件。 借由 JavaScript 的 LiveConnect 功能，您可以让 Java 和 JavaScript 间实现通讯。从 JavaScript 中，您可以创建 Java 对象并访问它们的公共方法和域。从 Java 中，也可以访问 JavaScript 的对象，属性和方法。 Netscape 发明了 JavaScript 并将 JavaScript 首先用于 Netscape 浏览器中。 如何在 HTML 页面加载 JavaScript 代码使用 &lt;script&gt; 标签在 HTML 文件中添加 JavaScript 代码。 我们可以将 JavaScript 代码放在 html 文件中任何位置，但是我们一般放在网页的 head 或者 body 部分。 放在 &lt;head&gt; 部分最常用的方式是在页面中head部分放置 &lt;script&gt; 元素，浏览器解析 head 部分就会执行这个代码，然后才解析页面的其余部分。 放在 &lt;body&gt; 部分JavaScript 代码在网页读取到该语句的时候就会执行。 注意: javascript 作为一种脚本语言可以放在 html 页面中任何位置，但是浏览器解释 html 时是按先后顺序的，所以前面的 script 就先被执行。比如进行页面显示初始化的 js 必须放在 head 里面，因为初始化都要求提前进行（如给页面 body 设置 css 等）；而如果是通过事件调用执行的 function 那么对位置没什么要求的。 为什么把 &lt;script&gt; 放在 &lt;/body&gt; 前虽然理论上放在哪里都是可以的，但是对于前端页面优化来讲，还是放在底部是最佳的，因为如果JS执行出现错误了，最起码页面中的元素还能加载出来，因为DOM文档是从上往下的顺序执行的。 如果你还不了解DOM的加载顺序，请阅读jQuery中ready与load事件的区别。 下面是重点 按照HTML5标准中的HTML语法规则，如果在 &lt;/body&gt; 后再出现 &lt;script&gt; 或任何元素的开始标签，都是parse error，浏览器会忽略之前的 &lt;/body&gt; ，即视作仍旧在body内。所以实际效果和写在 &lt;/body&gt; 之前是没有区别的。 总之，这种写法虽然也能work，但是并没有带来任何额外好处，实际上出现这样的写法很可能是误解了“将script放在页面最末端”的教条。所以还是不要这样写为好。 script在body闭合标签之后还是之前-知乎 body 和 html 标签均没有关闭 JavaScript 的性能优化：加载和执行 扩展阅读：JavaScript 的性能优化：加载和执行 脚本位置 由于脚本会阻塞页面其他资源的下载，因此推荐将所有 &lt;script&gt; 标签尽可能放到 &lt;body&gt; 标签的底部，以尽量减少对整个页面下载的影响。 组织脚本 由于每个 &lt;script&gt; 标签初始下载时都会阻塞页面渲染，所以减少页面包含的 &lt;script&gt; 标签数量有助于改善这一情况。这不仅针对外链脚本，内嵌脚本的数量同样也要限制。浏览器在解析 HTML 页面的过程中每遇到一个 &lt;script&gt; 标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。 无阻塞的脚本 减少 JavaScript 文件大小并限制 HTTP 请求数在功能丰富的 Web 应用或大型网站上并不总是可行。Web 应用的功能越丰富，所需要的 JavaScript 代码就越多，尽管下载单个较大的 JavaScript 文件只产生一次 HTTP 请求，却会锁死浏览器的一大段时间。为避免这种情况，需要通过一些特定的技术向页面中逐步加载 JavaScript 文件，这样做在某种程度上来说不会阻塞浏览器。 无阻塞脚本的秘诀在于，在页面加载完成后才加载 JavaScript 代码。这就意味着在 window 对象的 onload事件触发后再下载脚本。有多种方式可以实现这一效果。 延迟加载脚本 HTML 4 为 &lt;script&gt; 标签定义了一个扩展属性：defer。Defer 属性指明本元素所含的脚本不会修改 DOM，因此代码能安全地延迟执行。 带有 defer 属性的 &lt;script&gt; 标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到 &lt;script&gt; 标签时开始下载，但不会执行，直到 DOM 加载完成，即onload事件触发前才会被执行。当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。 对于如下代码： 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;title&gt;Script Defer Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" defer&gt; alert(\"defer\"); &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; alert(\"script\"); &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; alert(\"load\"); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在支持 defer 属性的浏览器上，弹出的顺序则是：”script”、”defer”、”load”。请注意，带有 defer 属性的 &lt;script&gt; 元素不是跟在第二个后面执行，而是在 onload 事件被触发前被调用。 引用的资料可能写的比较早，在 CanIUse 上查了一下 defer 发现大部分浏览器都是支持的。如下图： HTML 5 为 &lt;script&gt; 标签定义了一个新的扩展属性：async。它的作用和 defer 一样，能够异步地加载和执行脚本，不因为加载脚本而阻塞页面的加载。但是有一点需要注意，在有 async 的情况下，JavaScript 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 async 就很有可能出现错误。 IE8,9不支持 async 动态脚本元素 使用 XMLHttpRequest(XHR)对象 原文中的总结 减少 JavaScript 对性能的影响有以下几种方法： 将所有的 &lt;script&gt; 标签放到页面底部，也就是 &lt;/body&gt; 闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。 尽可能地合并脚本。页面中的 &lt;script&gt; 标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。 采用无阻塞下载 JavaScript 脚本的方法： 使用 &lt;script&gt; 标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）； 使用动态创建的 &lt;script&gt; 元素来下载并执行代码； 使用 XHR 对象下载 JavaScript 代码并注入页面中。 通过以上策略，可以在很大程度上提高那些需要使用大量 JavaScript 的 Web 网站和应用的实际性能。 JavaScript数据类型及语言基础数据类型概要最新的 ECMAScript 标准定义了 7 种数据类型: 6 种 原始类型: Boolean Null Undefined Number String Symbol (new in ECMAScript 6) 和 Object 一些要点 一个没有被赋值的变量会有个默认值 undefined null 与 undefined 的不同点： 1234typeof null // object (bug in ECMAScript, should be null)typeof undefined // undefinednull === undefined // falsenull == undefined // true 1typeof null 返回 object Number 数字类型，它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。 NaN与任何值都不相等，包括自身。应当使用 x != x 来判断，当且仅当 x 为 NaN 的时候，表达式的结果才为 true。相似的函数有 isNaN(), isFinite()。 数组直接量的语法允许有可选的结尾逗号，故 [,,] 只有两个元素而非三个。 实践判断各种数据类型的方法123456789// 判断arr是否为一个数组，返回一个bool值function isArray(arr) &#123; return typeof arr === \"object\" &amp;&amp; Object.prototype.toString.call(arr) === \"[object Array]\";&#125;// 判断fn是否为一个函数，返回一个bool值function isFunction(fn) &#123; return typeof fn === \"function\";&#125; 数组类型在 ECMAScript5 中，可以直接使用 Array.isArray() 来判断数组。 12Array.isArray([]); //trueArray.isArray(&#123;&#125;); //false 我看《JavaScript权威指南上》没有推荐使用 instanceof，因为可能会有多窗体(frame)存在。 这样每一个窗口都有一个自己的 JavaScript 环境，有自己的全局对象。并且每个全局对象都有自己的一组构造函数。因此一个窗体中的对象不可能是另外窗体中的构造函数的实例。 所以采用了上述我写的那样的代码 值类型和引用类型的区别 值类型 声明一个值类型变量，编译器会在栈上分配一个空间，这个空间对应着该值类型变量，空间里存储的就是该变量的值。存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 引用类型 引用类型的实例分配在堆上，新建一个引用类型实例，得到的变量值对应的是该实例的内存分配地址，这就像您的银行账号一样。存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。 在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。 如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。如下图所示： JavaScript中原始值包括：undefined，null，布尔值，数字和字符串。引用类型主要指对象（包括数组和函数）。 原始值是不可更改的。对象的值是可修改的。 原始值的比较是值的比较。对象的比较并非值的比较。对象的值都是引用，对象的比较均是引用的比较，当且仅当他们都引用同一个基对象时，他们才相等。 参考： ECMAScript 原始值和引用值 对象的读取、遍历方式参考：JavaScript 指南-使用对象 对象 在javascript中，一个对象可以是一个单独的拥有属性和类型的实体。我们拿它和一个杯子做下类比。一个杯子是一个对象(物体)，拥有属性。杯子有颜色，图案，重量，由什么材质构成等等。同样，javascript对象也有属性来定义它的特征。 属性 一个 javascript 对象有很多属性。一个对象的属性可以被解释成一个附加到对象上的变量。对象的属性和普通的 javascript 变量基本没什么区别，仅仅是属性属于某个对象。属性定义了对象的特征(译注：动态语言面向对象的鸭子类型)。你可以通过点符号来访问一个对象的属性。JavaScript 对象的属性也可以通过方括号访问。 枚举 你可以在 for...in 语句中使用方括号标记以枚举一个对象的所有属性。为了展示它如何工作，下面的函数当你将对象及其名称作为参数传入时，显示对象的属性： 12345678910111213141516171819function showProps(obj, objName) &#123; var result = \"\"; for (var i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; result += objName + \".\" + i + \" = \" + obj[i] + \"\\n\"; &#125; &#125; return result;&#125;var srcObj = &#123; a: 1, b: &#123; b1: [\"hello\", \"hi\"], b2: \"JavaScript\" &#125;&#125;;console.log(showProps(srcObj,'srcObj')); console: 12srcObj.a = 2srcObj.b = [object Object] 这里使用 hasOwnProperty() 是为了确保是自己的属性而非继承的属性。 可以如下写，跳过这个对象的方法： 12345678910111213function showPropsWithoutFun(obj, objName) &#123; var result = \"\"; for (var i in obj) &#123; if (!obj.hasOwnProperty(i)) &#123; //跳过继承属性 continue; &#125; if (typeof obj[i] === \"function\") &#123; //跳过这个对象的方法 continue; &#125; result += objName + \".\" + i + \"=\" + obj[i] + \"\\n\"; &#125; return result;&#125; 相关的方法还有：Object.keys(), Object.getOwnPropertyNames() Object.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。 Object.getOwnPropertyNames() 方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。 创建对象 创建对象的方式有三种：对象直接量，关键字 new，使用 Object.create() 方法。 Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。 继承 所有的 JavaScript 对象继承于至少一个对象。被继承的对象被称作原型，并且继承的属性可能通过构造函数的 prototype 对象找到。 定义方法 一个方法 是关联到某个对象的函数，或者简单地说，一个方法是一个值为某个函数的对象属性。定义方法就象定义普通的函数，除了它们必须被赋给对象的某个属性。例如： 1234567objectName.methodname = function_name;var myObj = &#123; myMethod: function(params) &#123; // ...do something &#125;&#125;; 深度克隆了解值类型和引用类型的区别，了解各种对象的读取、遍历方式，并在util.js中实现以下方法： 12345678910111213141516171819202122232425// 使用递归来实现一个深度克隆，可以复制一个目标对象，返回一个完整拷贝// 被复制的对象类型会被限制为数字、字符串、布尔、日期、数组、Object对象。不会包含函数、正则对象等function cloneObject(src) &#123; // your implement&#125;// 测试用例：var srcObj = &#123; a: 1, b: &#123; b1: [\"hello\", \"hi\"], b2: \"JavaScript\" &#125;&#125;;var abObj = srcObj;var tarObj = cloneObject(srcObj);srcObj.a = 2;srcObj.b.b1[0] = \"Hello\";console.log(abObj.a);console.log(abObj.b.b1[0]);console.log(tarObj.a); // 1console.log(tarObj.b.b1[0]); // \"hello\" 参考： 白话简单克隆和深度克隆 介绍什么是深度克隆，用羊圈和羊的图，简单深刻。如下图： javascript克隆对象深度介绍 这个代码写的太妙了，可惜找不到源地址了，都是转载来转载去的，要是你知道源地址，请留言告诉我。 浅度克隆：基本类型为值传递，对象仍为引用传递。 深度克隆：所有元素或属性均完全克隆，并于原引用类型完全独立，即，在后面修改对象的属性的时候，原对象不会被修改。 思路：深度克隆复制目标对象，那么就需要枚举这个对象。 判断当前属性是否是引用类型，如果是数组或者对象，创建相应类型变量。 枚举对象内所有属性。 使用 hasOwnProperty() 方法，排除继承的属性。 给新的对象相应位置赋值，若当前属性为引用类型（数组或对象）递归本方法。直到内部的值类型。 返回新的对象。 我的代码实现： 12345678910111213141516171819function cloneObject(src) &#123; // your implement var o; //result if (Object.prototype.toString.call(src) === \"[object Array]\") &#123; o = []; //判断是否是数组，并赋初始值 &#125; else &#123; o = &#123;&#125;; &#125; for (var i in src) &#123; //遍历这个对象 if (src.hasOwnProperty(i)) &#123; //排出继承属性 if (typeof src[i] === \"object\") &#123; o[i] = cloneObject(src[i]); //递归赋值 &#125; else &#123; o[i] = src[i]; //直接赋值 &#125; &#125; &#125; return o;&#125; 对数组进行去重参考： MDN Array JavaScript Array 对象 w3school 要求： 123456789// 对数组进行去重操作，只考虑数组中元素为数字或字符串，返回一个去重后的数组function uniqArray(arr) &#123; // your implement&#125;// 使用示例var a = [1, 3, 5, 7, 5, 3];var b = uniqArray(a);console.log(b); // [1, 3, 5, 7] 思路： 新建一个空数组 遍历原数组 若新数组中不存在当前元素，将其 push 入新数组中 返回新数组 实现： 12345678910// 对数组进行去重操作，只考虑数组中元素为数字或字符串，返回一个去重后的数组function uniqArray(arr) &#123; var newArr = []; //创建空数组 for (var i in arr) &#123; //遍历旧数组 if (newArr.indexOf(arr[i]) == -1) &#123;//如果新数组中不存在当前元素 newArr.push(arr[i]);//新数组中加入当前元素 &#125; &#125; return newArr;&#125; 相关方法与知识点： Array 对象 Array 对象属性 属性 | 描述constructor | 返回对创建此对象的数组函数的引用。length | 设置或返回数组中元素的数目。prototype | 使您有能力向对象添加属性和方法。 Mutator 方法，这些方法可以改变数组自身 方法 | 描述pop | 移除数组的最后一个元素，返回值是被删除的元素。push | 在数组的末尾添加一个或者多个元素，返回值是新的数组的长度。reverse | 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个，也就是数组的索引发生了变化。shift | 删除数组的第一个元素，返回值是删除的元素。sort | 对数组中的元素进行排序。splice | 添加或删除数组中的一个或多个元素。unshift | 添加一个或者多个元素在数组的开头，返回值是新的数组的长度。 Accessor 方法，这些过程不改变数组自身 These methods do not modify the array and return some representation of the array. 方法|描述concat | 返回一个包含此数组和其他数组和/或值的结合的新数组indexOf | 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1。join | 将所有的数组元素连接成一个字符串。lastIndexOf | 返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引。slice | 返回数组中的一段。toSource | Returns an array literal representing the specified array; you can use this value to create a new array. Overrides the Object.toSource method.toString | 返回代表该数组及其元素的字符,重写Object.toString 过程.valueOf | Returns the primitive value of the array. Overrides the Object.valueOf method. 循环（迭代）过程 方法 | 描述filter | 对数组中的每一个元素调用参数中指定的过滤函数，并将对于过滤函数返回值为true的那些数组元素集合为新的数组返回。forEach | 对数组的每一个元素依次调用参数中指定的函数。every | 如果数组中每一个元素都满足参数中提供的测试函数，则返回真。map | Creates a new array with the results of calling a provided function on every element in this array.some | 如果数组中至少有一个元素满足参数函数的测试，则返回true。 实现 trim()参考： String MDN JavaScript String 对象 W3school 要求： 12345678910111213141516171819// 中级班同学跳过此题// 实现一个简单的trim函数，用于去除一个字符串，头部和尾部的空白字符// 假定空白字符只有半角空格、Tab// 练习通过循环，以及字符串的一些基本方法，分别扫描字符串str头部和尾部是否有连续的空白字符，并且删掉他们，最后返回一个完成去除的字符串function simpleTrim(str) &#123; // your implement&#125;// 很多同学肯定对于上面的代码看不下去，接下来，我们真正实现一个trim// 对字符串头尾进行空格字符的去除、包括全角半角空格、Tab等，返回一个字符串// 尝试使用一行简洁的正则表达式完成该题目function trim(str) &#123; // your implement&#125;// 使用示例var str = ' hi! ';str = trim(str);console.log(str); // 'hi!' 思路： 对于 simpleTrim() 做两次循环，从前面开始和从后面开始。遇到空格和Tab跳出，最后用 slice() 取出子字符串。 对于 trim() 使用正则表达式。 实现： 12345678910111213141516171819function simpleTrim(str) &#123; var i; var j; for (i = 0; i &lt; str.length; i++) &#123; //从头遍历字符串 if (str.charAt(i) != \" \" &amp;&amp; str.charAt(i) != \"\\t\") &#123; //当不为空的时候 break; //跳出循环 &#125; &#125; for (j = str.length - 1; j &gt;= 0; j--) &#123; if (str.charAt(j) != \" \" &amp;&amp; str.charAt(j) != \"\\t\") &#123; //当不为空的时候 break; //跳出循环 &#125; &#125; return str.slice(i, j + 1); //返回子字符串&#125;function trim(str) &#123; return str.replace(/^\\s+|\\s+$/g, '');&#125; 关于正则表达式： 正则表达式上面的思路是匹配开头和结尾的空白字符，并全局匹配。 ^：匹配字符串的开头，在多行检索中，匹配一行的开头。 $：匹配字符串的结尾，在多行检索中，匹配一行的结尾。 |：选择，匹配的是该符号左边的子表达式或右边的子表达式。 \\s：任何 Unicode 空白符。 g：执行一个全局匹配，简言之，即找到所有匹配，而不是找到第一个之后就停止。 以上来自 JavaScript权威指南（犀牛书），感觉这里面将的正则表达式还不错。 相关方法和知识点： String对象 String 对象属性 属性 | 描述constructor | 对创建该对象的函数的引用length | 字符串的长度prototype | 允许您向对象添加属性和方法 String 对象方法 方法 | 描述charAt() | 返回在指定位置的字符。charCodeAt() | 返回在指定的位置的字符的 Unicode 编码。concat() | 连接字符串。indexOf() | 检索字符串。lastIndexOf() | 从后向前搜索字符串。localeCompare() | 用本地特定的顺序来比较两个字符串。match()| 找到一个或多个正则表达式的匹配。replace() | 替换与正则表达式匹配的子串。search() | 检索与正则表达式相匹配的值。slice()| 提取字符串的片断，并在新的字符串中返回被提取的部分。split()| 把字符串分割为字符串数组。substr() | 从起始索引号提取字符串中指定数目的字符。substring() |提取字符串中两个指定的索引号之间的字符。toLowerCase() | 把字符串转换为小写。toUpperCase() | 把字符串转换为大写。toString() | 返回字符串。valueOf() | 返回某个字符串对象的原始值。 静态方法 String.fromCharCode() 使用作为参数传入的字符编码创建一个新的字符串。 HTML方法 由于不是标准方法，这里就不列举了。 遍历数组，使每一个元素执行 fn 函数要求： 1234567891011121314151617181920// 实现一个遍历数组的方法，针对数组中每一个元素执行fn函数，并将数组索引和元素作为参数传递function each(arr, fn) &#123; // your implement&#125;// 其中fn函数可以接受两个参数：item和index// 使用示例var arr = ['java', 'c', 'php', 'html'];function output(item) &#123; console.log(item)&#125;each(arr, output); // java, c, php, html// 使用示例var arr = ['java', 'c', 'php', 'html'];function output(item, index) &#123; console.log(index + ': ' + item)&#125;each(arr, output); // 0:java, 1:c, 2:php, 3:html 分析： 这个任务有点像 ECMAScript5 中新增的数组方法：forEach()。还有一点这里的参数 index 是可选形参，保证第一个参数 item 能正常传入就行了，代码非常简单，如下： 实现： 12345function each(arr, fn) &#123; for(var i in arr)&#123; fn(arr[i],i); &#125;&#125; 获取对象中第一层元素个数要求： 12345678910111213// 获取一个对象里面第一层元素的数量，返回一个整数function getObjectLength(obj) &#123;&#125;// 使用示例var obj = &#123; a: 1, b: 2, c: &#123; c1: 3, c2: 4 &#125;&#125;;console.log(getObjectLength(obj)); // 3 实现： 123function getObjectLength(obj) &#123; return Object.keys(obj).length;&#125; 这个自己写的比较简单，不知道可以这样写不。其中 Object.keys(o) 为 Object 的一个静态方法，参数是一个对象，返回一个包含o的所有可枚举自有（非继承）属性名字的数组。 正则表达式要求： 123456789// 判断是否为邮箱地址function isEmail(emailStr) &#123; // your implement&#125;// 判断是否为手机号function isMobilePhone(phone) &#123; // your implement&#125; 分析： 邮箱由（数字字母，点），数字字母组合，@符号，数字字母，（点，数字字母）。其中两个小括号都是任意个数的。并且开头和结尾都是字母。 手机号是11位组成的，有时候会在前面加国际区号的前缀，如中国：+86。查阅相关资料后发现区号最多4位。国际电话区号_百度百科 并且手机号最多就是11位，其他国家有用8位的，也有用7位，10位的都有。最短是7位，最长是11位。 实现： 1234567891011// 判断是否为邮箱地址function isEmail(emailStr) &#123; var pattern = /^(\\w+\\.)*\\w+@\\w+(\\.\\w+)+$/; return pattern.test(emailStr);&#125;// 判断是否为手机号function isMobilePhone(phone) &#123; var pattern = /^(\\+\\d&#123;1,4&#125;)?\\d&#123;7,11&#125;$/; return pattern.test(phone);&#125; 相关方法和知识点： 参考：RegExp MDN 正则表达式修饰符： 字符 | 含义g | 全局匹配i | 忽略大小写m | 让开始和结束字符（^ 和 $）工作在多行模式（也就是，^ 和 $ 可以匹配字符串中每一行的开始和结束（行是由 \\n 或 \\r 分割的），而不只是整个输入字符串的最开始和最末尾处。 字符类别 字符 | 含义[…]|方括号内的任意字符[^…]|不在方括号内的任意字符. | （点号，小数点）匹配任意单个字符，但是换行符除外，包括：\\n \\r \\u2028 或 \\u2029。需要注意的是，m 多行（multiline）标志不会改变点号的表现。因此为了匹配多行中的字符集，可使用[^] （当然你不是打算用在旧版本 IE 中），它将会匹配任意字符，包括换行符例如，/.y/ 匹配 “yes make my day” 中的 “my” 和 “ay”，但是不匹配 “yes”。\\d | 匹配基本拉丁字母表（basic Latin alphabet）中的一个数字字符。等价于[0-9]。例如，/\\d/ 或 /[0-9]/ 匹配 “B2 is the suite number.” 中的 ‘2’。\\D | 匹配任意一个不是基本拉丁字母表中数字的字符。等价于[^0-9]。例如，/\\D/ 或 /[^0-9]/ 匹配 “B2 is the suite number.” 中的 ‘B’。\\w | 匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。例如，/\\w/ 匹配 “apple” 中的 ‘a’，”$5.28” 中的 ‘5’ 和 “3D” 中的 ‘3’。\\W | 匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9_]。例如，/\\W/ 或 /[^A-Za-z0-9_]/ 匹配 “50%” 中的 ‘%’。\\s | 匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。等价于 [ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​ \\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​​\\u202f\\u205f​ \\u3000]。例如 /\\s\\w/ 匹配 “foo bar” 中的 ‘ bar’。\\S | 匹配一个非空白符。等价于 [^ \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e\\u2000​\\u2001\\u2002​\\u2003\\u2004​ \\u2005\\u2006​\\u2007\\u2008​\\u2009\\u200a​\\u2028\\u2029​\\u202f\\u205f​\\u3000]。例如，/\\S\\w/ 匹配 “foo bar” 中的 ‘foo’。[\\b] | 匹配一个退格符（backspace）（不要与 \\b 混淆） 直接量字符 字符| 匹配数字和字母字符|自身\\t | 匹配一个水平制表符（tab）\\r | 匹配一个回车符（carriage return）\\n | 匹配一个换行符（linefeed）\\v | 匹配一个垂直制表符（vertical tab）\\f | 匹配一个换页符（form-feed）\\0 | 匹配一个 NUL 字符。不要在此后面跟小数点。\\cX |X 是 A - Z 的一个字母。匹配字符串中的一个控制字符。例如，/\\cM/ 匹配字符串中的 control-M。\\xhh | 匹配编码为 hh （两个十六进制数字）的字符。\\uhhhh | 匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。 边界 字符| 含义^ |匹配输入/字符串的开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。例如，/^A/ 不匹配 “an A” 中的 “A”，但匹配 “An A” 中的 “A”。$ |匹配输入/字符串的结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。例如，/t$/ 不匹配 “eater” 中的 “t”，但匹配 “eat” 中的 “t”。\\b |匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。 （不要和 [\\b] 混淆）例如，/\\bno/ 匹配 “at noon” 中的 “no”，/ly\\b/ 匹配 “possibly yesterday.” 中的 “ly”。\\B |匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。例如，/\\Bon/ 匹配 “at noon” 中的 “on”，/ye\\B/ 匹配 “possibly yesterday.” 中的 “ye”。 DOM参考： HTML DOM 教程 W3C JavaScript HTML DOM W3C 参考手册-HTML DOM Document 对象 参考手册-HTML DOM Element 对象 基本任务任务： 先来一些简单的，在你的util.js中完成以下任务： 12345678910111213141516171819// 为element增加一个样式名为newClassName的新样式function addClass(element, newClassName) &#123; // your implement&#125;// 移除element中的样式oldClassNamefunction removeClass(element, oldClassName) &#123; // your implement&#125;// 判断siblingNode和element是否为同一个父元素下的同一级的元素，返回bool值function isSiblingNode(element, siblingNode) &#123; // your implement&#125;// 获取element相对于浏览器窗口的位置，返回一个对象&#123;x, y&#125;function getPosition(element) &#123; // your implement&#125; 思路： addClass() 对于element本身如果没有样式类，那么使用Element的className属性获取的是空字符串，则直接添加新的样式类字符串即可。对于已经有了样式类的元素，获取到原有的样式类后，在后面添加一个空格，再添加新的样式类即可。 removeClass() 获取原始的样式，然后用正则表达式去匹配这个要删掉的样式，由于是动态的正则表达式，所以要用正则的构造函数 RegExp() 来创建，并且使用 \\b 来确定单词边界。匹配好后用空字符串替换被匹配的样式类即可。 isSiblingNode() 直接判断两个父节点是不是相同 getPosition() 下面这些内容是我之前的思路，现在觉得太复杂，可以用另一种解决方法。 offsetTop, offsetLeft 都是相对于最近一个有定位的父元素，如果都没有那么就是相对于 body 的偏移位置。 offsetParent 是寻找最近一个有定位的父级元素，如果没有，那么找到 body 元素。 所以这道题需要先寻找有定位的父级元素，如果都没有，那么就是相对于 body 的偏移了，可以直接使用 offsetTop, offsetLeft。 如果有定位的父级元素不是 body，是 A 元素，那么再寻找 A 元素的最近的有定位的父级元素，如果没有，就是相对于 body 的定位，这时，所求偏移量就是 A 的偏移量加所求元素相对于 A 的偏移量。如果 A 还有已经定位的父级元素，就继续去推，直到找到 body 为止。 这里可能要用到一个递归算法。 另一种方法： 使用 getBoundingClientRect() 方法获取当前元素相对于可视区域的位置，再加上滚动条的位置。 关于滚动条的位置 scrollTop, scrollLeft 这两个属性的使用，各个浏览器还都不一样。 详情见 document.body.scrollTop or document.documentElement.scrollTop。 简单的说就是：FF、Opera 和 IE 浏览器认为在客户端浏览器展示的页面的内容对应于整个 HTML，所以使用 document.documentElement来代表，相应的滚动距离则通过 document.documentElement.scrollLeft 和 document.documentElement.scrollTop 来获取，而 Safari 和 Chrome 浏览器则认为页面开始于 body 部分，从而相应的滚动距离用 document.body.scrollLeft 和 document.body.scrollTop 来获取。另外需要注意的是，FF 和 IE 的 quirks mode（兼容模式）下是用 document.body 来获取的。 documentElement 对应的是 html 标签，而 body 对应的是 body 标签 针对跨浏览器的解决方案则可简单的用如下代码获取： 12var scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);var scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop); 实现： 1234567891011121314151617181920212223// 为element增加一个样式名为newClassName的新样式function addClass(element, newClassName) &#123; var oldClassName = element.className; //获取旧的样式类 element.className = oldClassName === \"\" ? newClassName : oldClassName + \" \" + newClassName;&#125;// 移除element中的样式oldClassNamefunction removeClass(element, oldClassName) &#123; var originClassName = element.className; //获取原先的样式类 var pattern = new RegExp(\"\\\\b\" + oldClassName + \"\\\\b\"); //使用构造函数构造动态的正则表达式 element.className = originClassName.replace(pattern, '');&#125;function isSiblingNode(element, siblingNode) &#123; return element.parentNode === siblingNode.parentNode;&#125;function getPosition(element) &#123; var pos=&#123;&#125;; pos.x = element.getBoundingClientRect().left + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft); pos.y = element.getBoundingClientRect().top + Math.max(document.documentElement.scrollTop, document.body.scrollTop); return pos;&#125; mini $任务： 接下来挑战一个mini $，它和之前的$是不兼容的，它应该是document.querySelector的功能子集，在不直接使用document.querySelector的情况下，在你的util.js中完成以下任务： 123456789101112131415161718192021// 实现一个简单的Queryfunction $(selector) &#123;&#125;// 可以通过id获取DOM对象，通过#标示，例如$(\"#adom\"); // 返回id为adom的DOM对象// 可以通过tagName获取DOM对象，例如$(\"a\"); // 返回第一个&lt;a&gt;对象// 可以通过样式名称获取DOM对象，例如$(\".classa\"); // 返回第一个样式定义包含classa的对象// 可以通过attribute匹配获取DOM对象，例如$(\"[data-log]\"); // 返回第一个包含属性data-log的对象$(\"[data-time=2015]\"); // 返回第一个包含属性data-time且值为2015的对象// 可以通过简单的组合提高查询便利性，例如$(\"#adom .classa\"); // 返回id为adom的DOM所包含的所有子节点中，第一个样式定义包含classa的对象 参考： Sizzle选择器 Sizzle引擎–原理与实践（一） Sizzle是怎样工作的 思路： 通过空格拆分参数 selector，因为可能是组合查询。拆分为数组 selectorArr 遍历 selectorArr，条件判断各种情况。 得到节点的 Element 对象后，以这个对象为父节点，继续下一层的判断。 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//多个选择器有点难到我了，看了一些资料觉得思路应该如下：//1.如果存在#，直接从#开始向后查//2.如果存在tag直接找到所有的tag然后向后查//3.样式类，属性，从后向前查，得到它所有的父节点名称，去筛选匹配//以上的做法有点太复杂，我还是做一个简单的正向匹配吧。function $(selector) &#123; if (!selector) &#123; return null; &#125; if (selector == document) &#123; return document; &#125; selector = selector.trim(); if (selector.indexOf(\" \") !== -1) &#123; //若存在空格 var selectorArr = selector.split(/\\s+/); //拆成数组 var rootScope = myQuery(selectorArr[0]); //第一次的查找范围 var i = null; var j = null; var result = []; //循环选择器中的每一个元素 for (i = 1; i &lt; selectorArr.length; i++) &#123; for (j = 0; j &lt; rootScope.length; j++) &#123; result.push(myQuery(selectorArr[i], rootScope[j])); &#125; // rootScope = result; // 目前这个方法还有bug &#125; return result[0][0]; &#125; else &#123; //只有一个，直接查询 return myQuery(selector, document)[0]; &#125;&#125;/** * 针对一个内容查找结果 success * @param &#123;String&#125; selector 选择器内容 * @param &#123;Element&#125; root 根节点元素 * @return &#123;NodeList数组&#125; 节点列表，可能是多个节点也可能是一个 */function myQuery(selector, root) &#123; var signal = selector[0]; // var allChildren = null; var content = selector.substr(1); var currAttr = null; var result = []; root = root || document; //若没有给root，赋值document switch (signal) &#123; case \"#\": result.push(document.getElementById(content)); break; case \".\": allChildren = root.getElementsByTagName(\"*\"); // var pattern0 = new RegExp(\"\\\\b\" + content + \"\\\\b\"); for (i = 0; i &lt; allChildren.length; i++) &#123; currAttr = allChildren[i].getAttribute(\"class\"); if (currAttr !== null) &#123; var currAttrsArr = currAttr.split(/\\s+/); console.log(currAttr); for (j = 0; j &lt; currAttrsArr.length; j++) &#123; if (content === currAttrsArr[j]) &#123; result.push(allChildren[i]); console.log(result); &#125; &#125; &#125; &#125; break; case \"[\": //属性选择 if (content.search(\"=\") == -1) &#123; //只有属性，没有值 allChildren = root.getElementsByTagName(\"*\"); for (i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i].getAttribute(selector.slice(1, -1)) !== null) &#123; result.push(allChildren[i]); &#125; &#125; &#125; else &#123; //既有属性，又有值 allChildren = root.getElementsByTagName(\"*\"); var pattern = /\\[(\\w+)\\s*\\=\\s*(\\w+)\\]/; //为了分离等号前后的内容 var cut = selector.match(pattern); //分离后的结果，为数组 var key = cut[1]; //键 var value = cut[2]; //值 for (i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i].getAttribute(key) == value) &#123; result.push(allChildren[i]); &#125; &#125; &#125; break; default: //tag result = root.getElementsByTagName(selector); break; &#125; return result;&#125; 事件绑定注册事件与移除事件任务与实现： 1234567891011121314151617// 给一个element绑定一个针对event事件的响应，响应函数为listenerfunction addEvent(element, event, listener) &#123; if (element.addEventListener) &#123; element.addEventListener(event,listener); &#125; else if(element.attachEvent)&#123; element.attachEvent(\"on\"+event,listener); &#125;&#125;// 移除element对象对于event事件发生时执行listener的响应function removeEvent(element, event, listener) &#123; if (element.removeEventListenr) &#123; element.removeEventListenr(event,listener); &#125; else if(element.detachEvent)&#123; element.detachEvent(\"on\"+event,listener); &#125;&#125; 相关说明： IE8+ 支持 addEventListener()。IE8 以下的版本使用 attachEvent()。 attachEvent() 不支持事件捕获。 attachEvent() 第一个参数事件处理程序属性名使用前缀 on。 attachEvent() 允许相同的事件处理程序函数注册多次。 click 与 enter 键事件绑定任务与实现： 12345678910111213// 实现对click事件的绑定function addClickEvent(element, listener) &#123; addEvent(element, \"click\", listener);&#125;// 实现对于按Enter键时的事件绑定function addEnterEvent(element, listener) &#123; addEvent(element, \"keydown\", function(event) &#123; if (event.keyCode == 13) &#123; listener(); &#125; &#125;);&#125; 相关说明： 这里我直接使用了上一个任务写好的 addEvent() 函数。这样可以简化代码，并有良好的兼容性。 enter 键的 keyCode 为 13。 事件代理参考： javascript事件代理（委托） JS - 事件代理 任务与实现： 12345678function delegateEvent(element,tag,eventName,listener)&#123; addEvent(element, eventName, function(event)&#123; var target = event.target || event.srcElement; if(target.tagName.toLowerCase() == tag.toLowerCase()) &#123; listener.call(target, event); &#125; &#125;);&#125; BOM任务与实现： 123456789101112131415161718192021222324252627282930313233343536373839404142// 判断是否为IE浏览器，返回-1或者版本号function isIE() &#123; var s = navigator.userAgent.toLowerCase(); console.log(s); //ie10的信息： //mozilla/5.0 (compatible; msie 10.0; windows nt 6.2; trident/6.0) //ie11的信息： //mozilla/5.0 (windows nt 6.1; trident/7.0; slcc2; .net clr 2.0.50727; .net clr 3.5.30729; .net clr 3.0.30729; media center pc 6.0; .net4.0c; .net4.0e; infopath.2; rv:11.0) like gecko var ie = s.match(/rv:([\\d.]+)/) || s.match(/msie ([\\d.]+)/); if(ie) &#123; return ie[1]; &#125; else &#123; return -1; &#125;&#125;// 设置cookiefunction setCookie(cookieName, cookieValue, expiredays) &#123; var cookie = cookieName + \"=\" + encodeURIComponent(cookieValue); if (typeof expiredays === \"number\") &#123; cookie += \";max-age=\" + (expiredays * 60 * 60 * 24); &#125; document.cookie = cookie;&#125;// 获取cookie值function getCookie(cookieName) &#123; var cookie = &#123;&#125;; var all = document.cookie; if (all===\"\") &#123; return cookie; &#125; var list = all.split(\"; \"); for (var i = 0; i &lt; list.length; i++) &#123; var p = list[i].indexOf(\"=\"); var name = list[i].substr(0, p); var value = list[i].substr(p + 1); value = decodeURIComponent(value); cookie[name] = value; &#125; return cookie;&#125; 参考自：JavaScript权威指南 sessionStorage、localStorage 和 cookie 之间的区别 共同点 都是保存在浏览器端，且同源的。都是键值对存储。 区别 特性 | Cookie | localStorage | sessionStorage 数据的声明周期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 | 4K左右 | 一般为5MB | 同左 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信 | 同左 易用性 | 需要程序员自己封装，源生的Cookie接口不友好 | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 | 同左 应用场景 每个 HTTP 请求都会带着 Cookie 信息，所以 Cookie 应当简单，比如判断用户是否登陆。 localStorage 接替 Cookie 管理购物车，同时也可以存储 HTML5 游戏的一些本地数据。 sessionStorage 在表单内容较多的时候，为了优化用户体验，按步骤分页引导填写，这时使用sessionStorage 就发挥了作用。 安全性 cookie 中最好不要放置任何明文的东西。两个 storage的数据提交后在服务端一定要校验 参考： 详说 Cookie, LocalStorage 与 SessionStorage Ajax任务： 123456789101112131415161718// 学习Ajax，并尝试自己封装一个Ajax方法。实现如下方法：function ajax(url, options) &#123; // your implement&#125;// 使用示例：ajax( 'http://localhost:8080/server/ajaxtest', &#123; data: &#123; name: 'simon', password: '123456' &#125;, onsuccess: function (responseText, xhr) &#123; console.log(responseText); &#125; &#125;); 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243function ajax(url, options) &#123; var dataResult; //结果data // 处理data if (typeof(options.data) === 'object') &#123; var str = ''; for (var c in options.data) &#123; str = str + c + '=' + options.data[c] + '&amp;'; &#125; dataResult = str.substring(0, str.length - 1); &#125; // 处理type options.type = options.type || 'GET'; //获取XMLHttpRequest对象 var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'); // 发送请求 xhr.open(options.type, url, true); if (options.type == 'GET') &#123; xhr.send(null); &#125; else &#123; xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.send(dataResult); &#125; // readyState xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; if (options.onsuccess) &#123; options.onsuccess(xhr.responseText, xhr.responseXML); &#125; &#125; else &#123; if (options.onfail) &#123; options.onfail(); &#125; &#125; &#125; &#125;;&#125; 说明： 首先是处理 data，因为测试用例中的 data 是对象，所以把它遍历出来，把键和值中间用 = 连接，和下一组数据用 &amp; 连接。 处理 type，默认是 GET 请求。 使用 open() 指明请求方法和 url。方法一般为 GET 或 POST。 调用 send() 方法，GET 请求没有主体，所以应该传递 null 或省略这个参数。POST 请求有主体，同时使用 setRequestHeaders() 来指定 “Content-type” 头。这样便成功发送了请求。 取的响应。一个完整的 HTTP 响应是由状态码、响应头集合、响应主体组成。 readyState 是一个整数，它指定了 HTTP 请求的状态。其值和含义如下表： 值 | 含义0 | open() 尚未调用1 | open() 已调用2 | 接收到响应头信息3 | 接收到响应主体4 | 响应完成 status 和 statusText 属性以数字和文本的形式返回 HTTP 状态码。这些属性保存标准的 HTTP 值。如，200和 “OK” 表示成功请求，404和 “Not Found” 表示 URL 不能匹配服务器上的任何资源。 getResponseHeader() 和 getAllResponseHeaders() 能查询响应头。 响应主体可以从 responseText 属性中得到文本形式的，从 responseXML 属性中得到 Document 形式的。 补充一点 onreadystatechange 事件会在 readyState 改变时被触发。 参考： Ajax W3C Comet：基于 HTTP 长连接的“服务器推”技术 练习1：处理兴趣列表任务要求在task0002目录下创建一个task0002_1.html文件，以及一个js目录和css目录，在js目录中创建task0002_1.js，并将之前写的util.js也拷贝到js目录下。然后完成以下需求。 第一阶段 在页面中，有一个单行输入框，一个按钮，输入框中用来输入用户的兴趣爱好，允许用户用半角逗号来作为不同爱好的分隔。 当点击按钮时，把用户输入的兴趣爱好，按照上面所说的分隔符分开后保存到一个数组，过滤掉空的、重复的爱好，在按钮下方创建一个段落显示处理后的爱好。 第二阶段 单行变成多行输入框，一个按钮，输入框中用来输入用户的兴趣爱好，允许用户用换行、空格（全角/半角）、逗号（全角/半角）、顿号、分号来作为不同爱好的分隔。 当点击按钮时的行为同上 第三阶段 用户输入的爱好数量不能超过10个，也不能什么都不输入。当发生异常时，在按钮上方显示一段红色的错误提示文字，并且不继续执行后面的行为；当输入正确时，提示文字消失。 同时，当点击按钮时，不再是输出到一个段落，而是每一个爱好输出成为一个checkbox，爱好内容作为checkbox的label。 思路主要就是对字符串的操作，split() 的使用，以及正则表达式的使用。 实现 代码 在线demo 练习2：倒计时任务要求在和上一任务同一目录下面创建一个task0002_2.html文件，在js目录中创建task0002_2.js，并在其中编码，实现一个倒计时功能。 界面首先有一个文本输入框，允许按照特定的格式YYYY-MM-DD输入年月日； 输入框旁有一个按钮，点击按钮后，计算当前距离输入的日期的00:00:00有多少时间差 在页面中显示，距离YYYY年MM月DD日还有XX天XX小时XX分XX秒 每一秒钟更新倒计时上显示的数 如果时差为0，则倒计时停止 思路 setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 clearInterval() 方法可取消由 setInterval() 设置的 timeout。 clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。 setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。 clearTimeout() 方法可取消由 setTimeout() 方法设置的 timeout。 实现 代码 在线demo 练习3：图片轮播任务要求在和上一任务同一目录下面创建一个task0002_3.html文件，在js目录中创建task0002_3.js，并在其中编码，实现一个轮播图的功能。 图片数量及URL均在HTML中写好 可以配置轮播的顺序（正序、逆序）、是否循环、间隔时长 图片切换的动画要流畅 在轮播图下方自动生成对应图片的小点，点击小点，轮播图自动动画切换到对应的图片 效果示例：http://echarts.baidu.com/ 上面的轮播图（不需要做左右两个箭头） 思路将图片排列成一排，一起向左运动，每次运动的距离刚好是一张图片的宽度。 对于下面的小圆点，使用事件代理，将事件传递给每个 a 标签。 参考： JS图片切换 实现 代码 在线demo 关于变速运动评论中有人问到运动部分为什么这样写，下面我讲一下吧。 123456789function startMove(target) &#123; clearInterval(timerInner); timerInner = setInterval(function() &#123; var speed = (target - imgListDiv.offsetLeft) / 6; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); imgListDiv.style.left = imgListDiv.offsetLeft + speed + \"px\"; &#125;, 30);&#125; 上面是运动部分代码。 参数 target 是运动终点的位置。 首先停止计时器，为了避免上一次调用方法时，计时器没有关闭带来的干扰。 1clearInterval(timerInner); 下面开始开启计时器，每隔 30ms 执行一次内部的函数。 变速运动 1var speed = (target - imgListDiv.offsetLeft) / 6; 逐渐变慢，最后停止，距离越远速度越大，速度由距离决定 速度=(目标值-当前值)/缩放系数 这样写的原因就是为了让它做缓冲运动，而不是匀速运动，这样给用户带来的交互感觉会更好。 速度取整 1speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); 像素不能是小数，所以速度大于0的时候，向上取整。速度小于0时，向下取整 最后关于运动终止条件。 1imgListDiv.style.left = imgListDiv.offsetLeft + speed + \"px\"; 由这一行可以看出，`imgListDiv.style.left` 在不断增大，即 `imgListDiv.offsetLeft` 在不断增大。这两个是相同的属性，只不过一个是在赋值时使用，第二个是在取值时使用。 再看这行代码，由于这部分是每个30ms执行一次的，所以继续执行到这里。 1var speed = (target - imgListDiv.offsetLeft) / 6; 当不断增大的 `imgListDiv.offsetLeft` 等于 `target` 时，`speed` 为0。宏观表现为不再运动，这便是运动终止的状态，但是这里的方法还是不断在执行，每个30ms在执行。 练习4：输入框即时提示任务要求在和上一任务同一目录下面创建一个task0002_4.html文件，在js目录中创建task0002_4.js，并在其中编码，实现一个类似百度搜索框的输入提示的功能。 要求如下： 允许使用鼠标点击选中提示栏中的某个选项 允许使用键盘上下键来选中提示栏中的某个选项，回车确认选中 选中后，提示内容变更到输入框中 初级班： 不要求和后端交互，可以自己伪造一份提示数据例如： 1var suggestData = ['Simon', 'Erik', 'Kener']; 中级班： 自己搭建一个后端Server，使用Ajax来获取提示数据 思路这里我使用了给 input 标签加 input 监听，即输入框内容发生改变时，触发事件。并兼容到 IE7。 关于 input 监听的代码如下： 12345678910111213141516171819202122function addInputListener() &#123; if (inputArea.addEventListener) &#123; // all browsers except IE before version 9 inputArea.addEventListener(\"input\", OnInput); &#125; if (inputArea.attachEvent) &#123; // Internet Explorer and Opera inputArea.attachEvent(\"onpropertychange\", OnPropChanged); // Internet Explorer &#125;&#125;// Firefox, Google Chrome, Opera, Safari from version 5, Internet Explorer from version 9function OnInput(event) &#123; var inputValue = event.target.value; handleInput(inputValue);&#125;// Internet Explorerfunction OnPropChanged(event) &#123; var inputValue = \"\"; if (event.propertyName.toLowerCase() == \"value\") &#123; inputValue = event.srcElement.value; handleInput(inputValue); &#125;&#125; 其中 handleInput() 为下一步要执行的方法。 其实后来想了想也可以使用 keyup 事件了做这个任务。 匹配的过程同样适用正则表达式，从开头开始匹配。遍历备选单词，如果匹配成功，则放入 li 标签中，准备展示。 然后分别添加点击事件，键盘的 keydown 事件，用来选中提示出的单词。 参考： oninput 事件 实现 代码 在线demo 练习5：拖拽交互任务要求 实现一个可拖拽交互的界面 如示例图，左右两侧各有一个容器，里面的选项可以通过拖拽来左右移动 被选择拖拽的容器在拖拽过程后，在原容器中消失，跟随鼠标移动 注意拖拽释放后，要添加到准确的位置 拖拽到什么位置认为是可以添加到新容器的规则自己定 注意交互中良好的用户体验和使用引导 思路 页面布局时，将要被拖拽的 div 设置为绝对定位，因为这样在后面拖拽的时候才方便更改坐标。 初始化界面的时候，首先让 div 块按照相应的高度重新排列一下。 拖拽方法的实现。由 mousedown mousemove mouseup 三部分组成。 在 mousemove 中判断，不能让鼠标拖出浏览器窗口。 在 mouseup 中判断，是否到达指定区域。完成拖拽。 我在这里没有使用 html5 中的拖拽 API，所以兼容性还是很好的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"Baidu ife JavaScript 正则 Regular","slug":"Baidu-ife-JavaScript-正则-Regular","permalink":"https://qccs.github.io/tags/Baidu-ife-JavaScript-正则-Regular/"}]},{"title":"百度Web前端技术学院(1)-HTML, CSS基础","slug":"z/2015-04-15-baidu-ife-1","date":"2015-04-15T11:06:05.000Z","updated":"2019-04-14T09:21:22.771Z","comments":true,"path":"2015/04/15/z/2015-04-15-baidu-ife-1/","link":"","permalink":"https://qccs.github.io/2015/04/15/z/2015-04-15-baidu-ife-1/","excerpt":"content{:toc} 百度前端学院的第一次任务笔记，HTML、CSS 基础。主要有 CSS 工作原理，选择器的使用，常用属性，行高属性，盒模型与定位，最后根据设计图实现4个页面。 任务任务： HTML、CSS基础 有人问到提交作业 fork 同步的问题，真心觉得官方 GitHub 的帮助文档讲的很好，我上一篇博客 同步一个 fork 就是翻译的这个官方文档，如果懒得看英文可以参考我的博客。","text":"content{:toc} 百度前端学院的第一次任务笔记，HTML、CSS 基础。主要有 CSS 工作原理，选择器的使用，常用属性，行高属性，盒模型与定位，最后根据设计图实现4个页面。 任务任务： HTML、CSS基础 有人问到提交作业 fork 同步的问题，真心觉得官方 GitHub 的帮助文档讲的很好，我上一篇博客 同步一个 fork 就是翻译的这个官方文档，如果懒得看英文可以参考我的博客。 写点东西记录一下我的做题过程吧。 CSS 如何工作CSS 如何工作 Mozilla 的开发者文档讲的很好。 浏览器在展现一个文档的时候，必须要把文档内容和相应的样式信息结合起来展示。 这个处理过程一般分两个阶段： 浏览器先将标记语言和 CSS 转换成 DOM (文档对象模型)结构。 这时 DOM 就代表了电脑内存中的相应文档，因为它已经融合了文档内容和相应的样式表。 最后浏览器把 DOM 的内容展示出来。 层叠和继承参考资料: 层叠和继承 对于层叠来说，共有三种主要的样式来源： 浏览器对HTML定义的默认样式。 用户定义的样式。 开发者定义的样式，可以有三种形式： 定义在外部文件（外链样式）：本教程中案例主要是通过这种形式定义样式。 在页面的头部定义（内联样式）：通过这种形式定义的样式只在本页面内生效。 定义在特定的元素身上（行内样式）：这种形式多用于测试，可维护性较差。 用户定义的样式表会覆盖浏览器定义的默认样式，然后网页开发者定义的样式又会覆盖用户样式。 再来看看优先级，从高到低依次为：网页开发者定义的样式、网页阅读者定义的样式、浏览器的默认样式。 对继承的元素来说，子元素自身的样式优先级高于从父级继承来的样式。 更多细节CSS 另外提供了一个 !important 关键字，用户可以通过使用这个关键字使自己定义的样式覆盖掉开发者定义的样式。这就意味着，作为开发者，你很难准确的预知页面最终在用户电脑上的显示效果。 选择器参考资料:选择器（Selectors） 标签选择器类选择器（Class selectors） 通过设置元素的 class 属性，可以为元素指定类名。类名由开发者自己指定。 文档中的多个元素可以拥有同一个类名。 在写样式表时，类选择器是以英文句号（.）开头的。 ID选择器（ID selectors） 通过设置元素的 id 属性为该元素制定ID。ID名由开发者指定。每个ID在文档中必须是唯一的。 在写样式表时，ID选择器是以#开头的。 优先级 如果多余一个规则指定了相同的属性值都应用到一个元素上，CSS规定拥有更高确定度的选择器优先级更高。ID选择器比类选择器更具确定度, 而类选择器比标签选择器（tag selector）更具确定度。 如果样式中包含冲突的规则，且它们具有相同的确定度。那么，后出现的规则优先级高。 如果你遇到规则冲突，你可以增加其中一条的确定度或将之移到后面以使它具有更高优先级。 伪类选择器（Pseudo-classes selectors）基于关系的选择器选择器 |选择的元素A E |任何是元素A的后代元素E (后代节点指A的子节点，子节点的子节点，以此类推)A &gt; E |任何元素A的子元素E:first-child |任何元素的第一个子元素EB + E |任何元素B的下一个兄弟元素E 其他属性text-indent定义和用法text-indent 属性规定文本块中首行文本的缩进。注释：允许使用负值。如果使用负值，那么首行会被缩进到左边。 可能的值 值 |描述length |定义固定的缩进。默认值：0。% |定义基于父元素宽度的百分比的缩进。inherit |规定应该从父元素继承 text-indent 属性的值。 text-transform定义和用法text-transform 属性控制文本的大小写。 说明这个属性会改变元素中的字母大小写，而不论源文档中文本的大小写。如果值为 capitalize，则要对某些字母大写，但是并没有明确定义如何确定哪些字母要大写，这取决于用户代理如何识别出各个“词”。 可能的值 值 |描述none |默认。定义带有小写字母和大写字母的标准的文本。capitalize |文本中的每个单词以大写字母开头。uppercase |定义仅有大写字母。lowercase |定义无大写字母，仅有小写字母。inherit |规定应该从父元素继承 text-transform 属性的值。 text-decoration定义和用法text-decoration 属性规定添加到文本的修饰。注释：修饰的颜色由 “color” 属性设置。注释：IE、Chrome 或 Safari 不支持 “blink” 属性值。 说明这个属性允许对文本设置某种效果，如加下划线。如果后代元素没有自己的装饰，祖先元素上设置的装饰会“延伸”到后代元素中。不要求用户代理支持 blink。 text-align定义和用法text-align 属性规定元素中的文本的水平对齐方式。该属性通过指定行框与哪个点对齐，从而设置块级元素内文本的水平对齐方式。通过允许用户代理调整行内容中字母和字之间的间隔，可以支持值 justify；不同用户代理可能会得到不同的结果。 可能的值 值 |描述left |把文本排列到左边。默认值：由浏览器决定。right |把文本排列到右边。center |把文本排列到中间。justify |实现两端对齐文本效果。inherit |规定应该从父元素继承 text-align 属性的值。 word-spacing定义word-spacing 属性增加或减少单词间的空白（即字间隔）。该属性定义元素中字之间插入多少空白符。针对这个属性，“字” 定义为由空白符包围的一个字符串。如果指定为长度值，会调整字之间的通常间隔；所以，normal 就等同于设置为 0。允许指定负长度值，这会让字之间挤得更紧。注释：允许使用负值。 white-space定义和用法white-space 属性设置如何处理元素内的空白。这个属性声明建立布局过程中如何处理元素中的空白符。值 pre-wrap 和 pre-line 是 CSS 2.1 中新增的。 可能的值 值 |描述normal |默认。空白会被浏览器忽略。pre |空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap |文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap |保留空白符序列，但是正常地进行换行。pre-line |合并空白符序列，但是保留换行符。inherit |规定应该从父元素继承 white-space 属性的值。 @font-faceCSS3 @font-face 规则在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。通过 CSS3，web 设计师可以使用他们喜欢的任意字体。当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。您“自己的”的字体是在 CSS3 @font-face 规则中定义的。 注释：Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。 使用您需要的字体在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)： 实例 12345678@font-face &#123; font-family: myFirstFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9+ */&#125;div &#123; font-family: myFirstFont;&#125; CSS3 字体描述符 下面的表格列出了能够在 @font-face 规则中定义的所有字体描述符： 描述符 |值 |描述font-family |name |必需。规定字体的名称。src |URL |必需。定义字体文件的 URL。font-stretch |normalcondensedultra-condensedextra-condensedsemi-condensedexpandedsemi-expandedextra-expandedultra-expanded|可选。定义如何拉伸字体。默认是 “normal”。font-style|ormalitalicoblique|可选。定义字体的样式。默认是 “normal”。font-weight|normalbold100200300400500600700800900|选。定义字体的粗细。默认是 “normal”。unicode-range |unicode-range |可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。 深入了解行高属性参考：深入了解css的行高Line Height属性 一般来说，设置行高为值：纯数字是最理想的方式，因为其会随着对应的 font-size 而缩放。 盒模型及定位已知宽度的div居中 用两种方法来实现一个背景色为红色、宽度为960px的在浏览器中居中 我的方法一： 使用 margin：0 auto; html文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"task0001-2.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"center\"&gt;aaa&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css文件 12345.center &#123; width: 960px; margin: 0 auto; background-color: red;&#125; 方法二： 绝对定位，左边距离 body 50%，margin-left: -480px 1234567.center &#123; width: 960px; background-color: red; position: absolute; left: 50%; margin-left: -480px;&#125; Demo 对于居中的补充参考自 学习CSS布局。 像下面这样写css代码，使用 max-width 替代 width 可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要。 有效的避免了如下问题：当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。 1234#main &#123; max-width: 600px; margin: 0 auto;&#125; CSS布局奇淫技巧之–各种居中 早期css滑动门 有的圆角矩形是复杂图案，无法直接用border-radius，请在不使用 border-radius 的情况下实现一个可复用的高度和宽度都自适应的圆角矩形示例 这道题我一开始不会做，查阅了资料，发现这就是所谓的 css 滑动门的应用。妙味云课堂之css：滑动门、圆角、css精灵使用三层嵌套，或者四层嵌套的 div，通过背景图定位等方式可以实现。 左侧固定右侧自适应宽度的两列布局 用两种不同的方法来实现一个两列布局，其中左侧部分宽度固定、右侧部分宽度随浏览器宽度的变化而自适应变化 我的方法一： 不使用浮动，使用绝对定位，将左上角的块放好位置，右边的块设置margin-left html 文件： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;layout&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"task0001-6-3.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"row\"&gt; &lt;div class=\"left\"&gt;DIV-A&lt;/div&gt; &lt;div class=\"right\"&gt;DIV-B&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt;DIV-C&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css 文件： 1234567891011121314151617181920.row &#123; position: relative;&#125;.left &#123; width: 100px; height: 100px; background-color: red; position: absolute; top: 0; left: 0;&#125;.right &#123; height: 100px; background-color: blue; margin-left: 100px;&#125;.bottom &#123; height: 100px; background-color: yellow;&#125; 方法二： 使用浮动，左边的块使用浮动，右边的块使用margin-left 123456789101112131415.left &#123; width: 100px; height: 100px; background-color: red; float: left;&#125;.right &#123; height: 100px; background-color: blue; margin-left: 100px;&#125;.bottom &#123; height: 100px; background-color: yellow;&#125; Demo 补充： 看完了后面的 BFC 之后，本题和下一题都可以用另一种方法了总之我已经震惊了！太爽了！有没有！ html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;使用 BFC 进行两列布局&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"two-col-layout-with-BFC.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;DIV-A&lt;/div&gt; &lt;div class=\"right\"&gt;DIV-B&lt;/div&gt; &lt;div class=\"bottom\"&gt;DIV-C&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css 123456789101112131415.left&#123; width: 100px; height: 100px; background-color: blue; float: left;&#125;.right&#123; height: 100px; background-color: yellow; overflow: hidden;&#125;.bottom&#123; height: 100px; background-color: red;&#125; Demo 双飞翼布局 用两种不同的方式来实现一个三列布局，其中左侧和右侧的部分宽度固定，中间部分宽度随浏览器宽度的变化而自适应变化 原题中参考资料 双飞翼布局 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Flying Swing Layout&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"task0001-6-4.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"bd\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"main-wrap\"&gt; &lt;p&gt;Flying Swing Layout&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"sub\"&gt; &lt;p&gt;Flying Swing Layout&lt;/p&gt; left &lt;/div&gt; &lt;div class=\"extra\"&gt; &lt;p&gt;Flying Swing Layout&lt;/p&gt; right &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css 12345678910111213141516171819202122232425262728.bd &#123; /*padding: 0 190px;*/&#125;.main &#123; float: left; width: 100%; background-color: #aaa;&#125;.main-wrap &#123; margin: 0 190px;&#125;.sub &#123; float: left; width: 190px; margin-left: -100%; background-color: blue; /*position: relative; left: -190px;*/&#125;.extra &#123; float: left; width: 190px; margin-left: -190px; background-color: yellow; /*position: relative; right: -190px;*/&#125; Demo 补充： 使用 BFC 的另一种方法，我再一次震惊！ 代码超级简单！ html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;flying-Swing-BFC&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"flying-Swing-BFC.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;div class=\"main\"&gt; flying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.htmlflying-Swing-BFC.html &lt;/div&gt; &lt;div class=\"footer\"&gt; footerfooterfooterfooterfooterfooterfooterfooterfooter &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css 1234567891011121314.left&#123; width: 100px; background-color: red; float: left;&#125;.right&#123; width: 200px; background-color: blue; float: right;&#125;.main&#123; background-color: #eee; overflow: hidden;&#125; Demo 浮动布局 实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化 这个题我觉的直接将每一个块浮动起来就好了，不知我理解的对不对。 html文件 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"task0001-6-5.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css文件 12345678910body &#123; background-color: red;&#125;div &#123; width: 150px; height: 100px; margin: 10px; float: left; background-color: blue;&#125; Demo 清除浮动/闭合浮动参考自 那些年我们一起清除过的浮动 by 一丝冰凉 清除浮动：清除对应的单词是 clear，对应CSS中的属性是 clear：left | right | both | none； 闭合浮动：更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。 我们想要达到的效果更确切地说是闭合浮动，而不是单纯的清除浮动，设置clear：both清除浮动并不能解决warp高度塌陷的问题。 正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。 最后一丝姐给了两个精益求精方案，我觉得方案一更易于理解，这里实践一下： 闭合浮动的Demo 下面是源码 html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"close-float.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"left\"&gt; &lt;h1&gt;left&lt;/h1&gt; &lt;div&gt;Content or Something&lt;/div&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row2\"&gt;Row2&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css 123456789101112131415161718192021222324252627.row &#123; border: 1px solid red;&#125;.clearfix:after &#123; content: \"\\200B\"; display: block; height: 0; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125;.left &#123; width: 200px; float: left; background-color: #eee;&#125;.right &#123; width: 200px; float: right; background-color: #eee;&#125;.row2 &#123; width: 600px; height: 50px; background-color: #aaa;&#125; 其中*zoom: 1是为了触发hasLayout 还有另一种解决方案！ 参考自：清除浮动（clearfix hack） 直接使用，如下代码即可 1234.clearfix&#123; overflow: auto; zoom: 1;&#125; Demo (实际上，我看完后面的资料，再翻到这里就明白了！正是使用了BFC原理！！！！！！！) 但是今天遇到一个坑！ 如果使用了 over-flow，在后面如果有元素要绝对布局在父元素的外面的，意思就是出现 top, bottom, left, right 的值为负值时，就会出现看不到，或者滚动条的问题！ 若是有这种要求，我觉得还是用一丝姐姐的解决方案比较好。 参考 清除浮动的几种方法 box-sizing当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。 他们的内边距和边框都是向内的挤压的。支持IE8+，需要加浏览器内核。 1234567.simple &#123; width: 500px; margin: 20px auto; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 响应式布局媒体查询 MDN CSS媒体查询 媒体查询-学习CSS布局 @media screen and (min-width: 500px) and (max-width: 800px) { ... } An Introduction to Meta Viewport and @viewport 多列布局 column BFC 和 IE 的 hasLayout BFC和IE的hasLayout Block Formatting Context 的几大用处 看完这个资料后我震惊了！竟然可以这么玩儿！我将本文之前提到的两列布局，双飞翼布局又重新写了一遍！太爽了！代码超级简洁！ Block Formatting Context 的几大用处： 防止 margin 折叠 清除float 不会环绕float元素 相关资料 视觉格式化模型(visual formatting model) 块格式化上下文(block formatting context) div 三列等高纯CSS实现三列DIV等高布局 最关键的地方有3句： 最外层div设置一个溢出隐藏 123#wrap &#123; overflow:hidden;&#125; 每一个子块设置 padding 和 margin 1234#left,#center,#right&#123; margin-bottom:-10000px; padding-bottom:10000px;&#125; overflow:hidden; ‘隐藏溢出。如果内容溢出wrap层，则不显示。 margin-bottom:-10000px; ‘底部边距-10000px。padding-bottom:10000px; ‘底部填充10000px。上面这两句能够实现的效果就是，产生10000px的填充，然后用负的边距把它给抵销掉。 去除inline-block元素间间距一开始我不知道是因为使用了 display: inline-block 会有间距。后来查找资料找到了相关的方案。 去除inline-block元素间间距的N种方法 Fighting the Space Between Inline Block Elements 真正意义上的inline-block水平呈现的元素间，换行显示或空格分隔的情况下会有间距。这种表现是符合规范的应该有的表现。 解决方法有很多，上述博文中提到的有： 移除空格 使用 margin 负值 取消闭合标签 使用 font-size: 0 使用 letter-spacing 使用 word-spacing 其他 我觉得使用 4 font-size: 0 比较好，对别的元素影响最小。代码如下：在 a 的外层将字体尺寸设为 0，载对内层的 a 重新设置字体大小，即可。 123456nav &#123; font-size: 0;&#125;nav a &#123; font-size: 16px;&#125; 参考资料 HTML、CSS的代码规范 自己要试着改变一些代码风格了，规范化！ 顾轶灵:Web语义化我看他回答最后的举例的Sildes做的非常好，可以经常看看。Semantic HTML。他的其他Slides也做的非常好，很喜欢这种风格！ CSS命名规范@W3C Funs 起名不再困难！ 点击阅读: CSS浏览器兼容性列表-维基百科 类似的我想到了 Can I Use，Can I Use 包含的更多，包括 HTML5, CSS SVG, JS API 等。 学习CSS布局 Media Queries 使用CSS渐变 CSS3 Gradient CSS渐变生成器","categories":[{"name":"HTML CSS","slug":"HTML-CSS","permalink":"https://qccs.github.io/categories/HTML-CSS/"}],"tags":[{"name":"Baidu ife HTML CSS task","slug":"Baidu-ife-HTML-CSS-task","permalink":"https://qccs.github.io/tags/Baidu-ife-HTML-CSS-task/"}]},{"title":"同步一个 fork","slug":"z/2015-04-12-Syncing-a-fork","date":"2015-04-12T07:14:54.000Z","updated":"2019-04-14T09:21:22.780Z","comments":true,"path":"2015/04/12/z/2015-04-12-Syncing-a-fork/","link":"","permalink":"https://qccs.github.io/2015/04/12/z/2015-04-12-Syncing-a-fork/","excerpt":"content{:toc} fork 了别人的仓库后，原作者又更新了仓库，如何将自己的代码和原仓库保持一致？本文将给你解答。 如何使用搜索引擎其实这个问题并不难，我又被坑了。百度搜的东西不靠谱啊，以后这种问题一定要用英文在 Google 或者 Bing 上搜索，这样才能搜到原汁原味的答案。就当是一个教训吧。 搜索 fork sync，就可以看到 GitHub 自己的帮助文档 Syncing a fork 点进去看这篇的时候，注意到有一个 Tip: Before you can sync your fork with an upstream repository, you must configure a remote that points to the upstream repository in Git.","text":"content{:toc} fork 了别人的仓库后，原作者又更新了仓库，如何将自己的代码和原仓库保持一致？本文将给你解答。 如何使用搜索引擎其实这个问题并不难，我又被坑了。百度搜的东西不靠谱啊，以后这种问题一定要用英文在 Google 或者 Bing 上搜索，这样才能搜到原汁原味的答案。就当是一个教训吧。 搜索 fork sync，就可以看到 GitHub 自己的帮助文档 Syncing a fork 点进去看这篇的时候，注意到有一个 Tip: Before you can sync your fork with an upstream repository, you must configure a remote that points to the upstream repository in Git.根据这两篇文章，问题迎刃而解！ 具体方法Configuring a remote for a fork 给 fork 配置一个 remote 主要使用 git remote -v 查看远程状态。 123git remote -v# origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)# origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加一个将被同步给 fork 远程的上游仓库 1git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 再次查看状态确认是否配置成功。 12345git remote -v# origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)# origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)# upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)# upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) Syncing a fork 从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/mastergit fetch upstream 1234567git fetch upstream# remote: Counting objects: 75, done.# remote: Compressing objects: 100% (53/53), done.# remote: Total 62 (delta 27), reused 44 (delta 9)# Unpacking objects: 100% (62/62), done.# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY# * [new branch] master -&gt; upstream/master 切换到本地主分支(如果不在的话)git checkout master 12git checkout master# Switched to branch &apos;master&apos; 把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。git merge upstream/master 12345678git merge upstream/master# Updating a422352..5fdff0f# Fast-forward# README | 9 -------# README.md | 7 ++++++# 2 files changed, 7 insertions(+), 9 deletions(-)# delete mode 100644 README# create mode 100644 README.md 如果想更新到 GitHub 的 fork 上，直接 git push origin master 就好了。","categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://qccs.github.io/categories/GitHub/"}],"tags":[{"name":"GitHub 同步 fork","slug":"GitHub-同步-fork","permalink":"https://qccs.github.io/tags/GitHub-同步-fork/"}]},{"title":"判断两个数组是否相似 (arraysSimilar)","slug":"z/2015-04-06-arrays-similar","date":"2015-04-06T07:14:54.000Z","updated":"2019-04-14T09:21:22.777Z","comments":true,"path":"2015/04/06/z/2015-04-06-arrays-similar/","link":"","permalink":"https://qccs.github.io/2015/04/06/z/2015-04-06-arrays-similar/","excerpt":"content{:toc} 题目题目来自 慕课网 JavaScript 深入浅出 1-6 编程练习 请在 index.html 文件中，编写 arraysSimilar 函数，实现判断传入的两个数组是否相似。具体需求： 数组中的成员类型相同，顺序可以不同。例如 [1, true] 与 [false, 2] 是相似的。 数组的长度一致。 类型的判断范围，需要区分: String, Boolean, Number, undefined, null, 函数, 日期, window.","text":"content{:toc} 题目题目来自 慕课网 JavaScript 深入浅出 1-6 编程练习 请在 index.html 文件中，编写 arraysSimilar 函数，实现判断传入的两个数组是否相似。具体需求： 数组中的成员类型相同，顺序可以不同。例如 [1, true] 与 [false, 2] 是相似的。 数组的长度一致。 类型的判断范围，需要区分: String, Boolean, Number, undefined, null, 函数, 日期, window. 当以上全部满足，则返回“判定结果:通过”，否则返回“判定结果:不通过”。 题目给出了 index.html 如下： 123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb18030\"&gt; &lt;title&gt;Untitled Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; /* * param1 Array * param2 Array * return true or false */ function arraysSimilar(arr1, arr2)&#123; &#125; &lt;/script&gt; &lt;script src=\"testData.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中 testData.js 是测试用例，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var result = function() &#123; //以下为多组测试数据 var cases = [&#123; arr1: [1, true, null], arr2: [null, false, 100], expect: true &#125;, &#123; arr1: [ function() &#123;&#125;, 100 ], arr2: [100, &#123;&#125;], expect: false &#125;, &#123; arr1: [null, 999], arr2: [&#123;&#125;, 444 ], expect: false &#125;, &#123; arr1: [window, 1, true, new Date(), \"hahaha\", (function() &#123;&#125;), undefined], arr2: [undefined, (function() &#123;&#125;), \"okokok\", new Date(), false, 2, window], expect: true &#125;, &#123; arr1: [new Date()], arr2: [&#123;&#125;], expect: false &#125;, &#123; arr1: [window], arr2: [&#123;&#125;], expect: false &#125;, &#123; arr1: [undefined, 1], arr2: [null, 2], expect: false &#125;, &#123; arr1: [new Object, new Object, new Object], arr2: [&#123;&#125;, &#123;&#125;, null ], expect: false &#125;, &#123; arr1: null, arr2: null, expect: false &#125;, &#123; arr1: [], arr2: undefined, expect: false &#125;, &#123; arr1: \"abc\", arr2: \"cba\", expect: false &#125;]; //使用for循环, 通过arraysSimilar函数验证以上数据是否相似，如相似显示“通过”,否则\"不通过\",所以大家要完成arraysSimilar函数,具体要求，详见任务要求。 for (var i = 0; i &lt; cases.length; i++) &#123; if (arraysSimilar(cases[i].arr1, cases[i].arr2) !== cases[i].expect) &#123; document.write(\"不通过！case\" + (i + 1) + \"不正确！arr1=\" + JSON.stringify(cases[i].arr1) + \", arr2=\" + JSON.stringify(cases[i].arr2) + \" 的判断结果不是\" + cases[i].expect); return false; &#125; &#125; return true;&#125;();document.write(\"判定结果:\" + (result ? \"通过\" : \"不通过\")); 解答各位读者在看解答前也可以自己考虑一下，看看咱们的想法是否一致，期待您在本文的留言。 思路通过观察测试用例，可以发现，最后三个用例有不是数组的。所以我们可以先判断传入的参数是否是数组。又因为题目中要求数组长度必须一致，这也是第二个限制条件。最后再区分具体的类型。 理清思路我们可以分为以下步骤： 判断传入的参数是否为数组 (使用 instanceof 方法) 检查两个数组长度是否一致 分别判断数组内元素的基本数据类型 (使用 typeof 方法) 因为 typeof 只能检查基本数据类型，对于 null, Date, window 返回的都是 object，所以使用 Object.prototype.toString.apply() 来检查这些对象类型，其返回值为：&#39;[object Null]&#39;, &#39;[object Date]&#39;, &#39;[object global]&#39; 分别比较每个数组内元素的各种类型的个数，如果都相等，那么这两个数组是相似的。 具体实现代码JavaScript代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * ===================================================== * 请在index.html文件中，编写arraysSimilar函数，实现判断传入的两个数组是否相似。具体需求： * 1. 数组中的成员类型相同，顺序可以不同。例如[1, true] 与 [false, 2]是相似的。 * 2. 数组的长度一致。 * 3. 类型的判断范围，需要区分:String, Boolean, Number, undefined, null, 函数，日期, window. * * 当以上全部满足，则返回\"判定结果:通过\"，否则返回\"判定结果:不通过\"。 * ===================================================== *//** param1 Array* param2 Array* return true or false*/function arraysSimilar(arr1, arr2)&#123; if (arr1 instanceof Array &amp;&amp; arr2 instanceof Array ) &#123; //先判断传入的是否是数组 if (arr1.length == arr2.length) &#123; //判断数组长度 console.log(\"same-length\"); console.log(arr1); console.log(arr2); //开始判断数组内部是否相似 return sameLengthArraysSimilar(arr1, arr2); &#125; else&#123; //两个数组长度不同返回false return false; &#125; &#125; else &#123; //传入的参数不是数组返回false return false; &#125;&#125;/** * 判断两个等长的数组内部是否相似 * 遍历数组 * arr1中元素各种类型出现的个数是否和arr2中元素各种类型出现的个数相同 * @param &#123;Array&#125; arr1 数组1 * @param &#123;Array&#125; arr2 数组2 * @return &#123;true,false&#125; */function sameLengthArraysSimilar(arr1,arr2) &#123; var numInArr1 = 0; var numInArr2 = 0; var booleanInArr1 = 0; var booleanInArr2 = 0; var funInArr1 = 0; var funInArr2 = 0; var undefinedInArr1 = 0; var undefinedInArr2 = 0; var stringInArr1 = 0; var stringInArr2 = 0; var nullInArr1 = 0; var nullInArr2 = 0; var dateInArr1 = 0; var dateInArr2 = 0; var windowInArr1 = 0; var windowInArr2 = 0; for (var i = 0; i &lt; arr1.length; i++) &#123; if(typeof arr1[i] === 'number' )&#123; numInArr1 ++; &#125; else if(typeof arr1[i] === 'boolean')&#123; booleanInArr1 ++; &#125; else if(typeof arr1[i] === 'function')&#123; funInArr1 ++; &#125; else if(typeof arr1[i] === 'undefined')&#123; undefinedInArr1 ++; &#125; else if(typeof arr1[i] === 'string')&#123; stringInArr1 ++; &#125; else if(typeof arr1[i] ==='object')&#123; if(Object.prototype.toString.apply(arr1[i]) === '[object Null]')&#123; nullInArr1 ++; &#125; else if(Object.prototype.toString.apply(arr1[i]) === '[object Date]')&#123; dateInArr1 ++; &#125; else if(Object.prototype.toString.apply(arr1[i]) === '[object global]')&#123; windowInArr1 ++; &#125; &#125; if(typeof arr2[i] === 'number')&#123; numInArr2 ++; &#125; else if(typeof arr2[i] === 'boolean')&#123; booleanInArr2 ++; &#125; else if(typeof arr2[i] === 'function')&#123; funInArr2 ++; &#125; else if(typeof arr2[i] === 'undefined')&#123; undefinedInArr2 ++; &#125; else if(typeof arr2[i] === 'string')&#123; stringInArr2 ++; &#125; else if(typeof arr2[i] ==='object')&#123; if(Object.prototype.toString.apply(arr2[i]) === '[object Null]')&#123; nullInArr2 ++; &#125; else if(Object.prototype.toString.apply(arr2[i]) === '[object Date]')&#123; dateInArr2 ++; &#125; else if(Object.prototype.toString.apply(arr2[i]) === '[object global]')&#123; windowInArr2 ++; &#125; &#125; &#125; console.log(\"num---\"+numInArr1); console.log(\"num---\"+numInArr2); console.log(\"boo---\"+booleanInArr1); console.log(\"boo---\"+booleanInArr2); console.log(\"null---\"+nullInArr1); console.log(\"null---\"+nullInArr2); console.log(\"window---\"+windowInArr1); console.log(\"window---\"+windowInArr2); console.log(\"date---\"+dateInArr1); console.log(\"date---\"+dateInArr2); console.log(\"string---\"+stringInArr1); console.log(\"string---\"+stringInArr2); console.log(\"fun---\"+funInArr1); console.log(\"fun---\"+funInArr2); console.log(\"undefined---\"+undefinedInArr1); console.log(\"undefined---\"+undefinedInArr2); if(numInArr1 == numInArr2 &amp;&amp; booleanInArr1==booleanInArr2 &amp;&amp; funInArr1==funInArr2 &amp;&amp; undefinedInArr1==undefinedInArr2 &amp;&amp; stringInArr1==stringInArr2 &amp;&amp; nullInArr1==nullInArr2 &amp;&amp; dateInArr1==dateInArr2 &amp;&amp; windowInArr1==windowInArr2)&#123; console.log('================================true'); return true; &#125;else&#123; console.log('================================false'); return false; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://qccs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript Array 算法","slug":"JavaScript-Array-算法","permalink":"https://qccs.github.io/tags/JavaScript-Array-算法/"}]},{"title":"代码校验工具 SublimeLinter 的安装与使用","slug":"z/2015-03-26-sublimeLinter","date":"2015-03-26T07:14:54.000Z","updated":"2019-04-14T09:21:22.755Z","comments":true,"path":"2015/03/26/z/2015-03-26-sublimeLinter/","link":"","permalink":"https://qccs.github.io/2015/03/26/z/2015-03-26-sublimeLinter/","excerpt":"content{:toc} 本文我将讲述一下 SublimeLinter 的安装过程。其组件 jshint 的安装与使用。其组件 csslint 的安装与使用。我将基于 Sublime Text 3 来安装。使用 Sublime Text 2 的用户阅读本文是没有帮助的。 SublimeLinter 是 Sublime 的插件，它的作用是检查代码语法是否有错误，并提示。习惯了 IDE 下写代码的人一定需要一款在 Sublime 上类似的语法检查工具。下面我们开始。 安装 SublimeLinter如同其他插件一样使用 Package Control 来安装。","text":"content{:toc} 本文我将讲述一下 SublimeLinter 的安装过程。其组件 jshint 的安装与使用。其组件 csslint 的安装与使用。我将基于 Sublime Text 3 来安装。使用 Sublime Text 2 的用户阅读本文是没有帮助的。 SublimeLinter 是 Sublime 的插件，它的作用是检查代码语法是否有错误，并提示。习惯了 IDE 下写代码的人一定需要一款在 Sublime 上类似的语法检查工具。下面我们开始。 安装 SublimeLinter如同其他插件一样使用 Package Control 来安装。 按下 Ctrl+Shift+p 进入 Command Palette 输入install进入 Package Control: Install Package 输入SublimeLinter。进行安装. 安装完成后可以看到这样一段话： 123456789101112131415161718192021Welcome to SublimeLinter, a linter framework for Sublime Text 3. * * * IMPORTANT! * * * SublimeLinter 3 is NOT a drop-in replacement for earlier versions. Linters *NOT* included with SublimeLinter 3, they must be installed separately. The settings are different. * * * READ THE DOCS! * * * Otherwise you will never know how to install linters, nor will you know about all of the great new features in SublimeLinter 3. For complete documentation on how to install and use SublimeLinter, please see: http://www.sublimelinter.com 可以看到具体的 Linters 组件不被包含在 SublimeLinter 3 中，所以我们要额外独立安装组件。可以针对不同的语言安装不同的组件。 JavaScript 语法检查SublimeLinter-jshint 是基于 nodeJS 下的 jshint 的插件，实际上 SublimeLinter-jshint 调用了 nodeJS 中 jshint 的接口来进行语法检查的。 安装 SublimeLinter-jshint为了让 JavaScript 代码有语法检查，我们安装 SublimeLinter-jshint同样的方法，我们安装 SublimeLinter-jshint 按下 Ctrl+Shift+p 进入 Command Palette 输入install进入 Package Control: Install Package 输入SublimeLinter-jshint。进行安装. 如下图 安装完成后我们可以看到下面的一段话 12345678910SublimeLinter-jshint ------------------------------- This linter plugin for SublimeLinter provides an interface to jshint. ** IMPORTANT! ** Before this plugin will activate, you *must* follow the installation instructions here: https://github.com/SublimeLinter/SublimeLinter-jshint 安装 nodeJS 和 jshint在插件开始工作之前，我们必须再看一下上述插件的安装说明通过 SublimeLinter-jshint 的说明 我们可以看到，这个组件依赖于 nodeJS 下的 jshint，所以我们安装 nodeJS 环境和 nodeJS 下的 jshint。 安装 Node.js 通过 npm 安装jshint 在命令行下输入如下代码，完成安装 npm install -g jshint 安装完成后命令行中出现如下的信息 12345678910C:\\Users\\Administrator\\AppData\\Roaming\\npm\\jshint -&gt; C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\jshint\\bin\\jshintjshint@2.6.3 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\jshint├── strip-json-comments@1.0.2├── underscore@1.6.0├── exit@0.1.2├── shelljs@0.3.0├── console-browserify@1.1.0 (date-now@0.1.4)├── htmlparser2@3.8.2 (domelementtype@1.3.0, entities@1.0.0, domhandler@2.3.0, readable-stream@1.1.13, domutils@1.5.1)├── minimatch@1.0.0 (sigmund@1.0.0, lru-cache@2.5.0)└── cli@0.6.6 (glob@3.2.11) 可以查看 jshint 版本，已确认安装完成。 12C:\\Users\\Administrator&gt;jshint -vjshint v2.6.3 现在，恭喜你，我们使用 Sublime 编辑 JavaScript 文件，就会有语法检查了！ 在编辑过程中，会有如下提示 点击提示点后，Sublime 状态栏也会有相应的说明 css 语法检查与 jshint 同理，SublimeLinter-csslint 也是基于 nodeJS 下的 csslint 的插件，实际上 SublimeLinter-csslint 调用了 nodeJS 中 csslint 的接口来进行语法检查的。 安装 SublimeLinter-csslint同样的方法。 按下 Ctrl+Shift+p 进入 Command Palette 输入install进入 Package Control: Install Package 输入SublimeLinter-csslint。进行安装. 如下图 安装完成后我们可以看到下面的一段话 12345678910SublimeLinter-csslint-------------------------------This linter plugin for SublimeLinter provides an interface to csslint.** IMPORTANT! **Before this plugin will activate, you *must*follow the installation instructions here:https://github.com/SublimeLinter/SublimeLinter-csslint 在使用插件之前，必须遵循上述网址中的安装说明 在 nodeJS 下安装 csslint进入上述的 GitHub 地址，csslint 的说明页。我们知道了和 jshint 一样，csslint 也是基于 nodeJS 下的 csslint 来使用的。 这里安装 nodeJS 过程省略。只需用 npm 安装 csslint 即可。 在命令行中输入 1npm install -g csslint 安装完成后命令行中出现如下的信息 123C:\\Users\\Administrator\\AppData\\Roaming\\npm\\csslint -&gt; C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\csslint\\cli.jscsslint@0.10.0 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\csslint└── parserlib@0.2.5 可以查看 csslint 版本，已确认安装完成。 12C:\\Users\\Administrator&gt;csslint --versionv0.10.0 现在，恭喜你，我们使用 Sublime 编辑 css 文件，就会有语法检查了！ 在编辑过程中，会有如下提示 点击提示点后，Sublime 状态栏也会有相应的说明","categories":[{"name":"Sublime","slug":"Sublime","permalink":"https://qccs.github.io/categories/Sublime/"}],"tags":[{"name":"Sublime jshint csslint","slug":"Sublime-jshint-csslint","permalink":"https://qccs.github.io/tags/Sublime-jshint-csslint/"}]}]}