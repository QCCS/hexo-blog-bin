<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2019/4 | qianchaochushui</title>
  <meta name="description" content="weichat:qianchaochushui">
  <meta name="keywords" content="Node javascript CSS React Vue">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="qianchaochushui">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="weichat:qianchaochushui">
<meta name="keywords" content="Node javascript CSS React Vue">
<meta property="og:type" content="website">
<meta property="og:title" content="qianchaochushui">
<meta property="og:url" content="https://qccs.github.io/archives/2019/04/page/3/index.html">
<meta property="og:site_name" content="qianchaochushui">
<meta property="og:description" content="weichat:qianchaochushui">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qianchaochushui">
<meta name="twitter:description" content="weichat:qianchaochushui">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class="wrapper">
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href="/">
				qianchaochushui
			</a>
			<div class="menu">
				<ul class="h-list">
					
						<li>
							<a class="flat-box nav-home" href="/">
								首页
							</a>
						</li>
					
						<li>
							<a class="flat-box nav-archives" href="/archives">
								存档
							</a>
						</li>
					
						<li>
							<a class="flat-box nav-categories" href="/categories">
								分类
							</a>
						</li>
					
						<li>
							<a class="flat-box nav-tags" href="/tags">
								标签
							</a>
						</li>
					
						<li>
							<a class="flat-box nav-about" href="/about">
								关于
							</a>
						</li>
					
				</ul>
				<div class="underline"></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a href="javascript:void(0)"><span class="icon icon-search flat-box"></span></a></li>
				
				<li class="s-menu"><a href="javascript:void(0)"><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class="nav-sub container container--flex">
			<a class="logo" href="javascript:void(0)">
				Word of Forks
			</a>

			<ul class="switcher h-list">
				<li class="s-comment"><a href="javascript:void(0)"><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class="s-top"><a href="javascript:void(0)"><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class="s-toc"><a href="javascript:void(0)"><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				首页
			</a>
		
			<a href="/archives" class="nav-archives nav">
				存档
			</a>
		
			<a href="/categories" class="nav-categories nav">
				分类
			</a>
		
			<a href="/tags" class="nav-tags nav">
				标签
			</a>
		
			<a href="/about" class="nav-about nav">
				关于
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
	
  <script>
    window.subData= { title:'Year : 2019.4'}
  </script>

<section class="post-list">
	
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="基于AngularJS的企业软件前端架构"><a href="#基于AngularJS的企业软件前端架构" class="headerlink" title="基于AngularJS的企业软件前端架构"></a>基于AngularJS的企业软件前端架构</h1><p>这篇是我参加QCon北京2014的演讲内容：</p>
<h2 id="提纲："><a href="#提纲：" class="headerlink" title="提纲："></a>提纲：</h2><p>企业应用在软件行业中占有很大的比重，而这类软件多数现在也都采用B/S的模式开发，在这个日新月异的时代，它们的前端开发技术找到了什么改进点呢？</p>
<p>B/S企业软件前端开发模式大体上与桌面软件类似，都是偏重量级的，在前端可能会有较多的业务逻辑，这些业务逻辑如何被合理模块化，与界面分离，以便测试，成为这个领域的一个重要挑战。另一方面，由于企业应用的界面相对规整，偏重的是数据存取，没有太多花哨的东西，所以常见的界面控件也是可枚举的，如何让开发界面的工作能更快完成，甚至由不擅长编写代码的业务设计人员来做，与界面原型的工作合二为一，能提高不少开发效率。</p>
<p>在AngularJS等MV*框架出现之后，给这个领域带来一些契机，架构师们能够有机会去重新规划前端的架构，甚至是开发流程，从而让整个软件的生产更为高效。</p>
<p>本文将探讨它给这个领域带来的变化。<br>

    
	  <div class="readmore">
      <a href="/2019/04/13/杂谈/2014-04-27-基于AngularJS的企业软件前端架构/">Read More</a>
    </div>
    
    
    
  </p></section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="2015前端组件化框架之路"><a href="#2015前端组件化框架之路" class="headerlink" title="2015前端组件化框架之路"></a>2015前端组件化框架之路</h1><h1 id="1-为什么组件化这么难做"><a href="#1-为什么组件化这么难做" class="headerlink" title="1. 为什么组件化这么难做"></a>1. 为什么组件化这么难做</h1><p>Web应用的组件化是一个很复杂的话题。</p>
<p>在大型软件中，组件化是一种共识，它一方面提高了开发效率，另一方面降低了维护成本。但是在Web前端这个领域，并没有很通用的组件模式，因为缺少一个大家都能认同的实现方式，所以很多框架/库都实现了自己的组件化方式。</p>
<p>前端圈最热衷于造轮子了，没有哪个别的领域能出现这么混乱而欣欣向荣的景象。这一方面说明前端领域的创造力很旺盛，另一方面却说明了基础设施是不完善的。</p>
<p>我曾经有过这么一个类比，说明某种编程技术及其生态发展的几个阶段：</p>
<ul>
<li>最初的时候人们忙着补全各种API，代表着他们拥有的东西还很匮乏，需要在语言跟基础设施上继续完善</li>
<li>然后就开始各种模式，标志他们做的东西逐渐变大变复杂，需要更好的组织了</li>
<li>然后就是各类分层MVC，MVP，MVVM之类，可视化开发，自动化测试，团队协同系统等等，说明重视生产效率了，也就是所谓工程化</li>
</ul>
<p>那么，对比这三个阶段，看看关注这三种东西的人数，觉得Web发展到哪一步了？</p>
<p>细节来说，大概是模块化和组件化标准即将大规模落地（好坏先不论），各类API也大致齐备了，终于看到起飞的希望了，各种框架几年内会有非常强力的洗牌，如果不考虑老旧浏览器的拖累，这个洗牌过程将大大加速，然后才能释放Web前端的产能。</p>
<p>但是我们必须注意到，现在这些即将普及的标准，很多都会给之前的工作带来改变。用工业体系的发展史来对比，前端领域目前正处于蒸汽机发明之前，早期机械（比如《木兰辞》里面的机杼，主要是动力与材料比较原始）已经普及的这么一个阶段。</p>
<p>所以，从这个角度看，很多框架/库是会消亡的（专门做模块化的AMD和CMD相关库，专注于标准化DOM选择器铺垫的某些库），一些则必须进行革新，还有一些受的影响会比较小（数据可视化等相关方向），可以有机会沿着自己的方向继续演进。</p>
<h1 id="2-标准的变革"><a href="#2-标准的变革" class="headerlink" title="2. 标准的变革"></a>2. 标准的变革</h1><p>对于这类东西来说，能获得广泛群众基础的关键在于：对将来的标准有怎样的迎合程度。对前端编程方式可能造成重大影响的标准有这些：</p>
<ul>
<li>module</li>
<li>Web Components</li>
<li>class</li>
<li>observe</li>
<li>promise</li>
</ul>
<p>module的问题很好理解，JavaScript第一次有了语言上的模块机制，而Web Components则是约定了基于泛HTML体系构建组件库的方式，class增强了编程体验，observe提供了数据和展现分离的一种优秀方式，promise则是目前前端最流行的异步编程方式。</p>
<p>这里面只有两个东西是绕不过去的，一是module，一是Web Components。前者是模块化基础，后者是组件化的基础。</p>
<p>module的标准化，主要影响的是一些AMD/CMD的加载和相关管理系统，从这个角度来看，正如seajs团队的@afc163 所说，不管是AMD还是CMD，都过时了。</p>
<p>模块化相对来说，迁移还比较容易，基本只是纯逻辑的包装，跟AMD或者CMD相比，包装形式有所变化，但组件化就是个比较棘手的问题了。</p>
<p>Web Components提供了一种组件化的推荐方式，具体来说，就是：</p>
<ul>
<li>通过shadow DOM封装组件的内部结构</li>
<li>通过Custom Element对外提供组件的标签</li>
<li>通过Template Element定义组件的HTML模板</li>
<li>通过HTML imports控制组件的依赖加载</li>
</ul>
<p>这几种东西，会对现有的各种前端框架/库产生很巨大的影响：</p>
<ul>
<li>由于shadow DOM的出现，组件的内部实现隐藏性更好了，每个组件更加独立，但是这使得CSS变得很破碎，LESS和SASS这样的样式框架面临重大挑战。</li>
<li>因为组件的隔离，每个组件内部的DOM复杂度降低了，所以选择器大多数情况下可以限制在组件内部了，常规选择器的复杂度降低，这会导致人们对jQuery的依赖下降。</li>
<li>又因为组件的隔离性加强，致力于建立前端组件化开发方式的各种框架/库（除Polymer外），在自己的组件实现方式与标准Web Components的结合，组件之间数据模型的同步等问题上，都遇到了不同寻常的挑战。</li>
<li>HTML imports和新的组件封装方式的使用，会导致之前常用的以JavaScript为主体的各类组件定义方式处境尴尬，它们的依赖、加载，都面临了新的挑战，而由于全局作用域的弱化，请求的合并变得困难得多。</li>
</ul>
<h1 id="3-当下最时髦的前端组件化框架-库"><a href="#3-当下最时髦的前端组件化框架-库" class="headerlink" title="3. 当下最时髦的前端组件化框架/库"></a>3. 当下最时髦的前端组件化框架/库</h1><p>在2015年初这个时间点看，前端领域有三个框架/库引领时尚，那就是Angular，Polymer，React（排名按照首字母），在知乎的这篇<a href="http://www.zhihu.com/question/26644904/answer/33634518" target="_blank" rel="noopener">2014 年末有哪些比较火的 Web 开发技术？</a>里，我大致回答过一些点，其他几位朋友的答案也很值得看。关于这三者的细节分析，<strong>侯振宇</strong>的这篇讲得很好：<a href="http://www.cnblogs.com/sskyy/p/4264371.html" target="_blank" rel="noopener">2015前端框架何去何从</a></p>
<p>我们可以看到，Polymer这个东西在这方面是有先天优势的，因为它的核心理念就是基于Web Components的，也就是说，它基本没有考虑如何解决当前的问题，直接以未来为发展方向了。</p>
<p>React的编程模式其实不必特别考虑Web标准，它的迁移成本并不算高，甚至由于其实现机制，屏蔽了UI层实现方式，所以大家能看到在native上的使用，canvas上的使用，这都是与基于DOM的编程方式大为不同的，所以对它来说，处理Web Components的兼容问题要在封装标签的时候解决，反正之前也是要封装。</p>
<p>Angular 1.x的版本，可以说是跟同时代的多数框架/库一样，对未来标准的兼容基本没有考虑，但是重新规划之后的2.0版本对此有了很多权衡，变成了激进变更，突然就变成一个未来的东西了。</p>
<p>这三个东西各有千秋，在可以预见的几年内将会鼎足三分，也许还会有新的框架出现，能不能比这几个流行就难说了。</p>
<p>此外，原Angular 2.0的成员Rob Eisenberg创建了自己的新一代框架<a href="http://aurelia.io/" target="_blank" rel="noopener">aurelia</a>，该框架将成为Angular 2.0强有力的竞争者。</p>
<h1 id="4-前端组件的复用性"><a href="#4-前端组件的复用性" class="headerlink" title="4. 前端组件的复用性"></a>4. 前端组件的复用性</h1><p>看过了已有的一些东西之后，我们可以大致来讨论一下前端组件化的一些理念。假设我们有了某种底层的组件机制，先不管它是浏览器原生的，或者是某种框架/库实现的约定，现在打算用它来做一个大型的Web应用，应该怎么做呢？</p>
<p>所谓组件化，核心意义莫过于提取真正有复用价值的东西。那怎样的东西有复用价值呢？</p>
<ul>
<li>控件</li>
<li>基础逻辑功能</li>
<li>公共样式</li>
<li>稳定的业务逻辑</li>
</ul>
<p>对于控件的可复用性，基本上是没有争议的，因为这是实实在在的通用功能，并且比较独立。</p>
<p>基础逻辑功能主要指的是一些与界面无关的东西，比如underscore这样的辅助库，或者一些校验等等纯逻辑功能。</p>
<p>公共样式的复用性也是比较容易认可的，因此也会有bootstrap，foundation，semantic这些东西的流行，不过它们也不是纯粹的样式库了，也带有一些小的逻辑封装。</p>
<p>最后一块，也就是业务逻辑。这一块的复用是存在很多争议的，一方面是，很多人不认同业务逻辑也需要组件化，另一方面，这块东西究竟怎样去组件化，也很需要思考。</p>
<p>除了上面列出的这些之外，还有大量的业务界面，这块东西很显然复用价值很低，基本不存在复用性，但仍然有很多方案中把它们“组件化”了，使得它们成为了“不具有复用性的组件”。为什么会出现这种情况呢？</p>
<p>组件化的本质目的并不一定是要为了可复用，而是提升可维护性。这一点正如面向对象语言，Java要比C++纯粹，因为它不允许例外情况的出现，连main函数都必须写到某个类里，所以Java是纯面向对象语言，而C++不是。</p>
<p>在我们这种情况下，也可以把组件化分为：全组件化，局部组件化。怎么理解这两个东西的区别呢，有人问过js框架和库的区别是什么，一般来说，有某种较强约定的东西，称为框架，而约定比较松散的，称为库。框架很多都是有全组件化理念的，比如说，很多年前就出现的ExtJS，它是全组件化框架，而jQuery和它的插件体系，则是局部组件化。所以用ExtJS写东西，不管写什么都是差不多一样的写法，而用jQuery的时候，大部分地方是原始HTML，哪里需要有些不一样的东西，就只在那个地方调用插件做一下特殊化。</p>
<p>对于一个有一定规模的Web应用来说，把所有东西都“组件化”，在管理上会有较大的便利性。我举个例子，同样是编写代码，短代码明显比长代码的可读性更高，所以很多语言里会建议“一个方法一般不要超过多少行，一个类最好不要超过多少行”之类。在Web前端这个体系里，JavaScript这块是做得相对较好的，现在入门水平的人，也已经很少会有把一堆js都写在一起的了。CSS这块，最近在SASS，LESS等框架的引领下，也逐步往模块化方面发展，否则直接编写bootstrap那种css，会非常痛苦。</p>
<p>这个时候我们再看HTML的部分，如果不考虑模板等技术的使用，某些界面光布局代码写起来就非常多了，像一些表单，都需要一层套一层，很多简单的表单元素都需要套个三层左右，更不必说一些有复杂布局的东西了。尤其是整个系统单页化之后，界面的header，footer，各种nav或者aside，很可能都有一定复杂性。如果这些东西的代码不作切分，那么主界面的HTML一定比较难看。</p>
<p>我们先不管用什么方式切分了，比如用某种模板，用类似Angular中的include，或者Polymer，React中的标签，或者直接使用原生Web Components，总之是把一块一块都拆开了，然后包含进来。从这个角度看，这些拆出去的东西都像组件，但如果从复用性的角度看，很可能多数东西，每一块都只有一个地方用，压根没有复用度。这个拆出去，纯粹是为了使得整个工程易于管理，易于维护。</p>
<p>这时候我们再来关注不同框架/库对UI层组件化的处理方式，发现有两个类型，模板和函数。</p>
<p>模板是一种很常见的东西，它用HTML字符串的方式表达界面的原始结构，然后通过代入数据的方式生成真正的界面，有的是生成目标HTML，有的还生成各种事件的自动绑定。前者是静态模板，后者是动态模板。</p>
<p>另外有一些框架/库偏爱用函数逻辑来生成界面，早期的ExtJS，现在的React（它内部还是可能使用模板，而且对外提供的是组件创建接口的进一步封装——jsx）等，这种实现技术的优势是不同平台上编程体验一致，甚至可以给每种平台封装相同的组件，调用方轻松写一份代码，在Web和不同Native平台上可用。但这种方式也有比较麻烦的地方，那就是界面调整比较繁琐。</p>
<p>本文前面部分引用<strong>侯振宇</strong>的那篇文章里，他提出这些问题：</p>
<blockquote>
<p>如何能把组件变得更易重用? 具体一点:</p>
<ul>
<li>我在用某个组件时需要重新调整一下组件里面元素的顺序怎么办?</li>
<li>我想要去掉组件里面某一个元素怎么办?<br>如何把组件变得更易扩展? 具体一点:</li>
<li>业务方不断要求给组件加功能怎么办?</li>
</ul>
</blockquote>
<p>为此，还提出了“模板复写”方案，在这一点上我有不同意见。</p>
<p>我们来看看如何把一个业务界面切割成组件。</p>
<p>有这么一个简单场景：一个雇员列表界面包括两个部分，雇员表格和用于填写雇员信息的表单。在这个场景下，存在哪些组件？</p>
<p>对于这个问题，主要存在两种倾向，一种是仅仅把“控件”和比较有通用性的东西封装成组件，另外一种是整个应用都组件化。</p>
<p>对前一种方式来说，这里面只存在数据表格这么一个组件。<br>对后一种方式来说，这里面有可能存在：数据表格，雇员表单，甚至还包括雇员列表界面这么一个更大的组件。</p>
<p>这两种方式，就是我们之前所说的“局部组件化”，“全组件化”。</p>
<p>我们前面提到，全组件化在管理上是存在优势的，它可以把不同层面的东西都搞成类似结构，比如刚才的这个业务场景，很可能最后写起来是这个样子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Employee-Panel</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Employee-List</span>&gt;</span><span class="tag">&lt;/<span class="name">Employee-List</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Employee-Form</span>&gt;</span><span class="tag">&lt;/<span class="name">Employee-Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Employee-Panel</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于UI层，最好的组件化方式是标签化，比如上面代码中就是三个标签表达了整个界面。但我个人坚决反对滥用标签，并不是把各种东西都尽量封装就一定好。</p>
<p>全标签化的问题主要有这些：</p>
<p>第一，语义化代价太大。只要用了标签，就一定需要给它合适的语义，也就是命名。但实际用的时候，很可能只是为了把一堆html简化一下而已，到底简化出来的那东西应当叫什么名字，光是起名也费不知多少脑细胞。比如你说雇员管理的表单，这个表单有heading吗，有footer吗，能折叠吗，等等，很难起一个让别人一看就知道的名字，要么就是特别长。这还算简单的，因为我们是全组件化，所以很可能会有组合了多种东西的一个较复杂的界面，你想来想去也没法给它起个名字，于是写了个：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这尼玛……可能我夸张了点，但很多时候项目规模够大，你不起这么复杂的名字，最后很可能没法跟功能类似的一个组件区分开，因为这些该死的组件都存在于同一个命名空间中。如果仅仅是当作一个界面片段来include，就不存在这种心理负担了。</p>
<p>比如Angular里面的这种：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-include</span>=<span class="string">"'aaa/bbb/ccc.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就不给它什么名字，直接include进来，用文件路径来区分。这个片段的作用可以用其目录结构描述，也就是通过物理名而非逻辑名来标识，目录层次充当了一个很好的命名空间。</p>
<p>现在的一些主流MVVM框架，比如knockout，angular，avalon，vue等等，都有一种“界面模板”，但这种模板并不仅仅是模板，而是可以视为一种配置文件。某一块界面模板描述了自身与数据模型的关系，当它被解析之后，按照其中的各种设置，与数据建立关联，并且反过来再更新自身所对应的视图。</p>
<p>不含业务逻辑的UI（或者是业务逻辑已分离的UI）基本不适合作为组件来看待，因为即使在逻辑不变的情况下，界面改版的可能性也太多了。比如即使是换了新的CSS实现方式，从float布局改成flex布局，都有可能把DOM结构少套几层div，因此，在使用模板的方案中，只能把界面层视为配置文件，不能看成组件，如果这么做，就会轻松很多。</p>
<p>部队行军的时候讲究“逢山开路，遇水搭桥”，这句话的重点在于只有到某些地形才开路搭桥，使用MVVM这类模式解决的业务场景，多数时候是一马平川，横着走都可以，不必硬要造路。所以从整个方案看的话，UI层实现应该是模板与控件并存，大部分地方是模板，少数地方是需要单独花时间搞的路和桥。</p>
<p>第二，配置过于复杂。有很多东西其实不太适合封装，不但封装的代价大，使用的代价也会很大。有时候会发现，调用代码的绝大部分都是在写各种配置。</p>
<p>就像刚才的雇员表单，既然你不从标签的命名上去区分，那一定会在组件上加配置。比如你原来想这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EmployeeForm</span> <span class="attr">heading</span>=<span class="string">"雇员表单"</span>&gt;</span><span class="tag">&lt;/<span class="name">EmployeeForm</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在组件内部，判断有没有设置heading，如果没有就不显示，如果有，就显示。过了两天，产品问能不能把heading里面的某几个字加粗或者换色，然后码农开始允许这个heading属性传入html。没多久之后，你会惊奇地发现有人用你的组件，没跟你说，就在heading里面传入了折叠按钮的html，并且用选择器给折叠按钮加了事件，点一下之后还能折叠这个表单了……</p>
<p>然后你一想，这个不行，我得给他再加个配置，让他能很简单地控制折叠按钮的显示，但是现在这么写太不直观，于是采用对象结构的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EmployeeForm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Option</span> <span class="attr">collapsible</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Heading</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>雇员<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>表单<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Heading</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">EmployeeForm</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后又有一天，发现有很多面板都可以折叠，然后特意创建了一个可折叠面板组件，又创建了一种继承机制，其他普通业务面板从它继承，从此一发不可收拾。</p>
<p>我举这例子的意思是为了说明什么呢，我想说，在规模较大的项目中，企图用全标签化加配置的方式来描述所有的普通业务界面，是一定事倍功半的，并且这个规模越大就越坑，这也正是ExtJS这类对UI层封装过度的体系存在的最大问题。</p>
<p>这个问题讨论完了，我们来看看另外一个问题：如果UI组件有业务逻辑，应该如何处理。</p>
<p>比如说，性别选择的下拉框，它是一个非常通用化的功能，照理说是很适合被当做组件来提供的。但是究竟如何封装它，我们就有些犯难了。这个组件里除了界面，还有数据，这些数据应当内置在组件里吗？理论上从组件的封装性来说，是都应当在里面的，于是就这么造了一个组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GenderSelect</span>&gt;</span><span class="tag">&lt;/<span class="name">GenderSelect</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个组件非常美好，只需直接放在任意的界面中，就能显示带有性别数据的下拉框了。性别的数据很自然地是放在组件的实现内部，一个写死的数组中。这个太简单了，我们改一下，改成商品销售的国家下拉框。</p>
<p>表面上看，这个没什么区别，但我们有个要求，本公司商品销售的国家的信息是统一配置的，也就是说，这个数据来源于服务端。这时候，你是不是想把一个http请求封装到这组件里？</p>
<p>这样做也不是不可以，但存在至少两个问题：</p>
<ul>
<li>如果这类组件在同一个界面中出现多次，就可能存在请求的浪费，因为有一个组件实例就会产生一个请求。</li>
<li>如果国家信息的配置界面与这个组件同时存在，当我们在配置界面中新增一个国家了，下拉框组件中的数据并不会实时刷新。</li>
</ul>
<p>第一个问题只是资源的浪费，第二个就是数据的不一致了。曾经在很多系统中，大家都是手动刷新当前页面来解决这问题的，但到了这个时代，人们都是追求体验的，在一个全组件化的解决方案中，不应再出现此类问题。</p>
<p>如何解决这样的问题呢？那就是引入一层Store的概念，每个组件不直接去到服务端请求数据，而是到对应的前端数据缓存中去获取数据，让这个缓存自己去跟服务端保持同步。</p>
<p>所以，在实际做方案的过程中，不管是基于Angular，React，Polymer，最后肯定都做出一层Store了，不然会有很多问题。</p>
<h1 id="5-为什么MVVM是一种很好的选择"><a href="#5-为什么MVVM是一种很好的选择" class="headerlink" title="5. 为什么MVVM是一种很好的选择"></a>5. 为什么MVVM是一种很好的选择</h1><p>我们回顾一下刚才那个下拉框的组件，发现存在几个问题：</p>
<ul>
<li>界面不好调整。刚才的那个例子相对简单，如果我们是一个省市县三级联动的组件，就比较麻烦了。比如说，我们想要把水平布局改成垂直的，又或者，想要把中间的label的字改改，都会非常麻烦。按照传统的做组件的方式，就要加若干配置项，然后组件里面去分别判断，修改DOM结构。</li>
<li>如果数据的来源不是静态json，而是某个动态的服务接口，那用起来就很麻烦。</li>
<li>我们更多地需要业务逻辑的复用和纯“控件”的复用，至于那些绑定业务的界面组件，复用性其实很弱。</li>
</ul>
<p>所以，从这些角度，会尽量期望在HTML界面层与JavaScript业务逻辑之间，存在一种分离。</p>
<p>这时候，再看看绝大多数界面组件存在什么问题：</p>
<p>有时候我们考虑一下DOM操作的类型，会发现其实是很容易枚举的：</p>
<ul>
<li>创建并插入节点</li>
<li>移除节点</li>
<li>节点的交换</li>
<li>属性的设置</li>
</ul>
<p>多数界面组件封装的绝大部分内容不过是这些东西的重复。这些东西，其实是可以通过某些配置描述出来的，比如说，某个数组以什么形式渲染成一个select或者无序列表之类，当数组变动，这些东西也跟着变动，这些都应当被自动处理，如果某个方案在现在这个时代还手动操作这些，那真的是一种落伍。</p>
<p>所以我们可以看到，以Angular，Knockout，Vue，Avalon为代表的框架们在这方面做了很多事，尽管理念有所差异，但大方向都非常一致，也就是把大多数命令式的DOM操作过程简化为一些配置。</p>
<p>有了这种方式之后，我们可以追求不同层级的复用：</p>
<ul>
<li>业务模型因为是纯逻辑，所以非常容易复用</li>
<li>视图模型基本上也是纯逻辑，界面层多数是纯字符串模板，同一个视图模型搭配不同的界面模板，可以实现视图模型的复用</li>
<li>同一个界面模板与不同的视图模型组合，也能直接组合出完全不同的东西</li>
</ul>
<p>所以这么一来，我们的复用粒度就非常灵活了。正因为这样，我一直认为Angular这样的框架战略方向是很正确的，虽然有很多战术失误。我们在很多场景下，都是需要这样的高效生产手段的。</p>
<h1 id="6-组件的长期积累"><a href="#6-组件的长期积累" class="headerlink" title="6. 组件的长期积累"></a>6. 组件的长期积累</h1><p>我们做组件化这件事，一定是一种长期打算，为了使得当前的很多东西可以作为一种积累，在将来还能继续使用，或者仅仅作较小的修改就能使用，所以必须考虑对未来标准的兼容。主要需要考虑的方面有这几点：</p>
<ul>
<li>尽可能中立于语言和框架，使用浏览器的原生特性</li>
<li>逻辑层的模块化（ECMAScript module）</li>
<li>界面层的元素化（Web Components）</li>
</ul>
<p>之前有很多人对Angular 2.0的激进变更很不认同，但它的变更很大程度上是对标准的全面迎合。这不仅仅是它的问题，其实是所有前端框架的问题。不面对这些问题，不管现在多么好，将来都是死路一条。这个问题的根源是，这几个已有的规范约束了模块化和元素化的推荐方式，并且，如果要对当前和未来两边做适配的话，基本就没法干了，导致以前的都不得不做一定的迁移。</p>
<p>模块化的迁移成本还比较小，无论是之前AMD还是CMD的，都可以根据一些规则转换过来，但组件化的迁移成本太大了，几乎每种框架都会提出自己的理念，然后有不同的组件化理念。</p>
<p>还是从三个典型的东西来说：Polymer，React，Angular。</p>
<p>Polymer中的组件化，其实就是标签化。这里的标签，并不只是界面元素，甚至逻辑组件也可以这样，比如这个代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-panel</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">core-ajax</span> <span class="attr">id</span>=<span class="string">"ajax"</span> <span class="attr">url</span>=<span class="string">"http://url"</span> <span class="attr">params</span>=<span class="string">"&#123;&#123;formdata&#125;&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">core-ajax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-panel</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到这里的core-ajax标签，很明显这已经是纯逻辑的了，在大多数前端框架或者库中，调用ajax肯定不是这样的，但在浏览器端这么干也不是它独创，比如flash里面的WebService，比如早期IE中基于htc实现的webservice.htc等等，都是这么干的。在Polymer中，这类东西称为非可见元素（non-visual-element）。</p>
<p>React的组件化，跟Polymer略有不同，它的界面部分是标签化，但如果有单纯的逻辑，还是纯JavaScript模块。</p>
<p>既然大家的实现方式都那么不一致，那我们怎么搞出尽量可复用的组件呢？问题到最后还是要绕到Web Components上。</p>
<p>在Web Components与前端组件化框架的关系上，我觉得是这么个样子：</p>
<p>各种前端组件化框架应当尽可能以Web Components为基石，它致力于组织这些Components与数据模型之间的关系，而不去关注某个具体Component的内部实现，比如说，一个列表组件，它究竟内部使用什么实现，组件化框架其实是不必关心的，它只应当关注这个组件的数据存取接口。</p>
<p>然后，这些组件化框架再去根据自己的理念，进一步对这些标准Web Components进行封装。换句话说，业务开发人员使用某个组件的时候，他是应当感知不到这个组件内部究竟使用了Web Components，还是直接使用传统方式。（这一点有些理想化，可能并不是那么容易做到，因为我们还要管理像import之类的事情）。</p>
<h1 id="7-我们需要关注什么"><a href="#7-我们需要关注什么" class="headerlink" title="7. 我们需要关注什么"></a>7. 我们需要关注什么</h1><p>目前来看，前端框架/库仍然处于混战期，可比中国历史上的春秋战国，百家齐放，作为跟随者来说，这是很痛苦的，因为无所适从，很可能你作为一个企业的前端架构师或者技术经理，需要做一些选型工作，但选哪个能保证几年后不被淘汰呢？基本没有。</p>
<p>虽然我们不知道将来什么框架会流行，但我们可以从一些细节方面去关注，某个具体的方面，将来会有什么，也可以了解一下在某个具体领域存在什么样的方案。一个完整的框架方案，无非是以下多个方面的综合。</p>
<h2 id="7-1-模块化"><a href="#7-1-模块化" class="headerlink" title="7.1 模块化"></a>7.1 模块化</h2><p>这块还是不讲了，支付宝seajs还有百度ecomfe这两个团队的人应该都能比我讲得好得多。</p>
<h2 id="7-2-Web-Components"><a href="#7-2-Web-Components" class="headerlink" title="7.2 Web Components"></a>7.2 Web Components</h2><p>本文前面讨论过一些，也不深入了。</p>
<h2 id="7-3-变更检测"><a href="#7-3-变更检测" class="headerlink" title="7.3 变更检测"></a>7.3 变更检测</h2><p>我们知道，现代框架的一个特点是自动化，也就是把原有的一些手动操作提取。在前端编程中，最常见的代码是在干什么呢？读写数据和操作DOM。不少现代的框架/库都对这方面作了处理，比如说通过某种配置的方式，由框架自动添加一些关联，当数据变更的时候，把DOM进行相应修改，又比如，当DOM发生变动的时候，也更新对应的数据。</p>
<p>这个关联过程可能会用到几种技术。首先我们看怎么知道数据在变化，这里面有三种途径：</p>
<p>一、存取器的封装。这个的意思也就是对数据进行一层包装，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">	name: <span class="string">"aaa"</span>,</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;,</span><br><span class="line">	setName: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，不允许用户直接调用data.name，而是调用对应的两个函数。Backbone就是通过这样的机制实现数据变动观测的，这种方式适用于几乎所有浏览器，缺点就是比较麻烦，要对每个数据进行包装。</p>
<p>这个机制在稍微新一点的浏览器中，也有另外一种实现方式，那就是defineProperty相关的一些方法，使用更优雅的存取器，这样外界可以不用调用函数，而是直接用data.name这样进行属性的读写。</p>
<p>国产框架avalon使用了这个机制，低版本IE中没有defineProperty，但在低版本IE中不止有JavaScript，还存在VBScript，那里面有存取器，所以他巧妙地使用了VBS做了这么一个兼容封装。</p>
<p>基于存取器的机制还有个麻烦，就是每次动态添加属性，都必须再添加对应的存取器，否则这个属性的变更就无法获取。</p>
<p>二、脏检测。</p>
<p>以Angular 1.x为代表的框架使用了脏检测来获知数据变更，这个机制的大致原理是：</p>
<p>保存数据的新旧值，每当有一些DOM或者网络、定时器之类的事件产生，用这个事件之后的数据去跟之前保存的数据进行比对，如果相同，就不触发界面刷新，否则就刷新。</p>
<p>这个方式的理念是，控制所有可能导致数据变更的来源（也就是各种事件），在他们可能对数据进行操作之后，判断新旧数据是否有变化，忽略所有中间变更，也就是说，如果你在同一个事件中，把某个数据任意修改了很多次，但最后改回来了，框架会认为你什么都没干，也就不会通知界面去刷新了。</p>
<p>不可否认的是，脏检测的效率是比较低的，主要是不能精确获知数据变更的影响，所以当数据量更大的情况下，浪费更严重，需要手动作一些优化。比如说一个很大的数组，生成了一个界面上的列表，当某个项选中的时候，改变颜色。在这种机制下，每次改变这个项的数据状态，就需要把所有的项都跟原来比较一遍，然后，还要再全部比较一次发现没有关联引起的变化了，才能对应刷新界面。</p>
<p>三、观察机制。</p>
<p>在ES7里面，引入了Object的observe方法，可以用于监控对象或数组的变动。</p>
<p>这是目前为止最合理的观测方案。这个机制很精确高效，比如说，连长跟士兵说，你去观察对面那个碉堡里面的动静。这个含义很复杂，包括什么呢？</p>
<ul>
<li>是不是加人了</li>
<li>是不是有人离开了</li>
<li>谁跟谁换岗了</li>
<li>上面的旗子从太阳旗换成青天白日了</li>
</ul>
<p>所谓观察机制，也就是观测对象属性的变更，数组元素的新增，移除，位置变更等等。我们先思考一下界面和数据的绑定，这本来就应当是一个外部的观察，你是数据，我是界面，你点头我微笑，你伸手我打人。这种绑定本来就应当是个松散关系，不应当因为要绑定，需要破坏原有的一些东西，所以很明显更合理。</p>
<p>除了数据的变动可以被观察，DOM也是可以的。但是目前绝大多数双向同步框架都是通过事件的方式把DOM变更同步到数据上。比如说，某个文本框绑定了一个对象的属性，那很可能，框架内部是监控了这个文本框的键盘输入、粘贴等相关事件，然后取值去往对象里写。</p>
<p>这么做可以解决大部分问题，但是如果你直接myInput.value=”111”，这个变更就没法获取了。这个不算大问题，因为在一个双向绑定框架中，一个既被监控，又手工赋值的东西，本身也比较怪，不过也有一些框架会尝试从HTMLInputELement的原型上去覆盖value赋值，尝试把这种东西也纳入框架管辖范围。</p>
<p>另外一个问题，那就是我们只考虑了特定元素的特定属性，可以通过事件获取变更，如何获得更广泛意义上的DOM变更？比如说，一般属性的变更，或者甚至子节点的增删？</p>
<p>DOM4引入了MutationObserver，用于实现这种变更的观测。在DOM和数据之间，是否需要这么复杂的观测与同步机制，目前尚无定论，但在整个前端开发逐步自动化的大趋势下，这也是一种值得尝试的东西。</p>
<p>复杂的关联监控容易导致预期之外的结果：</p>
<ul>
<li>慕容复要复国，每天读书练武，各种谋划</li>
<li>王语嫣观察到了这种现象，认为表哥不爱自己了</li>
<li>段誉看到神仙姐姐闷闷不乐，每天也茶饭不思</li>
<li>镇南王妃心疼爱子，到处调查这件事的原委，意外发现段正淳还跟旧爱有联系</li>
<li>……</li>
</ul>
<p>总之这么下来，最后影响到哪里了都不知道，谁让丘处机路过牛家村呢？</p>
<p>所以，变更的关联监控是很复杂的一个体系，尤其是其中产生了闭环的时候。搭建整个这么一套东西，需要极其精密的设计，否则熟悉整套机制的人只要用特定场景轻轻一推就倒了。灵智上人虽然武功过人，接连碰到欧阳锋，周伯通，黄药师，全部都是上来就直接被抓了后颈要害，大致就是这意思。</p>
<p>polymer实现了一个<a href="https://github.com/Polymer/observe-js" target="_blank" rel="noopener">observe-js</a>，用于观测数组、对象和路径的变更，有兴趣的可以关注。</p>
<p>在有些框架，比如aurelia中，是混合使用了存取器和观察模式，把存取器作为观察模式的降级方案，在浏览器不支持observe的情况下使用。值得一提的是，在脏检测方式中，变更是合并后批量提交的，这一点常常被另外两种方案的使用者忽视。其实，即使用另外两种方式，也还是需要一个合并与批量提交过程。</p>
<p>怎么理解这个事情呢？数据的绑定，最终都是要体现到界面上的，对于界面来说，其实只关注你每一次操作所带来的数据变更的始终，并不需要关心中间过程。比如说，你写了这么一个循环，放在某个按钮的点击中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">	obj.a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>界面有一个东西绑定到这个a，对框架来说，绝对不应当把中间过程直接应用到界面上，以刚才这个例子来说，合理的情况只应当存在一次对界面DOM的赋值，这个值就是对obj.a进行了10000次赋值之后的值。尽管用存取器或者观察模式，发现了对obj上a属性的这10000次赋值过程，这些赋值还是都必须被舍弃，否则就是很可怕的浪费。</p>
<p>React使用虚拟DOM来减少中间的DOM操作浪费，本质跟这个是一样的，界面只应当响应逻辑变更的结束状态，不应当响应中间状态。这样，如果有一个ul，其中的li绑定到一个1000元素的数组，当首次把这个数组绑定到这个ul上的时候，框架内部也是可以优化成一次DOM写入的，类似之前常用的那种DocumentFragment，或者是innerHTML一次写入整个字符串。在这个方面，所有优化良好的框架，内部实现机制都应当类似，在这种方案下，是否使用虚拟DOM，对性能的影响都是很小的。</p>
<h2 id="7-4-Immutable-Data"><a href="#7-4-Immutable-Data" class="headerlink" title="7.4 Immutable Data"></a>7.4 Immutable Data</h2><p>Immutable Data是函数式编程中的一个概念，在前端组件化框架中能起到一些很独特的作用。</p>
<p>它的大致理念是，任何一种赋值，都应当被转化成复制，不存在指向同一个地方的引用。比如说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a==b);</span><br></pre></td></tr></table></figure>
<p>这个我们都知道，b跟a的内存地址是不一致的，简单类型的赋值会进行复制，所以a跟b不相等。但是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	counter : <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">b.counter++;</span><br><span class="line"><span class="built_in">console</span>.log(a.counter==b.counter);</span><br></pre></td></tr></table></figure>
<p>这时候因为a和b指向相同的内存地址，所以只要修改了b的counter，a里面的counter也会跟着变。</p>
<p>Immutable Data的理念是，我能不能在这种赋值情况下，直接把原来的a完全复制一份给b，然后以后大家各自变各自的，互相不影响。光凭这么一句话，看不出它的用处，看例子：</p>
<p>对于全组件化的体系，不可避免会出现很多嵌套的组件。嵌套组件是一个很棘手的问题，在很多时候，是不太好处理的。嵌套组件所存在的问题主要在于生命周期的管理和数据的共享，很多已有方案的上下级组件之间都是存在数据共享的，但如果内外层存在共享数据，那么就会破坏组件的独立性，比如下面的一个列表控件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-list</span> <span class="attr">list-data</span>=<span class="string">"&#123;arr&#125;"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">my-listitem</span>&gt;</span><span class="tag">&lt;/<span class="name">my-listitem</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">my-listitem</span>&gt;</span><span class="tag">&lt;/<span class="name">my-listitem</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">my-listitem</span>&gt;</span><span class="tag">&lt;/<span class="name">my-listitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在赋值的时候，一般是在外层整体赋值一个类似数组的数据，而不是自己挨个在每个列表项上赋值，不然就很麻烦。但是如果内外层持有相同的引用，对组件的封装性很不利。</p>
<p>比如在刚才这个例子里，假设数据源如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">	&#123;<span class="attr">name</span>: <span class="string">"Item1"</span>&#125;, </span><br><span class="line">	&#123;<span class="attr">name</span>: <span class="string">"Item2"</span>&#125;, </span><br><span class="line">	&#123;<span class="attr">name</span>: <span class="string">"Item3"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>通过类似这样的方式赋值给界面组件，并且由它在内部给每个子组件分别进行数据项的赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.data = arr;</span><br></pre></td></tr></table></figure>
<p>赋值之后会有怎样的结果呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(list.data == arr);</span><br><span class="line"><span class="built_in">console</span>.log(listitem0.data == arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(listitem1.data == arr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(listitem2.data == arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>这种方案里面，后面那几个log输出的结果都会是true，意思就是内层组件与外层共享数据，一旦内层组件对数据进行改变，外层中的也就改变了，这明显是违背组件的封装性的。</p>
<p>所以，有一些方案会引入Immutable Data的概念。在这些方案里，内外层组件的数据是不共享的，它们的引用不同，每个组件实际上是持有了自己的数据，然后引入了自动的赋值机制。</p>
<p>这时候再看看刚才那个例子，就会发现两层的职责很清晰：</p>
<ul>
<li>外层持有一个类似数组的东西arr，用于形成整个列表，但并不关注每条记录的细节</li>
<li>内层持有某条记录，用于渲染列表项的界面</li>
<li>在整个列表的形成过程中，list组件根据arr的数据长度，实例化若干个listitem，并且把arr中的各条数据赋值给对应的listitem，而这个赋值，就是immutable data起作用的地方，其实是把这条数据复制了一份给里面，而不是把外层这条记录的引用赋值进去。内层组件发现自己的数据改变之后，就去进行对应的渲染</li>
<li>如果arr的条数变更了，外层监控这个数据，并且根据变更类型，添加或者删除某个列表项</li>
<li>如果从外界改变了arr中某一条记录的内容，外层组件并不直接处理，而是给对应的内层进行了一次赋值</li>
<li>如果列表项中的某个操作，改变了自身的值，它首先是把自己持有的数据进行改变，然后，再通过immutable data把数据往外同步一份，这样，外层组件中的数据也就更新了。</li>
</ul>
<p>所以我们再看这个过程，真是非常清晰明了，而且内外层各司其职，互不干涉。这是非常有利于我们打造一个全组件化的大型Web应用的。各级组件之间存在比较松散的联系，而每个组件的内部则是封闭的，这正是我们所需要的结果。</p>
<p>说到这里，需要再提一个容易混淆的东西，比如下面这个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">outer-component</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">inner-component</span>&gt;</span><span class="tag">&lt;/<span class="name">inner-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">outer-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们为了给inner-component做一些样式定位之类的事情，很可能在内外层组件之间再加一些额外的布局元素，比如变成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">outer-component</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">inner-component</span>&gt;</span><span class="tag">&lt;/<span class="name">inner-component</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">outer-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里中间多了一级div，也可能是若干级元素。如果有用过Angular 1.x的，可能会知道，假如这里面硬造一级作用域，搞个ng-if之类，就可能存在多级作用域的赋值问题。在上面这个例子里，如果在最外层赋值，数据就会是outer -&gt; div -&gt; inner这样，那么，从框架设计的角度，这两次赋值都应当是immutable的吗？</p>
<p>不是，第一次赋值是非immutable，第二次才需要是，immutable赋值应当仅存在于组件边界上，在组件内部不是特别有必要使用。刚才的例子里，依附于div的那层变量应当还是跟outer组件在同一层面，都属于outer组件的人民内部矛盾。</p>
<p>这里是facebook实现的<a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">immutable-js库</a></p>
<h2 id="7-5-Promise与异步"><a href="#7-5-Promise与异步" class="headerlink" title="7.5 Promise与异步"></a>7.5 Promise与异步</h2><p>前端一般都习惯于用事件的方式处理异步，但很多时候纯逻辑的“串行化”场景下，这种方式会让逻辑很难阅读。在新的ES规范里，也有yield为代表的各种原生异步处理方案，但是这些方案仍然有很大的理解障碍，流行度有限，很大程度上会一直停留在基础较好的开发人员手中。尤其是在浏览器端，它的受众应该会比node里面还要狭窄。</p>
<p>前端里面，处理连续异步消息的最能被广泛接受的方案是promise，我这里并不讨论它的原理，也不讨论它在业务中的使用，而是要提一下它在组件化框架内部所能起到的作用。</p>
<p>现在已经没有哪个前端组件化框架可以不考虑异步加载问题了，因为，在前端这个领域，加载就是一个绕不过去的坎，必须有了加载，才能有执行过程。每个组件化框架都不能阻止自己的使用者规模膨胀，因此也应当在框架层面提出解决方案。</p>
<p>我们可能会动态配置路由，也可能在动态加载的路由中又引入新的组件，如何控制这些东西的生命周期，值得仔细斟酌，如果在框架层面全异步化，对于编程体验的一致性是有好处的。将各类接口都promise化，能够在可维护性和可扩展性上提供较多便利。</p>
<p>我们之前可能熟知XMLHTTP这样的通信接口，这个东西虽然被广为使用，但是在优雅性等方面，存在一些问题，所以最近出来了替代方案，那就是fetch。</p>
<p>细节可以参见月影翻译的这篇<a href="http://www.w3ctech.com/topic/854" target="_blank" rel="noopener">【翻译】这个API很“迷人”——(新的Fetch API)</a></p>
<p>在不支持的浏览器上，也有github实现的一个polyfill，虽然不全，但可以凑合用<a href="https://github.com/github/fetch" target="_blank" rel="noopener">window.fetch polyfill</a></p>
<p>大家可以看到，fetch的接口就是基于promise的，这应当是前端开发人员最容易接受的方案了。</p>
<h1 id="7-6-Isomorphic-JavaScript"><a href="#7-6-Isomorphic-JavaScript" class="headerlink" title="7.6 Isomorphic JavaScript"></a>7.6 Isomorphic JavaScript</h1><p>这个东西的意思是前后端同构的JavaScript，也就是说，比如一块界面，可以选择在前端渲染，也可以选择在后端渲染，值得关注，可以解决像seo之类的问题，但现在还不能处理很复杂的状况，持续关注吧。</p>
<h1 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h1><p>很感谢能看到这里，以上这些是我近一年的一些思考总结。从技术选型的角度看，做大型Web应用的人会很痛苦，因为这是一个青黄不接的年代，目前已有的所有框架/库都存在不同程度的缺陷。当你向未来看去，发现它们都是需要被抛弃，或者被改造的，人最痛苦的是在知道很多东西不好，却又要从中选取一个来用。@严清 跟@寸志 @题叶讨论过这个问题，认为现在这个阶段的技术选型难做，不如等一阵，我完全赞同他们的观点。</p>
<p>选型是难，但是从学习的角度，可真的是挺好的时代，能学的东西太多了，我每天路上都在努力看有可能值得看的东西，可还是看不完，只能努力去跟上时代的步伐。</p>
<p>以下一段，与诸位共勉：</p>
<blockquote>
<p>It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way–in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.</p>
</blockquote>


    
    
    
  </section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="从零开始编写自己的JavaScript框架（一）"><a href="#从零开始编写自己的JavaScript框架（一）" class="headerlink" title="从零开始编写自己的JavaScript框架（一）"></a>从零开始编写自己的JavaScript框架（一）</h1><p>#1. 模块的定义和加载</p>
<p>##1.1 模块的定义</p>
<p>一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。</p>
<p>先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？</p>
<p>我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。</p>
<p>考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。<br>

    
	  <div class="readmore">
      <a href="/2019/04/13/杂谈/2013-07-01-从零开始编写自己的JavaScript框架（一）/">Read More</a>
    </div>
    
    
    
  </p></section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="前端开发技术的发展"><a href="#前端开发技术的发展" class="headerlink" title="前端开发技术的发展"></a>前端开发技术的发展</h1><p>前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了：</p>
<ul>
<li>专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。</li>
<li>VML和SVG等基于XML的描述图形的语言。</li>
<li>从属于XML体系的XML，XPath，DTD等技术。</li>
<li>用于支撑后端的ASP，JSP，ASP.net，PHP，nodejs等语言或者技术。</li>
<li>被第三方程序打包的一种类似浏览器的宿主环境，比如Adobe AIR和使用HyBird方式的一些开发技术，如PhoneGap（它使用Android中的WebView等技术，让开发人员使用传统Web开发技术来开发本地应用）</li>
<li>Adobe Flash，Flex，Microsoft Silverlight，Java Applet，JavaFx等RIA开发技术。</li>
</ul>
<p>本文从狭义的前端定义出发，探讨一下这方面开发技术的发展过程。<br>

    
	  <div class="readmore">
      <a href="/2019/04/13/杂谈/2013-01-14-前端开发技术的发展/">Read More</a>
    </div>
    
    
    
  </p></section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="清华故地重游"><a href="#清华故地重游" class="headerlink" title="清华故地重游"></a>清华故地重游</h1><p>2014年4月底在北京参加QCon，27号抽空回清华看了一遍，10多年没回来，很感慨，没想到正好还碰上校庆了。学校里面的路居然还记得，打车从东门进，到主楼附近下车了往里走，那些年的回忆涌上心头。</p>
<p>这是四教，入学时候英语分级考试就在这。第一节正式的课程：王致勇老师的《无机化学》也是在这里上。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu1fxhokj21kw166qti.jpg" alt="四教"></p>
<p>这是四教和五教中间的过道。有次下雪，同学提醒我小心点，我说，你见过龙王被水呛的吗？话音未落立刻摔在地上，被群嘲了。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu1h45ayj21kw1667wh.jpg" alt="四教五教中间的过道"></p>
<p>这是刚才的路口。有一次骑车路过，右前方的一个人急速左拐，我没刹得住车，撞在他后座，从他车上面飞了过去，手心都是血。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/6ecbbfd0gw1efwu0qk3msj21mg17ce81.jpg" alt="五教路口"></p>
<p>这是9号楼，计算机系的，后面是10号楼。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu0v6l8hj21mg17cnpd.jpg" alt="9号楼"></p>
<p>入学的时候在这个地方，有志愿者迎接新生。<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu1ot39kj21mg17cx6p.jpg" alt="入学迎新"></p>
<p>体育课一般在这上。<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu1jhoa5j21mg17cu0x.jpg" alt="体育课"></p>
<p>到东面来了，左边是9号楼，右边是10号楼，在这个楼下丢过好几辆自行车。<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu0tre1sj21mg17cu0x.jpg" alt="9号楼10号楼中间"></p>
<p>10号楼的门口，变成办公楼了。<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu0x1gglj21mg17ckjl.jpg" alt="10号楼"></p>
<p>10号楼427，从98年住到99年，进门左手边靠窗的上铺，现在是办公室了，没进去。<br><img src="http://ww2.sinaimg.cn/mw690/6ecbbfd0gw1efwu14qf6uj21mg17c1br.jpg" alt="427"></p>
<p>宿舍斜对面的洗手间，亮亮在这里一边洗衣服一边欢快唱歌，现在他是海归副教授了，当年也有唱ws歌的一面，哈哈。<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu13pyk9j21mg17cne6.jpg" alt="wc"></p>
<p>那时候宿舍没电话，家里打电话过来的时候，宿管喊427徐飞电话，然后一边答应说来了来了，一边飞奔下来。<br><img src="http://ww2.sinaimg.cn/mw690/6ecbbfd0gw1efwu15mv34j21mg17ch7k.jpg" alt="楼梯口"></p>
<p>这个地方以前是8食堂，在这吃饭次数很多。<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu0rxegtj21mg17ckjl.jpg" alt="原来的8食堂"></p>
<p>那时候这里是个小店，有卖汽水的，我这种乡下孩子从来没喝过芬达和苹果汁，西瓜汁，不知道那个叫什么，只见过可乐和雪碧，后来听到站在我前面的来自深圳的赵铌同学说，才学着说要苹果汁。<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu1e49v3j21mg17ckjl.jpg" alt="小卖部"></p>
<p>在这学排球的，学不会，被老师训，标语很震撼人心，每个人入学的时候都默默算了一下吧？<br><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu1i2esaj21mg17c7wh.jpg" alt="体育系"></p>
<p>那时候这里是平地，在这军训，很大一片操场。<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu1bret3j21mg17cb29.jpg" alt="东操场"></p>
<p>10食堂，做化学实验回来一般会在这吃饭，河对面的树林里当时有练某某功的，好奇围观了一次。<br><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu0ybl2xj21mg17ce81.jpg" alt="10食堂"></p>
<p>28号楼，机械系在里面，某师兄的宿舍在这。<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu126j1ej21mg17ckjl.jpg" alt="28号楼"></p>
<p>我们材料系在这，23号楼，住306，现在要刷卡进去，没能进。<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu0znzibj21mg17ce81.jpg" alt="23号楼"></p>
<p>23号楼背后,99年短学期有一次整个宿舍回来晚了,没喊宿管,武涛从这爬上去,然后挨个拉我们上去,那时候没有栏杆.<br><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu10wt2qj21mg17chdt.jpg" alt="23号楼背后"></p>
<p>这是14还是15食堂？经常跟材81的吴光麟一起在这吃。那会旁边有一个店卖饼干，3块一斤，很划算。<br><img src="http://ww2.sinaimg.cn/mw690/6ecbbfd0gw1efwu17ypvdj21mg17c1kx.jpg" alt="丁香园"></p>
<p>二校门<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu18z6i6j21mg17c7wh.jpg" alt="二校门"></p>
<p>一教，在这里上CAD课程，学autocad14<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu1nkp5bj21mg17ce81.jpg" alt="一教"></p>
<p>日晷和大礼堂<br><img src="http://ww2.sinaimg.cn/mw690/6ecbbfd0gw1efwu1d0ejpj21mg17c7wh.jpg" alt="日晷"></p>
<p>学堂，制图课程好像在这，也有在水利馆的<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu1m74a1j217c1mghdt.jpg" alt="学堂"></p>
<p>同方部<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu1l0pwzj217c1mge81.jpg" alt="同方部"></p>
<p>大礼堂西面的池塘<br><img src="http://ww4.sinaimg.cn/mw690/6ecbbfd0gw1efwu16t420j21mg17ce81.jpg" alt="池塘"></p>
<p>自清亭<br><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu1r09ucj21mg17ce81.jpg" alt="自清亭"></p>
<p>朱自清雕像<br><img src="http://ww3.sinaimg.cn/mw690/6ecbbfd0gw1efwu1pxaxkj21mg17ce81.jpg" alt="雕像"></p>
<p>水木清华<br><img src="http://ww1.sinaimg.cn/mw690/6ecbbfd0gw1efwu1f2ygjj21mg17c4po.jpg" alt="水木清华"></p>
<p>荷塘月色<br><img src="http://ww2.sinaimg.cn/mw690/6ecbbfd0gw1efwu1ahyv7j21mg17chdt.jpg" alt="荷塘月色"></p>
<p>其实这一片我很少来，太文艺了。。。</p>
<p>下午还去亮亮的办公室坐了会，大家都跟以前有些不一样了，他送我们下楼的时候，在电梯碰到个女生，叫他李老师好，我就在犹豫要不要把李老师当年的糗事说出来，哈哈哈哈。</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="前端架构那些事儿"><a href="#前端架构那些事儿" class="headerlink" title="前端架构那些事儿"></a>前端架构那些事儿</h1><p>在谈前端架构之前，需要先探讨一下不同人群对前端产生的困惑。前端这个职业最近几年才逐渐被认可，之前一直是低端的代名词，所以多数高手很不屑搞这个。之前的很多项目，人们对前端这块的要求也只是能用就行，所以很少会在上面去细致、深入地建立一套完善体系。而多数产品的技术经理也会是后端出身的，往往对前端的认识还停留在Java Struts那个原始的MVC模型上，或者首先想到的就是GWT和JSF，这是从后端角度出发的一种视角。用这类思维方式做出来的产品，一般用户体验都不会很好。</p>
<p>另一方面，从界面层上手的人群，他对用户体验这方面会把控得比较好，但通常缺架构意识，或者说是软件工程的意识。在界面层比较复杂的情况下，很可能会有失控的趋势。对整个系统结构的认知程度通常不够深入，也缺乏设计模式等方面的知识。</p>
<p>开发人员会有一些困惑：</p>
<ul>
<li><p>创建项目的时候，一般没有人作前端的技术选型</p>
<ul>
<li>拿到项目之后，没有直接可复制的基础版本</li>
</ul>
</li>
<li><p>习惯于引用第三方组件</p>
<ul>
<li>赶功能，需要某个组件或者特效</li>
<li>上网搜到一个合适的，加进来</li>
<li>它还依赖一些别的库</li>
<li>文件大还是次要的</li>
<li>可能会产生冲突，样式也不一致</li>
</ul>
</li>
</ul>
<p>开发经理也会有一些困惑：</p>
<ul>
<li><p>协作过程感觉有问题</p>
<ul>
<li>前端人员写原始界面，包含静态界面和特效</li>
<li>开发人员接着改，加逻辑</li>
<li>发现有问题要返工了</li>
<li>在谁的代码基础上继续改？如何合并？</li>
</ul>
</li>
<li><p>2014年了，为什么还有这么多人工环节？</p>
<ul>
<li>能自动单元测试吗？</li>
<li>能自动发布打包吗？</li>
</ul>
</li>
</ul>
<p>用户会对这些事情感到烦恼：</p>
<ul>
<li><p>长得丑</p>
<ul>
<li>界面老土</li>
<li>风格不一致</li>
</ul>
</li>
<li><p>速度慢</p>
<ul>
<li>加载慢</li>
<li>渲染慢</li>
<li>执行慢</li>
</ul>
</li>
<li><p>出错</p>
</li>
</ul>
<p>架构的本质是什么？其实也是一种管理。通常我们所说的管理，都是指对于任务和人员的管理，而架构管的是机器和代码。比如说，机器的部署属于运维的物理架构，SOA属于服务架构，那么，前端的架构指什么呢？</p>
<p>长期以来，前端所处的位置是比较偏应用层，而且是很薄的一层，而架构又要求深度和广度，所以之前在前端里面做架构，好比在小水塘里游泳，稍微扑腾两下就到处碰壁。但最近这几年来，前端的范围被大大拓展了，所以这一层逐渐变得大有可为。</p>
<p>怎样去理解架构呢？在早期的文字MUD游戏里，有这么一句话：“你感觉哪里不对，但是又说不上来。”在我们开发和使用软件系统的过程中，或多或少会遇到这样的感觉，有这种感觉就说明架构方面可能有些问题。</p>
<p>在狭义的前端领域，架构要处理的很重要的事情是组件的集成。由于JavaScript本身缺乏命名空间这样的机制，多数框架都倾向于自己搞一套，所以这方面的碎片化是很严重的。如果一个公司的实力不足以自研所有用到的组件，就会一直面临这方面的问题。</p>
<p>比如说，在做某个功能的过程中，发现需要一个组件，时间来不及做，就到网上搜了个，加到代码里面，先运行起来再说。一不小心，等功能做完的时候，已经引入了无数种组件了，有很多代码是重叠的，可能有的还有冲突，外观也不一致。</p>
<p>环顾四周的大型互联网公司，基本上都有自己的前端框架，比如阿里的Kissy和Arale，腾讯的JX，百度的Tangram，360的QWrap等，为什么？因为要整合别的框架，并且在此基础上发展适合自己的组件库，代价非常大，初期没办法的时候只能凑合，长期来说，所有代码都可控的意义非常重要。</p>
<p>那么，是不是一套框架可以包打天下呢，这个真的很难。对于不同的产品形态，如果想要用一套框架去适应，有的会偏轻，有的又偏重，有的要兼容低端浏览器，有的又不要，很难取舍。</p>
<p>常见的前端产品形态包括：</p>
<ul>
<li>内容型Web站点 侧重渲染方面的优化，前端逻辑比重小</li>
<li>操作型B/S系统 以数据和逻辑为中心，界面较规整</li>
<li>内嵌Web的本地应用 要处理缓存和一些本地接口，包括PC客户端和移动端</li>
</ul>
<p>另外有Web游戏，因为跟我们的企业形态关系不大，而且也比较独特，所以不包含在内。这三种产品的前端框架要处理的事情显然是不太一样的，所以可以细分成2-3种项目模板，整理出对应的种子项目，供同类产品初始化用。</p>
<p>最近我们经常在前端领域听说两个词：全端、全栈。</p>
<p>全端的意思是，原来的只做在浏览器中运行的Web程序不够，还要做各种终端，包括iOS，Android等本地应用，甚至PC桌面应用。</p>
<p>为什么广义的前端应当包含本地应用呢？因为现在的本地应用，基于很多考虑，都变成了混合应用，也就是说，开发这个应用的技术，既包含原生的代码，也包含了嵌入的HTML5代码。这么一来，就造成了开发本地应用的人技能要求较广，能够根据产品的场景，合理选择每个功能应当使用的技术。</p>
<p>现在有一些PC端的混合应用开发技术，比如node-webkit和hex，前者的典型应用是Intel® XDK，后者的典型应用是有道词典，此外，豌豆荚的PC客户端也是采用类似技术的，也有一些产品是用的qt-webkit。这类技术可以方便做跨平台，极大减少开发工作量。</p>
<p>所以，我们可以看到，在很多公司，开发安卓、iOS应用的人员跟Web前端的处于同一个团队中，这很大程度上就是考虑到这种情况。</p>
<p>全栈的意思是，除了只做在浏览器中运行的代码，还写一些服务端的代码，这个需求又是从哪里来的呢？</p>
<p>这个需求其实来自优化。我们要优化一个系统的前端部分，有这么一些事情可以做：</p>
<ul>
<li>HTML结构的优化，减少DOM树的层次等等</li>
<li>CSS渲染性能的优化，批量写入DOM变更之类</li>
<li>资源文件的优化，比如小图片的合并，图像格式的处理，图标字体的使用等</li>
<li>JavaScript逻辑的优化，模块化，异步加载，性能优化</li>
<li>加载字节量的优化，主要是分摊的策略</li>
<li>HTTP请求的优化</li>
</ul>
<p>这里面，除了前三条，其他都可能跟后端有些关系，尤其是最后一条。但是前端的人没法去优化后端的东西，这是不同的协作环节，所以就很麻烦。</p>
<p>那么，如果有了全栈，这个问题可以怎么解决呢？</p>
<p>比如说，我们要做最原始的小文件合并，可以在服务器做一些配置，把多个合并成一个请求，比如天猫的某个url：</p>
<p><a href="http://g.tbcdn.cn/kissy/k/1.4.1/??dom/base-min.js,event-min.js,event/dom/base-min.js,event/base-min.js,event/dom/touch-min.js,event/dom/shake-min.js,event/dom/focusin-min.js,event/custom-min.js,cookie-min.js?t=1.js" target="_blank" rel="noopener">http://g.tbcdn.cn/kissy/k/1.4.1/??dom/base-min.js,event-min.js,event/dom/base-min.js,event/base-min.js,event/dom/touch-min.js,event/dom/shake-min.js,event/dom/focusin-min.js,event/custom-min.js,cookie-min.js?t=1.js</a></p>
<p>这个就很明显是多个文件合并而成的，9个小文件的请求，合并成了一个64k的文件请求。</p>
<p>这种简单的事情可以在静态代理服务器上配置出来，更复杂的就比较难了，需要一定的服务端逻辑。比如说，我们有多个ajax请求，请求不同的服务，每个请求的数据量都非常少，但因为请求数很多，可能会影响加载性能，如果能把它们在服务端就合并成一个就好了。但这个优化是前端发起的，传统模式下，他的职责范围有限，优化不到服务端去，而这多个服务很可能是跨产品模块的，想要合并，放在哪个后端团队都很怪异。</p>
<p>这可真难办，就像老虎追猴子，猴子上了树，老虎只能在下面干瞪眼。但是如果我们能让老虎上树，这就不是个问题了。如果有这么一层NodeJS，这一层完全由前端程序员控制，他就可以在这个地方做这种合并，非常的合理。</p>
<p>除此之外，我们常常会用到HTML模板，但使用它的最佳位置是随着产品的场景而不同的，可能某个地方在前端更好，可能某个地方在后端好些。到底放在哪合适，只有前端开发人员才会知道，如果前端开发人员不能参与一部分后端代码的开发，优化工作也还是做不彻底。有NodeJS之后会怎样呢，因为不管前端模板还是后端模板，都是JavaScript的，可以使用同一套库，这样在做调整的时候不会有代码迁移的烦恼，直接把模板换地方即可。</p>
<p>现在，也有很多业务场景有实时通信的需求，目前来说最合适的方案是Socket.io，它默认使用NodeJS来当服务端，这也是NodeJS的一个重要使用场景。</p>
<p>这样，前端开发人员也部分参与了运行在服务端的代码，他的工作范围从原先客户端浏览器，向后拓展了一个薄层，所以就有了全栈的称呼。至于说这个称呼还继续扩展，一个前端开发人员从视觉到交互到静态HTML到JavaScript包办的情况，这个就有些过头了。</p>
<p>以上这些，主要解决的都是代码层面的事情。另外有一个方面，也是需要关注，但却常常不能引起重视的，那就是前端的工程化问题。</p>
<p>早期为什么没有这些问题？因为那时候前端很简单，复杂度不高，现在整个很复杂了，就带来了很多管理问题。比如说整个系统的前端都组件化了之后，HTML会拆分成各种模板，JavaScript会拆分成各种模块，而CSS也通过LESS或者SASS这种方式，变成了一种编译式的语言。</p>
<p>这时候，我们考虑一个所谓的组件，它就比较麻烦了。它可能是一个或者多个HTML模板，加上一个或者多个JavaScript模块，再包含CSS中的一部分构成的，而前两者都可能有依赖项，三个部分也都要避免与其他组件的冲突。</p>
<p>这些东西都需要管理，并且提供一种比较好的方案去维护。在JavaScript被模块化之后，也可以通过单元测试来控制它们的质量，并且把这个过程自动化，每次版本有变更之前，保证它们最基本的正确性。最终，需要有一种自动化的发布机制，把这几类代码提取，打包合并，压缩，发布。</p>
<p>这个主题展开可以讲很多，所以我们不在本次分享中涉及。在我之前的几篇文章中，也阐述过观点。</p>
<p>目前这方面研究最深入的是之前百度FIS团队的张云龙，他的几篇文章在<a href="https://github.com/fouber/blog" title="这里" target="_blank" rel="noopener">这里</a>，强烈推荐阅读。</p>
<p>后记：</p>
<p>这篇文章是我入职苏宁之后第一次公开分享，目标受众主要是后端出身的技术经理，目的是让这个群体能有更多的前端意识。现在公司的项目基本都有前端模块，但人员专职程度较低，水平也参差不齐。苏宁的战略口号之一是提升用户体验，从产品角度看，用户体验的提升并非是UI做几个图，搞一些花哨效果就可以了，它是一个系统工程，涉及从用户习惯调研、产品设计、前端开发、甚至后端服务等一系列环节，需要从易用度、观感、加载性能、流畅度等各方面共同提升。</p>
<p>这些东西都需要从全局角度作规划，从源头控制起，否则只能是头疼医头，脚痛医脚。为此，基础技术中心会逐步整合几套适合不同场景的基础前端框架，作为种子项目供今后的技术选型使用。此外，还会从前端开发的各种主题组织一些技术分享，并且逐步形成一套制度化，流程化的培训体系。</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="为什么企业应用这么“钟情”于IE6"><a href="#为什么企业应用这么“钟情”于IE6" class="headerlink" title="为什么企业应用这么“钟情”于IE6"></a>为什么企业应用这么“钟情”于IE6</h1><p>企业内部的信息化，很多起步都很早，但B/S化基本都是从2000年以后开始的，之前有各种客户端，比如基本的Win32 API开发，或者Delphi体系（VCL等，C++ Builder也算在内），微软的几个封装化的体系（ATL，MFC，还有昙花一现的JFC），Java体系（AWT、Swing，SWT等），这些技术本身都比较成熟，IDE的支持也不错，但最终，很大一部分迁移到Web上了。</p>
<p>迁移到Web的最直接因素是部署成本，B/S架构有天然的部署优势，无需分发，这一点人所共知，但另外还有个重要因素是开发成本。很多人对这一点不相信，为什么呢，因为现在前端码农也不便宜啊，怎么就他降低开发成本了？<br>

    
	  <div class="readmore">
      <a href="/2019/04/13/杂谈/2014-01-20-为什么企业应用这么“钟情”于IE6/">Read More</a>
    </div>
    
    
    
  </p></section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="Web应用的组件化开发（二）"><a href="#Web应用的组件化开发（二）" class="headerlink" title="Web应用的组件化开发（二）"></a>Web应用的组件化开发（二）</h1><h2 id="管控平台"><a href="#管控平台" class="headerlink" title="管控平台"></a>管控平台</h2><p>在上一篇中我们提到了组件化的大致思路，这一篇主要讲述在这么做之后，我们需要哪些外围手段去管控整个开发过程。从各种角度看，面对较大规模前端开发团队，都有必要建立这么一个开发阶段的协作平台。</p>
<p>在这个平台上，我们要做哪些事情呢？<br>

    
	  <div class="readmore">
      <a href="/2019/04/13/杂谈/2013-12-09-Web应用的组件化（二）/">Read More</a>
    </div>
    
    
    
  </p></section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="JavaScript深入之执行上下文"><a href="#JavaScript深入之执行上下文" class="headerlink" title="JavaScript深入之执行上下文"></a>JavaScript深入之执行上下文</h1><blockquote>
<p>JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">《JavaScript深入之执行上下文栈》</a>中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>然后分别在<a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">《JavaScript深入之变量对象》</a>、<a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">《JavaScript深入之作用域链》</a>、<a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">《JavaScript深入之从ECMAScript规范解读this》</a>中讲解了这三个属性。</p>
<p>阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。<br>

    
	  <div class="readmore">
      <a href="/2019/04/13/深入系列文章/JavaScript深入之执行上下文/">Read More</a>
    </div>
    
    
    
  </p></section>
</article>
    </div>
  
    <div class="post-wrapper">
      <article class="post revealno-title">
  <section class="meta">
    
    <time>
      4月 13, 2019
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="JavaScript专题之偏函数"><a href="#JavaScript专题之偏函数" class="headerlink" title="JavaScript专题之偏函数"></a>JavaScript专题之偏函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>维基百科中对偏函数 (Partial application) 的定义为：</p>
<blockquote>
<p>In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. </p>
</blockquote>
<p>翻译成中文：</p>
<p>在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。</p>
<p>什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。</p>
<p>举个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个 partial 函数可以做到局部应用</span></span><br><span class="line"><span class="keyword">var</span> addOne = partial(add, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>个人觉得翻译成“局部应用”或许更贴切些，以下全部使用“局部应用”。</p>
<h2 id="柯里化与局部应用"><a href="#柯里化与局部应用" class="headerlink" title="柯里化与局部应用"></a>柯里化与局部应用</h2><p>如果看过上一篇文章<a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">《JavaScript专题之柯里化》</a>，实际上你会发现这个例子和柯里化太像了，所以两者到底是有什么区别呢？</p>
<p>其实也很明显：</p>
<p>柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。</p>
<p>局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。</p>
<p>如果说两者有什么关系的话，引用 <a href="https://github.com/hemanth/functional-programming-jargon#partial-application" target="_blank" rel="noopener">functional-programming-jargon</a> 中的描述就是：</p>
<blockquote>
<p> Curried functions are automatically partially applied.</p>
</blockquote>
<h2 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h2><p>我们今天的目的是模仿 underscore 写一个 partial 函数，比起 curry 函数，这个显然简单了很多。</p>
<p>也许你在想我们可以直接使用 bind 呐，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addOne = add.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>然而使用 bind 我们还是改变了 this 指向，我们要写一个不改变 this 指向的方法。</p>
<h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>根据之前的表述，我们可以尝试着写出第一版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="comment">// 似曾相识的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们来写个 demo 验证下 this 的指向：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var addOne = add.bind(null, 1);</span></span><br><span class="line"><span class="keyword">var</span> addOne = partial(add, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    addOne: addOne</span><br><span class="line">&#125;</span><br><span class="line">obj.addOne(<span class="number">2</span>); <span class="comment">// ???</span></span><br><span class="line"><span class="comment">// 使用 bind 时，结果为 4</span></span><br><span class="line"><span class="comment">// 使用 partial 时，结果为 5</span></span><br></pre></td></tr></table></figure>
<h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><p>然而正如 curry 函数可以使用占位符一样，我们希望 partial 函数也可以实现这个功能，我们再来写第二版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">var</span> _ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> position = <span class="number">0</span>, len = args.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            args[i] = args[i] === _ ? <span class="built_in">arguments</span>[position++] : args[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(position &lt; <span class="built_in">arguments</span>.length) args.push(argumetns[position++]);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们验证一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a; &#125;;</span><br><span class="line">subFrom20 = partial(subtract, _, <span class="number">20</span>);</span><br><span class="line">subFrom20(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>值得注意的是：underscore 和 lodash 都提供了 partial 函数，但只有 lodash 提供了 curry 函数。</p>
<h2 id="专题系列"><a href="#专题系列" class="headerlink" title="专题系列"></a>专题系列</h2><p>JavaScript专题系列目录地址：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog</a>。</p>
<p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p>
<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>


    
    
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/archives/2019/04/page/2/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
    <a class="next" rel="next" href="/archives/2019/04/page/4/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  


      </div>
      <aside class='l_side'>
        
  <section class="m_widget about">

<img class="avatar waves-image" src="https://avatars3.githubusercontent.com/u/13073380?s=460&amp;v=4">

<div class="header">zhouli</div>
<div class="content">
<div class="desc">weichat:qianchaochushui</div>
</div>
</section>

  <section class="m_widget links">
<div class="header">友情链接</div>
<div class="content">
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://finance.json119.com">
            <div class="name">finance</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://json119.com/">
            <div class="name">json119</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class="m_widget categories">
<div class="header">分类</div>
<div class="content">
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/Bootstrap/"><div class="name">Bootstrap</div><div class="badget">1</div></a></li>
    
        <li><a class="flat-box" href="/categories/CSS/"><div class="name">CSS</div><div class="badget">1</div></a></li>
    
        <li><a class="flat-box" href="/categories/GitHub/"><div class="name">GitHub</div><div class="badget">2</div></a></li>
    
        <li><a class="flat-box" href="/categories/HTML-CSS/"><div class="name">HTML CSS</div><div class="badget">1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Interview/"><div class="name">Interview</div><div class="badget">1</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class="name">JavaScript</div><div class="badget">22</div></a></li>
    
        <li><a class="flat-box" href="/categories/Sublime/"><div class="name">Sublime</div><div class="badget">1</div></a></li>
    
        <li><a class="flat-box" href="/categories/Tools/"><div class="name">Tools</div><div class="badget">1</div></a></li>
    
        <li><a class="flat-box" href="/categories/css1/"><div class="name">css1</div><div class="badget">0</div></a></li>
    
        <li><a class="flat-box" href="/categories/jekyll/"><div class="name">jekyll</div><div class="badget">2</div></a></li>
    
        <li><a class="flat-box" href="/categories/js/"><div class="name">js</div><div class="badget">0</div></a></li>
    
        <li><a class="flat-box" href="/categories/js1/"><div class="name">js1</div><div class="badget">0</div></a></li>
    
        <li><a class="flat-box" href="/categories/mysql1/"><div class="name">mysql1</div><div class="badget">0</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">标签</div>
    <div class="content">
        <a href="/tags/Baidu-ife-HTML-CSS-task/" style="font-size: 14px; color: #808080">Baidu ife HTML CSS task</a> <a href="/tags/Baidu-ife-JavaScript-正则-Regular/" style="font-size: 14px; color: #808080">Baidu ife JavaScript 正则 Regular</a> <a href="/tags/BootStrap-HTML-CSS-Zhihu/" style="font-size: 14px; color: #808080">BootStrap HTML CSS Zhihu</a> <a href="/tags/ES2015-ES6-ES5-babel/" style="font-size: 14px; color: #808080">ES2015 ES6 ES5 babel</a> <a href="/tags/Git-GitHub-分支/" style="font-size: 14px; color: #808080">Git GitHub 分支</a> <a href="/tags/GitHub-同步-fork/" style="font-size: 14px; color: #808080">GitHub 同步 fork</a> <a href="/tags/IE-CSS-兼容性-HTML/" style="font-size: 14px; color: #808080">IE CSS 兼容性 HTML</a> <a href="/tags/JavaScript-Ajax-URL-HistoryApi-pushState-pjax/" style="font-size: 14px; color: #808080">JavaScript Ajax URL HistoryApi pushState pjax</a> <a href="/tags/JavaScript-Array-算法-慕课网/" style="font-size: 14px; color: #808080">JavaScript Array 算法 慕课网</a> <a href="/tags/JavaScript-HTML-CSS-Sass-移动端-XSS-AMD-requireJS-CommonJS-性能优化-WebApp/" style="font-size: 14px; color: #808080">JavaScript HTML CSS Sass 移动端 XSS AMD requireJS CommonJS 性能优化 WebApp</a> <a href="/tags/JavaScript-HTML-CSS-思维导图-技能树/" style="font-size: 14px; color: #808080">JavaScript HTML CSS 思维导图 技能树</a> <a href="/tags/JavaScript-作用域-慕课网-ife/" style="font-size: 14px; color: #808080">JavaScript 作用域 慕课网 ife</a> <a href="/tags/JavaScript-函数-慕课网-ife/" style="font-size: 14px; color: #808080">JavaScript 函数 慕课网 ife</a> <a href="/tags/JavaScript-慕课网-this-ife/" style="font-size: 14px; color: #808080">JavaScript 慕课网 this ife</a> <a href="/tags/JavaScript-闭包-慕课网-ife/" style="font-size: 14px; color: #808080">JavaScript 闭包 慕课网 ife</a> <a href="/tags/JavaScript-面向对象-慕课网-ife/" style="font-size: 14px; color: #808080">JavaScript 面向对象 慕课网 ife</a> <a href="/tags/Sublime-jshint-csslint/" style="font-size: 14px; color: #808080">Sublime jshint csslint</a> <a href="/tags/Weinre-WebApp-调试工具-JavaScript-HTML-CSS/" style="font-size: 14px; color: #808080">Weinre WebApp 调试工具 JavaScript HTML CSS</a> <a href="/tags/countdown-JavaScript/" style="font-size: 14px; color: #808080">countdown JavaScript</a> <a href="/tags/jekyll-RubyGems/" style="font-size: 14px; color: #808080">jekyll RubyGems</a> <a href="/tags/jekyll-端口-markdown-Foxit-RubyGems-HTML-CSS/" style="font-size: 14px; color: #808080">jekyll 端口 markdown Foxit RubyGems HTML CSS</a> <a href="/tags/tools-CSS-reveal-配色/" style="font-size: 14px; color: #808080">tools CSS reveal 配色</a> <a href="/tags/函数-JavaScript/" style="font-size: 14px; color: #808080">函数 JavaScript</a> <a href="/tags/动画-CSS-airbnb-lottie-JavaScript/" style="font-size: 14px; color: #808080">动画 CSS airbnb lottie JavaScript</a> <a href="/tags/动画-手势/" style="font-size: 14px; color: #808080">动画 手势</a> <a href="/tags/对象-函数-this-闭包-面向对象-作用域/" style="font-size: 14px; color: #808080">对象 函数 this 闭包 面向对象 作用域</a> <a href="/tags/效率-vscode-markdown/" style="font-size: 14px; color: #808080">效率 vscode markdown</a> <a href="/tags/文件-下载-JavaScript/" style="font-size: 14px; color: #808080">文件 下载 JavaScript</a> <a href="/tags/正则-分组-Regular/" style="font-size: 14px; color: #808080">正则 分组 Regular</a> <a href="/tags/算法-shuffle-乱序-洗牌/" style="font-size: 14px; color: #808080">算法 shuffle 乱序 洗牌</a> <a href="/tags/继承-对象-原型-Array-正则/" style="font-size: 14px; color: #808080">继承 对象 原型 Array 正则</a> <a href="/tags/面试-Lenovo-实习-JavaScript/" style="font-size: 14px; color: #808080">面试 Lenovo 实习 JavaScript</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/qccs" class="social github" target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://finance.json119.com" class="social vcard" target="_blank" rel="external">
          <span class="icon icon-vcard"></span>
        </a>
      
        <a href="/atom.xml" class="social rss" target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
    <style>
        .aaa{
            text-align: center;
        }
    </style>
    <div class="aaa">
        <a href="https://info.flagcounter.com/fv6m"><img src="https://s11.flagcounter.com/count2/fv6m/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_0/labels_0/pageviews_0/flags_0/percent_0/" alt="Flag Counter" border="0"></a>
        <a href="http://www.miibeian.gov.cn/" target="_blank">渝ICP备16001049号</a></div>

    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?2f089ce8c3df6466fce313abefd662c3";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();


    </script>
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/node-waves/0.7.5/waves.min.js"></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
