<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qianchaochushui</title>
  
  <subtitle>subtitle</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qccs.github.io/"/>
  <updated>2019-04-14T09:32:35.367Z</updated>
  <id>https://qccs.github.io/</id>
  
  <author>
    <name>zhouli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E4%B8%93%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    <id>https://qccs.github.io/2019/04/14/专题系列文章/JavaScript专题之偏函数/</id>
    <published>2019-04-14T09:32:35.367Z</published>
    <updated>2019-04-14T09:32:35.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript专题之偏函数"><a href="#JavaScript专题之偏函数" class="headerlink" title="JavaScript专题之偏函数"></a>JavaScript专题之偏函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>维基百科中对偏函数 (Partial application) 的定义为：</p><blockquote><p>In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. </p></blockquote><p>翻译成中文：</p><p>在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。</p><p>什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。<br><a id="more"></a><br>举个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个 partial 函数可以做到局部应用</span></span><br><span class="line"><span class="keyword">var</span> addOne = partial(add, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>个人觉得翻译成“局部应用”或许更贴切些，以下全部使用“局部应用”。</p><h2 id="柯里化与局部应用"><a href="#柯里化与局部应用" class="headerlink" title="柯里化与局部应用"></a>柯里化与局部应用</h2><p>如果看过上一篇文章<a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">《JavaScript专题之柯里化》</a>，实际上你会发现这个例子和柯里化太像了，所以两者到底是有什么区别呢？</p><p>其实也很明显：</p><p>柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。</p><p>局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。</p><p>如果说两者有什么关系的话，引用 <a href="https://github.com/hemanth/functional-programming-jargon#partial-application" target="_blank" rel="noopener">functional-programming-jargon</a> 中的描述就是：</p><blockquote><p> Curried functions are automatically partially applied.</p></blockquote><h2 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h2><p>我们今天的目的是模仿 underscore 写一个 partial 函数，比起 curry 函数，这个显然简单了很多。</p><p>也许你在想我们可以直接使用 bind 呐，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addOne = add.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>然而使用 bind 我们还是改变了 this 指向，我们要写一个不改变 this 指向的方法。</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>根据之前的表述，我们可以尝试着写出第一版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="comment">// 似曾相识的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来写个 demo 验证下 this 的指向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var addOne = add.bind(null, 1);</span></span><br><span class="line"><span class="keyword">var</span> addOne = partial(add, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    addOne: addOne</span><br><span class="line">&#125;</span><br><span class="line">obj.addOne(<span class="number">2</span>); <span class="comment">// ???</span></span><br><span class="line"><span class="comment">// 使用 bind 时，结果为 4</span></span><br><span class="line"><span class="comment">// 使用 partial 时，结果为 5</span></span><br></pre></td></tr></table></figure><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><p>然而正如 curry 函数可以使用占位符一样，我们希望 partial 函数也可以实现这个功能，我们再来写第二版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">var</span> _ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> position = <span class="number">0</span>, len = args.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            args[i] = args[i] === _ ? <span class="built_in">arguments</span>[position++] : args[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(position &lt; <span class="built_in">arguments</span>.length) args.push(argumetns[position++]);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a; &#125;;</span><br><span class="line">subFrom20 = partial(subtract, _, <span class="number">20</span>);</span><br><span class="line">subFrom20(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>值得注意的是：underscore 和 lodash 都提供了 partial 函数，但只有 lodash 提供了 curry 函数。</p><h2 id="专题系列"><a href="#专题系列" class="headerlink" title="专题系列"></a>专题系列</h2><p>JavaScript专题系列目录地址：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog</a>。</p><p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p><p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript专题之偏函数&quot;&gt;&lt;a href=&quot;#JavaScript专题之偏函数&quot; class=&quot;headerlink&quot; title=&quot;JavaScript专题之偏函数&quot;&gt;&lt;/a&gt;JavaScript专题之偏函数&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;维基百科中对偏函数 (Partial application) 的定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成中文：&lt;/p&gt;
&lt;p&gt;在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。&lt;/p&gt;
&lt;p&gt;什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记2-继承、数组、正则表达式</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-06-08-JavaScript-good-parts-note2/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-06-08-JavaScript-good-parts-note2/</id>
    <published>2019-04-14T09:29:00.637Z</published>
    <updated>2019-04-14T09:29:00.638Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。</p><a id="more"></a><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的两大好处：代码重用，引入一套类型系统的规范。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>JavaScript 通过构造器函数产生对象。</p><p>构造器调用模式，即用<code>new</code>前缀去调用一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mammal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mammal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mammal.prototype.says = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.saying || <span class="string">''</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMammal = <span class="keyword">new</span> Mammal(<span class="string">'Herb'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myMammal.getName()) <span class="comment">//Herb</span></span><br></pre></td></tr></table></figure><p>书中不推荐这样的写法。有很多风险。若忘记添加<code>new</code>前缀，<code>this</code>无法绑定到新的对象上。而是绑定到了全局对象上，破坏了全局变量环境。</p><h3 id="对象说明符"><a href="#对象说明符" class="headerlink" title="对象说明符"></a>对象说明符</h3><p>上一节中的构造器可能要接受一大串参数。我们可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = Maker(&#123;</span><br><span class="line">    first: f,</span><br><span class="line">    middle: m,</span><br><span class="line">    last: l,</span><br><span class="line">    state: s,</span><br><span class="line">    city: c</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将JSON对象传递给构造器，而它返回一个构造完全的对象。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在一个纯粹的原型模式中，我们将摒弃类，转而专注于对象。一个新对象可以继承一个就对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMammal = &#123;</span><br><span class="line">    name: <span class="string">'MM'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;,</span><br><span class="line">    says: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saying || <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCat = <span class="built_in">Object</span>.create(myMammal)</span><br><span class="line">myCat.name = <span class="string">'Kitty'</span></span><br><span class="line">myCat.saying = <span class="string">'meow'</span></span><br><span class="line">myCat.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Kitty is running'</span></span><br><span class="line">&#125;</span><br><span class="line">myCat.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.says + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.says</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种差异化继承。</p><h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><p>前文看到的继承模式没法保护隐私。对象的所有属性都是可见的。无法得到私有变量和私有函数。为了解决这一问题，我们有模块模式。</p><p>构造一个生成对象的函数需要4步骤：</p><ol><li>创建一个新对象。</li><li>有选择的定义私有变量和方法。</li><li>给这个新对象扩充方法。</li><li>返回那个新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mammal = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    that.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spec.name</span><br><span class="line">    &#125;</span><br><span class="line">    that.says = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spec.saying || <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMammal = mammal(&#123;</span><br><span class="line">    name: <span class="string">'Herb'</span>,</span><br><span class="line">    saying: <span class="string">'Cheers!'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.getName()) <span class="comment">//Herb</span></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.says()) <span class="comment">//Cheers!</span></span><br></pre></td></tr></table></figure><p>也可以参考上一篇文章，<a href="http://gaohaoyang.github.io/2016/06/07/JavaScript-good-parts-note1/#section-34" target="_blank" rel="noopener">JavaScript 语言精粹笔记1-语法、对象、函数 之模块部分</a>。</p><h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>这一部分看的不是特别懂，我想等我学完ES2015中的类和模块部分后再看看吧。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>一个数组字面量是在一对方括号中包围零个或多个用逗号分隔的值的表达式。</p><p>再大多数语言中，一个数组的多有元素都要求是相同的类型。JavaScript 允许数组包含任意混合类型的值。</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>JavaScript 数组的<code>length</code>属性是没有上界的。如果用大于或等于当前<code>length</code>的数字作为下标来存储一个元素，那么<code>length</code>值会被增大以容纳新元素，不会发生数组越界错误。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>数组也是对象，可以用<code>delete</code>来删除元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="number">3</span>, <span class="string">'four'</span>, <span class="string">'wu'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> numbers[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.length) <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>可以使用<code>splice</code>方法，进行删除和修改操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">0</span>]) <span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.length) <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用常规<code>for</code>循环即可，可以保证数组的顺序。</p><h3 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h3><p>当属性名是小而连续的整数时，应该使用数组，否则使用对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>返回数组的类型是<code>object</code>，没有任何意义。</p><p>判断数组类型的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(numbers)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5.1 (ECMA-262) 和 ECMAScript 2015 (6th Edition, ECMA-262) 标准中的方法。</p><p>或者下面这个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> is_array = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply(value) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(is_array(numbers)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>数组的方法被存储在<code>Array.prototype</code>中的函数。</p><p>数组是对象，因此<code>Array.prototype</code>也是可扩充的。</p><h3 id="指定初始值"><a href="#指定初始值" class="headerlink" title="指定初始值"></a>指定初始值</h3><p>JavaScript 的数组不会预制值。</p><p>JavaScript 没有多维数组，单项大多数类 C 语言一样，支持元素为数组的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = [</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.log(matrix[<span class="number">1</span>][<span class="number">2</span>]) <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>关于正则表达式，以前的博文写的比较多了，详情见：</p><p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-10" target="_blank" rel="noopener">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分1</a></p><p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-12" target="_blank" rel="noopener">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分2</a></p><p><a href="http://gaohaoyang.github.io/2016/05/06/regular-expression-group/" target="_blank" rel="noopener">浅谈正则表达式中的分组和引用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="继承 对象 原型 Array 正则" scheme="https://qccs.github.io/tags/%E7%BB%A7%E6%89%BF-%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B-Array-%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记1-语法、对象、函数</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-06-07-JavaScript-good-parts-note1/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-06-07-JavaScript-good-parts-note1/</id>
    <published>2019-04-14T09:29:00.627Z</published>
    <updated>2019-04-14T09:29:00.627Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。</p><a id="more"></a><p><img src="https://img3.doubanio.com/lpic/s3651235.jpg" alt></p><p>原书中第一章为精华，做了一些周边介绍，略去。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>这里说一下JavaScript的注释，一种是 <code>/* */</code> 包围的块注释，另一种是 <code>//</code> 开头的行注释。</p><p>因为块注释的字符可能是JavaScript中正则表达式字面量，因此不是很安全，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    var rm_a = /a*/</span>.match(s)</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符由一个字母开头，后面可选择性的加上一个或多个字母、数字或下划线。要避免保留字。</p><p>标识符被用于语句、变量、参数、属性名、运算符和标记。</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>可以存在指数部分，100和1e2完全相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> === <span class="number">1e2</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用<code>isNaN</code>来检测<code>NaN</code>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当年 JavaScript 被创建的时候，Unicode 是16位字符集，因此 JavaScript 字符串是16位的。</p><p>用双引号或单引号包裹。</p><p>重点说一下转义字符<code>\</code></p><p>反斜杠后面可以跟<code>&quot;</code>, <code>&#39;</code>, <code>\</code>, <code>/</code>, <code>b</code> (backspace), <code>f</code> (formfeed), <code>n</code>, <code>r</code> (carriage return), <code>t</code>, <code>u1234</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'A'</span> === <span class="string">'\u0041'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>每个<code>&lt;script&gt;</code>标签的内容被一起抛到一个公共的全局名字空间中。</p><p><code>{...}</code>代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。</p><p>下列值当做假：</p><ul><li><code>false</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>&#39;&#39;</code></li><li><code>0</code></li><li><code>NaN</code></li></ul><p>其他所有值都当做真</p><p><code>for in</code>语句枚举对象的所有属性名（键名），使用<code>object.hasOwnProperty(variable)</code>来确定这个属性名是该对象成员，还是来自原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (myvar <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(myvar)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>运算符优先级</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code> <code>[]</code> <code>()</code></td><td>提取属性与调用函数</td></tr><tr><td><code>delete</code> <code>new</code> <code>typeof</code> <code>+</code> <code>-</code> <code>!</code></td><td>一元运算符</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code></td><td></td></tr><tr><td><code>+</code> <code>-</code></td><td></td></tr><tr><td><code>&gt;=</code> <code>&lt;=</code> <code>&gt;</code> <code>&lt;</code></td><td></td></tr><tr><td><code>===</code> <code>!==</code></td><td></td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td>`</td><td></td><td>`</td><td>逻辑或</td></tr><tr><td><code>?:</code></td><td>三目</td></tr></tbody></table><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>对象字面量是一种可以方便地按指定规格创建新对象的表示法。</p><p>数组字面量是一种可以方便地按指定规格创建新数组的表示法。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数字面量定义了函数值。后续章节详谈。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是属性的容器，每一个属性都拥有名字和值。属性的名字可以是包含空字符串在内的任意字符串。属性的值可以是除<code>undefined</code>值之外的任何值。</p><p>JavaScript 包含一种原型链的特性，允许对象继承另一个对象的属性。正确地使用它能减少对象初始化时消耗的时间和内存。</p><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty_object = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stooge = &#123;</span><br><span class="line">    firstName: <span class="string">'Haoyang'</span>,</span><br><span class="line">    lastName: <span class="string">'Gao'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stooge.firstName); <span class="comment">// Haoyang</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge[<span class="string">'firstName'</span>]); <span class="comment">// Haoyang</span></span><br></pre></td></tr></table></figure><p>不存在的属性返回<code>undefined</code>。</p><p>使用<code>||</code>来填充默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stooge.firstName || <span class="string">'Joe'</span>); <span class="comment">// Haoyang</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge.age || <span class="number">25</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>直接使用赋值语句更新，若不存在这个属性，则作为扩充操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stooge.firstName = <span class="string">'aaa'</span></span><br><span class="line">stooge.nickName = <span class="string">'peip'</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge) <span class="comment">//Object &#123;firstName: "aaa", lastName: "Gao", nickName: "peip"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对象通过引用来传递他们永远不会被复制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = stooge</span><br><span class="line">x.hair = <span class="string">'black'</span></span><br><span class="line">stooge.hair <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过字面量创建的对象都连接到<code>Object.prototype</code>，它是JavaScript中的标配对象。</p><p>可以使用<code>Object.create()</code>方法创建一个使用原对象作为其原型的新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherStooge = <span class="built_in">Object</span>.create(stooge)</span><br><span class="line">anotherStooge.firstName <span class="comment">//"aaa"</span></span><br><span class="line">anotherStooge.firstName = <span class="string">'bbb'</span></span><br><span class="line">anotherStooge.firstName <span class="comment">//"bbb"</span></span><br><span class="line">anotherStooge.hair <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure><p>新对象先查找自己的属性，若不存在则会向原型方向查找。</p><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4ieu7focqj207h05caaf.jpg" alt></p><p>当我们对某个对象作出改变时，不会触及该对象的原型。</p><p>原型关系是一种动态关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p><p>检查对象并确定对象有什么属性是很容易的事情，只要试着去检索该属性并验证取得的值。</p><p><code>typeof</code>用来确定对象属性的类型。</p><p><code>hasOwnProperty</code>，若对象拥有独有的属性，它将返回<code>true</code>。不会检查原型链。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用<code>for in</code>可以遍历一个对象中的所有属性名，包括原型链上的属性名。可以使用<code>hasOwnProperty</code>过滤原型链上的属性，使用<code>typeof</code>来排除函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> anotherStooge) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anotherStooge.hasOwnProperty(name) &amp;&amp; <span class="keyword">typeof</span> anotherStooge[name] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">'---&gt;'</span> + anotherStooge[name])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// firstName---&gt;bbb</span></span><br></pre></td></tr></table></figure><p>属性名是无序的，若想保持顺序应使用数组和<code>for</code>循环。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delete</code>可以用来删除对象的属性。若对象包含该属性，则会被移除。它不会触及原型链中的任何对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anotherStooge.firstName <span class="comment">//"bbb"</span></span><br><span class="line"><span class="keyword">delete</span> anotherStooge.firstName</span><br><span class="line">anotherStooge.firstName <span class="comment">//"aaa"</span></span><br></pre></td></tr></table></figure><h3 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h3><p>JavaScript 可以随意的定义全局变量来容纳应用的所有资源。但这会削弱程序的灵活性，应避免使用全局变量。</p><p>最小化使用全局变量的方法之一是为应用只创建一个唯一的全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.stooge = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.flight = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一章将使用闭包来进行信息隐藏，是另一种有效减少全局污染的方法。</p><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>JavaScript 中的函数就是对象。函数对象连接到<code>Function.prototype</code>（该原型对象本身连接到<code>Object.prototype</code>）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。</p><p>函数对象在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值即为该函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4lrei2b3pj208f06et95.jpg" alt></p><p>因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。</p><p>函数的与众不同之处在于可以被调用。</p><h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>函数对象通过函数字面量来创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：<code>this</code>和<code>arguments</code>。参数<code>this</code>在面向对象编程中非常重要，它的值取决于调用的模式。JavaScript中一共有4中调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。</p><p>实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为<code>undefined</code>。</p><p>下面的内容也可以参考我以前的博文 <a href="http://gaohaoyang.github.io/2015/06/12/JavaScript-this/" target="_blank" rel="noopener">JavaScript 中的 this</a></p><h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，<code>this</code>被绑定到该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params">inc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.increment()</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">myObject.increment(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p>当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。</p><p>此时<code>this</code>被绑定到全局对象。即时是内部函数也会将<code>this</code>绑定到全局对象。</p><p>可以在函数内创建一个属性并赋值为<code>this</code>来解决这个问题。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.double = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.value = add(that.value, that.value)</span><br><span class="line">    &#125;</span><br><span class="line">    helper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.double()</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//8</span></span><br></pre></td></tr></table></figure><h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。</p><p>如果在一个函数前面带上<code>new</code>来调用，那么背地里将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时<code>this</code>会被绑定到那个新对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造器函数</span></span><br><span class="line"><span class="keyword">var</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Que的所有实例提供一个公共方法</span></span><br><span class="line">Quo.prototype.getStatus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">'confused'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myQuo.getStatus()) <span class="comment">//confused</span></span><br></pre></td></tr></table></figure><p>书中不推荐这种形式的构造器函数，下一章有更好的解决方案。</p><h4 id="Apply-调用模式"><a href="#Apply-调用模式" class="headerlink" title="Apply 调用模式"></a>Apply 调用模式</h4><p><code>apply</code>方法让我们构建一个参数数组传递给调用函数。他也允许我们选择<code>this</code>的值。<code>apply</code>方法接受两个参数，第一个是要绑定给<code>this</code>的值，第二个是参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> sum = add.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> statusObject = &#123;</span><br><span class="line">    status: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status = Quo.prototype.getStatus.apply(statusObject)</span><br><span class="line"><span class="built_in">console</span>.log(status) <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>当函数被调用时，会得到一个<code>arguments</code>数组。通过此参数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)) <span class="comment">//45</span></span><br></pre></td></tr></table></figure><p>因语言的设计错误，<code>arguments</code>并不是一个真正的数组。是一个“类似数组”的对象。有<code>length</code>属性，但没有任何数组的方法。</p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>函数执行时遇到关闭函数体的<code>}</code>时结束。然后把控制权交还给调用该函数的程序。</p><p><code>return</code>可以使函数提前返回，不在执行余下的语句。</p><p>函数总是会返回一个值，若没有指定，则返回<code>undefined</code>。</p><p>若函数调用时在前面加上了<code>new</code>前缀，且返回值不是一个对象的时候，则返回<code>this</code>（该新对象）。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是干扰程序的正常流畅的不寻常的事故。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'number'</span> || <span class="keyword">typeof</span> b !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> &#123;</span><br><span class="line">            name: <span class="string">'TypeError'</span>,</span><br><span class="line">            message: <span class="string">'add needs numbers'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="string">'a'</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4mprafcvhj20ml00xjrj.jpg" alt></p><p><code>throw</code>语句中断函数的执行。抛出一个<code>exception</code>对象，该对象包含一个用来识别异常类型的<code>name</code>属性和一个描述性的<code>message</code>属性。也可以自定义其他属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> try_it = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        add2(<span class="string">'a'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.name + <span class="string">': '</span> + e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">try_it() <span class="comment">//TypeError: add needs numbers</span></span><br></pre></td></tr></table></figure><p>如果在<code>try</code>代码块内抛出一个异常，控制权就会跳转到它的<code>catch</code>语句中。</p><h3 id="扩充类型的功能"><a href="#扩充类型的功能" class="headerlink" title="扩充类型的功能"></a>扩充类型的功能</h3><p>JavaScript 允许给语言的基本类型扩充功能。通过<code>Object.prototype</code>添加方法，可以让该方法对所有对象都适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先添加方法使得该方法对所有函数可用</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype[name] = func</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个取整方法</span></span><br><span class="line"><span class="built_in">Number</span>.method(<span class="string">'integer'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>[<span class="keyword">this</span> &lt; <span class="number">0</span> ? <span class="string">'ceil'</span> : <span class="string">'floor'</span>](<span class="keyword">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">-10</span> / <span class="number">3</span>).integer()) <span class="comment">//-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 trim()</span></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'trim'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'  hello alibaba  '</span>.trim()) <span class="comment">//hello alibaba</span></span><br></pre></td></tr></table></figure><p>JavaScript 原型继承是动态的，因此新的方法立刻被赋予到所有的对象实例上，即使对象实例是在方法被增加之前就创建好了。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数就是会直接或者间接地调用自身的一种函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> walkTheDom = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node, func</span>) </span>&#123;</span><br><span class="line">    func(node)</span><br><span class="line">    node = node.firstChild</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        walk(node, func)</span><br><span class="line">        node = node.nextSibling</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getElementsByAttribute = <span class="function"><span class="keyword">function</span>(<span class="params">att, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = []</span><br><span class="line">    walkTheDom(<span class="built_in">document</span>.body, <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> actual = node.nodeType === <span class="number">1</span> &amp;&amp; node.getAttribute(att)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> actual === <span class="string">'string'</span> &amp;&amp; (actual === value || <span class="keyword">typeof</span> value !== <span class="string">'string'</span>)) &#123;</span><br><span class="line">            results.push(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在知乎主页上操作</span></span><br><span class="line"><span class="built_in">console</span>.log(getElementsByAttribute(<span class="string">'data-za-module'</span>, <span class="string">'AnswerItem'</span>))</span><br><span class="line"><span class="comment">//得到下列数据</span></span><br><span class="line"><span class="comment">//[div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content]</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域控制着变量与参数的可见性及生命周期。它减少了名称冲突，并提供了自动内存管理。</p><p>无块级作用域。</p><p>有函数作用域。</p><p>建议在函数体的顶部声明函数中可能用到的所有变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quo = <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get_status: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> status</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myQuo = quo(<span class="string">'amazed'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myQuo.get_status()) <span class="comment">//amazed</span></span><br></pre></td></tr></table></figure><p>狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。</p><p>避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前<code>i</code>值的函数，这样就不会导致混淆了。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>将一个函数作为参数，一旦接收到响应，再调用这个函数。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>可以用函数和闭包构造模块。</p><p>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberCal = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> half = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> double = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tribble = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        half: half,</span><br><span class="line">        double: double,</span><br><span class="line">        tribble: tribble</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.half(<span class="number">5</span>)) <span class="comment">//2.5</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.half(<span class="number">6</span>)) <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.double(<span class="number">7</span>)) <span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.tribble(<span class="number">7</span>)) <span class="comment">//21</span></span><br></pre></td></tr></table></figure><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>如果让方法返回<code>this</code>而不是默认的<code>undefined</code>，就可以启用级联，即连续调用。</p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。</p><p>详情见以前的博文 <a href="http://gaohaoyang.github.io/2015/06/11/JavaScript-function/#bind--currying" target="_blank" rel="noopener">JavaScript 函数 -bind 与 currying</a>。</p><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="对象 函数 this 闭包 面向对象 作用域" scheme="https://qccs.github.io/tags/%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0-this-%E9%97%AD%E5%8C%85-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>前端如何写一个精确的倒计时</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-11-25-how-to-write-a-count-down/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-11-25-how-to-write-a-count-down/</id>
    <published>2019-04-14T09:29:00.617Z</published>
    <updated>2019-04-14T09:29:00.617Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。</p><p><img src="https://img.alicdn.com/tfs/TB18QnlOpXXXXcVXpXXXXXXXXXX-388-256.png" alt></p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>众所周知 setTimeout 或者 setInterval 调用的时候会有微小的误差。有人做了一个 <a href="https://bl.ocks.org/kenpenn/raw/92ebaa71696b4c4c3acd672b1bb3f49a/" target="_blank" rel="noopener">demo</a> 来观察这个现象并对其做了修正。短时间的误差倒也可以接受，但是作为一个长时间的倒计时，误差累计就会导致倒计时不准确。</p><p>因此我们可以在获取剩余时间的时候，每次 new 一个设备时间，因为设备时间的流逝相对是准确的，并且如果设备打开了网络时间同步，也会解决这个问题。</p><p>但是，如果用户修改了设备时间，那么整个倒计时就没有意义了，用户只要将设备时间修改为倒计时的 endTime 就可以轻易看到倒计时结束是页面的变化。因此一开始获取服务端时间就是很重要的。</p><p>简单的说，一个简单的精确倒计时原理如下：</p><ul><li>初始化时请求一次服务器时间 serverTime，再 new 一个设备时间 deviceTime</li><li>deviceTime 与 serverTime 的差作为时间偏移修正</li><li>每次递归时 new 一个系统时间，解决 setTimeout 不准确的问题</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>获取剩余时间的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取剩余时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; endTime    截止时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; deviceTime 设备时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; serverTime 服务端时间</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125;            剩余时间对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> getRemainTime = <span class="function">(<span class="params">endTime, deviceTime, serverTime</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = endTime - <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) - serverTime + deviceTime</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="built_in">Math</span>.floor((t / <span class="number">1000</span>) % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor((t / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor((t / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)) % <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">let</span> days = <span class="built_in">Math</span>.floor(t / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>))</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'total'</span>: t,</span><br><span class="line">        <span class="string">'days'</span>: days,</span><br><span class="line">        <span class="string">'hours'</span>: hours,</span><br><span class="line">        <span class="string">'minutes'</span>: minutes,</span><br><span class="line">        <span class="string">'seconds'</span>: seconds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>获取服务器时间可以使用 mtop 接口 <code>mtop.common.getTimestamp</code> </del></p><p>然后可以通过下面的方式来使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务端时间（获取服务端时间代码略）</span></span><br><span class="line">getServerTime(<span class="function">(<span class="params">serverTime</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    <span class="keyword">let</span> intervalTimer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        <span class="keyword">let</span> remainTime = getRemainTime(endTime, deviceTime, serverTime)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒计时到两个小时内</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime.total &lt;= <span class="number">7200000</span> &amp;&amp; remainTime.total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒计时结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainTime.total &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            clearInterval(intervalTimer);</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的的写法也可以做到准确倒计时，同时也比较简洁。不需要隔段时间再去同步一次服务端时间。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在写倒计时的时候遇到了一个坑这里记录一下。</p><p><strong>千万别在倒计时结束的时候请求接口</strong>。会让服务端瞬间 QPS 峰值达到非常高。</p><p><img src="https://img.alicdn.com/tfs/TB1LBzjOpXXXXcnXpXXXXXXXXXX-154-71.png" alt></p><p>如果在倒计时结束的时候要使用新的数据渲染页面，正确的做法是：</p><p>在倒计时结束前的一段时间里，先请求好数据，倒计时结束后，再渲染页面。</p><p>关于倒计时，如果你有什么更好的解决方案，欢迎评论交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tfs/TB18QnlOpXXXXcVXpXXXXXXXXXX-388-256.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="countdown JavaScript" scheme="https://qccs.github.io/tags/countdown-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 babel</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-06-14-how-to-use-babel/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-06-14-how-to-use-babel/</id>
    <published>2019-04-14T09:29:00.613Z</published>
    <updated>2019-04-14T09:29:00.613Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。</p><a id="more"></a><p><img src="https://babeljs.io/images/logo.svg" alt></p><p>学习 Babel 可以通过其手册 Babel handbook。</p><ul><li><a href="https://github.com/thejameskyle/babel-handbook" target="_blank" rel="noopener">babel-handbook</a></li></ul><p>其中包含多语言版本，分为<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">用户手册</a>和<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">插件手册</a>。这是一个很好的学习 Babel 的资料。</p><h2 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h2><p>在 node 和 npm 环境安装好的前提下，安装 babel，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global babel-cli</span><br></pre></td></tr></table></figure><p>安装完成后就可以编译文件了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel main.js</span><br></pre></td></tr></table></figure><p>编译后的文件显示在终端上，可以添加其他命令让它输出到指定文件下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel example.js --out-file compiled.js</span><br><span class="line">或</span><br><span class="line">babel example.js -o compiled.js</span><br></pre></td></tr></table></figure><p>或将整个目录编译成一个新的目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel src --out-dir lib</span><br><span class="line">或</span><br><span class="line">babel src -d lib</span><br></pre></td></tr></table></figure><p>但这很麻烦，并且并不是一个很好的解决方案，请看下一节项目内运行 babel-cli。</p><h2 id="在项目内运行-babel-cli"><a href="#在项目内运行-babel-cli" class="headerlink" title="在项目内运行 babel-cli"></a>在项目内运行 babel-cli</h2><p>初始化项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>再安装 babel-cli</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure><p>项目中的<code>package.json</code>应该包含如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"learn-es6"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-cli"</span>: <span class="string">"^6.10.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 npm scripts 命令。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name": "learn-es6",</span><br><span class="line">  "version": "1.0.0",</span><br><span class="line"><span class="addition">+   "scripts": &#123;</span></span><br><span class="line"><span class="addition">+     "build": "babel src -d lib"</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "babel-cli": "^6.10.1"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在终端里运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>还不能成功编译，因为没有配置<code>.babelrc</code>文件。</p><h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置<code>.babelrc</code></h2><p>通过配置<code>.babelrc</code>来告诉 babel 来做什么。</p><p>在项目的根路径下创建<code>.babelrc</code>文件。然后输入以下内容作为开始：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [],</span><br><span class="line">    <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让 babel 将 ES2015 转化为 ES5，我们要安装如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br></pre></td></tr></table></figure><p>安装完成后在<code>.babelrc</code>中添加参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "presets": [</span><br><span class="line"><span class="addition">+       "es2015"</span></span><br><span class="line">    ],</span><br><span class="line">    "plugins": []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在项目<code>src/main.js</code>中写一些 ES2015 的代码试试吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在终端中输入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>执行后终端中显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; learn-es6@1.0.0 build c:\gitWorkSpace\learn-es6</span><br><span class="line">&gt; babel src -d lib</span><br></pre></td></tr></table></figure><p>然后可以看到目录中出现了<code>lib/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>即编译成功。</p><h2 id="配置-jshintrc"><a href="#配置-jshintrc" class="headerlink" title="配置.jshintrc"></a>配置<code>.jshintrc</code></h2><p>若编辑器中安装了 jshint 语法检查的插件。默认对于 ES2015 的代码可能会报错或者警告，看着可能会不爽。我们可以在配置文件中将它设置为允许 ES2015 的模式。</p><p>在项目根目录下创建文件<code>.jshintrc</code>。内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"asi"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esversion"</span>: <span class="number">2015</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述文件我分别设置了，使用无分号模式，es 版本使用 2015。</p><p>关于<code>.jshintrc</code>的更详细配置可以参见官方示例：<a href="https://github.com/jshint/jshint/blob/master/examples/.jshintrc" target="_blank" rel="noopener">https://github.com/jshint/jshint/blob/master/examples/.jshintrc</a></p><p>好，babel 就说到这里，下面开始进入真正的 ES2015 的学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Babel&lt;/a&gt; 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="ES2015 ES6 ES5 babel" scheme="https://qccs.github.io/tags/ES2015-ES6-ES5-babel/"/>
    
  </entry>
  
  <entry>
    <title>提升用户体验的前端动画</title>
    <link href="https://qccs.github.io/2019/04/14/z/2018-06-01-animation/"/>
    <id>https://qccs.github.io/2019/04/14/z/2018-06-01-animation/</id>
    <published>2019-04-14T09:29:00.610Z</published>
    <updated>2019-04-14T09:29:00.610Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>与其他开发人员不同的是，前端开发都是在端上游走舞者，直接与用户交流沟通，这就需要前端开发具有更敏锐的交互体验思考，或者能更精准地理解设计师们意图，将最佳的用户体验带给用户。优质的交互体验对于用户来说学习成本应该是极低的，都是非常自然的操作，却可以让用户感到畅快愉悦，甚至惊喜。本文将通过一个看似简单的 poplayer 来分析我在这其中通过思考做的体验优化，获得类似 native 的体验感。</p><p><img src="https://ws1.sinaimg.cn/large/7011d6cfgy1frx9jv0kpfj208w0fracu.jpg" alt></p><a id="more"></a><blockquote><p>关于 poplayer 是什么，详见 <a href="https://github.com/amfe/article/issues/18" target="_blank" rel="noopener">POPLAYER起来HIGH~~</a></p></blockquote><p>简单的说下需求，这个弹层希望可以像 native 在商品详情页的弹层一样，从下向上滑出，点击遮罩或按钮时关闭。为了给用户带来更好的体验，我在这个基础上又增加了一些手势和过渡的动画效果，如下图。下面简单的拆分一下动画细节：</p><ul><li>页面载入，卡片向上滑入</li><li>增加 pan 的手势，卡片跟随手指滑动</li><li>随着手指滑动，增加遮罩透明度与卡片阴影变化</li><li>增加向上和向下的边界条件的处理</li></ul><h2 id="动画与手势的运用"><a href="#动画与手势的运用" class="headerlink" title="动画与手势的运用"></a>动画与手势的运用</h2><p>这些动画利用 CSS 3 的一些属性再加上手势操作即可完成，这里手势操作我选择了老牌的 <a href="https://hammerjs.github.io/" target="_blank" rel="noopener">HammerJS</a>。</p><p>点击超级会员专享，折上95折 banner，卡片向上滑入</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072164318.mp4" autoplay controls preload loop muted width="300px"></video><p>这里直接使用 <code>transition</code> 控制过渡。发生样式变化的有 3 个地方：</p><ul><li>卡片位置，使用 <code>transform: translateY</code> 控制纵向位置</li><li>遮罩透明度，随着卡片上滑，背景遮罩由透明变为半透明</li><li>卡片的阴影，注意仔细观察，随着卡片的上滑，为了凸显出弹层是悬浮在底层的视觉效果，其阴影的 <code>blur</code>,<code>spread</code>,<code>color</code> 也跟随变重</li></ul><p>下面再加入 pan 手势，即拖拽或平移，这里我们使用这个手势实现弹层的拖拽和相关动画。手指不离开屏幕进行滑动操作，如下图：</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072178262.mp4" controls preload loop muted width="300px"></video><p>我们把最外层容器节点作为参数，实例化 hammer 对象，默认 pan 手势只有横向操作，这里设置为所有方向。在监听 pandown panup 时，根据手指移动的差值控制卡片位置、背景遮罩透明度、卡片阴影的样式。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hammer = <span class="keyword">new</span> Hammer(containerEl)</span><br><span class="line">hammer.get(<span class="string">'pan'</span>).set(&#123; <span class="attr">direction</span>: Hammer.DIRECTION_ALL &#125;)</span><br><span class="line">hammer.on(<span class="string">'pandown panup'</span>, panDownUp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> panDownUp = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> opacity = <span class="number">0.7</span> - ev.deltaY / <span class="number">1024</span></span><br><span class="line">  coverEle.style.opacity = opacity</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boxShadowBlur = <span class="number">12</span> - ev.deltaY / <span class="number">46</span></span><br><span class="line">  <span class="keyword">const</span> boxShadowSpread = <span class="number">3</span> - ev.deltaY / <span class="number">180</span></span><br><span class="line">  <span class="keyword">const</span> boxShadowColorAlpha = <span class="string">''</span></span><br><span class="line">  popWrapEle.style.boxShadow = <span class="string">`0 0 <span class="subst">$&#123;boxShadowBlur&#125;</span>px <span class="subst">$&#123;boxShadowSpread&#125;</span>px rgba(0,0,0,<span class="subst">$&#123;opacity&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scrollY = ev.deltaY * <span class="number">1.2</span></span><br><span class="line">  popWrapEle.style.transform = <span class="string">`translateY(<span class="subst">$&#123;scrollY&#125;</span>px)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于各个样式属性的值，通过乘系数等方式得到需要的值。</p><p>这里要注意，pan 的操作中是不需要原有的 transition 过渡的，因为滑动操作时，希望让动画非常跟手，而 transition 是一个消耗时间的过渡，而且多次触发 transition 也会导致性能问题，我们要在 panstart 将其移除，panend 再加回来，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hammer.on(<span class="string">'panstart'</span>, () =&gt; &#123;</span><br><span class="line">  popWrapEle.classList.remove(<span class="string">'pop-wrap-transition'</span>)</span><br><span class="line">  coverEle.classList.remove(<span class="string">'cover-transition'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hammer.on(<span class="string">'panend'</span>, (ev) =&gt; &#123;</span><br><span class="line">  popWrapEle.classList.add(<span class="string">'pop-wrap-transition'</span>)</span><br><span class="line">  coverEle.classList.add(<span class="string">'cover-transition'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="向下滑出的处理"><a href="#向下滑出的处理" class="headerlink" title="向下滑出的处理"></a>向下滑出的处理</h2><p>用户在向下滑动松手时的距离，如果大于某个值，让卡片滑出，关闭 poplayer，小于某个值，则回弹到原位。</p><p>这比较符合用户体验、防止误关闭，同时滑出的关闭方式也给了用户一种流畅感。经过本人多次测试，最终选择的下滑临界值为 180。效果如下图：</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072156428.mp4" controls preload loop muted width="300px"></video><p>在 panend 事件中加入这个逻辑判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hammer.on(<span class="string">'panend'</span>, (ev) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev.deltaY &gt; <span class="number">180</span>) &#123;</span><br><span class="line">    closePoplayer()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    popWrapEle.style.transform = <span class="string">'translateY(0)'</span></span><br><span class="line">    popWrapEle.style.boxShadow = <span class="string">'0 0 12px 3px rgba(0,0,0,.74)'</span></span><br><span class="line">    coverEle.style.opacity = <span class="string">'0.7'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="向上滑动的溢出感"><a href="#向上滑动的溢出感" class="headerlink" title="向上滑动的溢出感"></a>向上滑动的溢出感</h2><p>这个卡片本身是无法再向上滑动的，但是如果用户想继续滑呢？为了让这个弹层增添一些活力，我在这个操作中让卡片微微膨胀，增添亲和力，仿佛用户想滑动它，但是它又存在着一股粘滞力无法大距离的移动，甚至满足了用户心中的小小控制欲。</p><p>效果如下：</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072160378.mp4" controls preload loop muted width="300px"></video><p>在向上滑动事件中加入如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> panDownUp = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev.deltaY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ev.deltaY)</span><br><span class="line">    <span class="keyword">const</span> scrollUpY = ev.deltaY / <span class="number">80</span></span><br><span class="line">    <span class="keyword">const</span> scaleX = -ev.deltaY / <span class="number">20000</span> + <span class="number">1</span></span><br><span class="line">    popWrapEle.style.transform = <span class="string">`scale(<span class="subst">$&#123;scaleX&#125;</span>) translateY(<span class="subst">$&#123;scrollUpY&#125;</span>px)`</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他小坑"><a href="#其他小坑" class="headerlink" title="其他小坑"></a>其他小坑</h2><p>webkit 前缀。ios 8 下部分 CSS 3 属性需要添加 <code>-webkit-</code> 前缀。参考<a href="http://www.ayqy.net/blog/flexbox%E5%B8%83%E5%B1%80%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/" target="_blank" rel="noopener">flexbox布局的兼容性</a>。</p><p>覆盖 status bar。iOS 11 起，需要在 meta 标签中添加 <code>viewport-fit=cover</code>，才能使得 webView 覆盖到顶部的 status bar，meta 标签最终可以写为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"viewport-fit=cover,width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>交互体验体现在各个细节之中，没有大而全的规则，但整体方向就是让用户在使用软件的时候感到更加的自然畅快。而动画只是交互体验中的一小部分。</p><p>我认为前端的本质，就是将最优质的用户体验带给用户，我也在为之不断努力，欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与其他开发人员不同的是，前端开发都是在端上游走舞者，直接与用户交流沟通，这就需要前端开发具有更敏锐的交互体验思考，或者能更精准地理解设计师们意图，将最佳的用户体验带给用户。优质的交互体验对于用户来说学习成本应该是极低的，都是非常自然的操作，却可以让用户感到畅快愉悦，甚至惊喜。本文将通过一个看似简单的 poplayer 来分析我在这其中通过思考做的体验优化，获得类似 native 的体验感。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/7011d6cfgy1frx9jv0kpfj208w0fracu.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="动画 手势" scheme="https://qccs.github.io/tags/%E5%8A%A8%E7%94%BB-%E6%89%8B%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>从设计师和开发的角度使用 lottie</title>
    <link href="https://qccs.github.io/2019/04/14/z/2018-09-10-lottie/"/>
    <id>https://qccs.github.io/2019/04/14/z/2018-09-10-lottie/</id>
    <published>2019-04-14T09:29:00.599Z</published>
    <updated>2019-04-14T09:29:00.600Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p><img src="https://gw.alicdn.com/tfs/TB1yLBduDqWBKNjSZFAXXanSpXa-800-600.gif" alt></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">lottie</a> 是一个可以轻易的给各种 native app 添加高质量动画的类库。可以在 iOS、Android 和 React Native 实时渲染 After Effects 动画，就像使用静态图片一样容易。上图即为 lottie 的 logo。</p><p>简单的说，lottie 动画制作的流程是，通过 Bodymovin 扩展将 AE 动画导出为 json 数据，然后再将这个 json 渲染在客户端或者 web 端。如下图：</p><a id="more"></a><p><img src="https://gw.alicdn.com/tfs/TB1G3F7u67nBKNjSZLeXXbxCFXa-617-255.png" alt></p><p>官网宣传了3个特性：</p><ul><li>灵活使用AE的特性</li><li>随心所欲控制你的动画</li><li>很小的文件体积</li></ul><p>个人认为 lottie 最大的优势就是可以将设计师设计的动图原原本本的在页面上展现出来，完美还原了动画的精细度，并且对动画拥有足够的控制能力。目前所有使用 gif 或 apng 的场景应该都可以使用 lottie，当然 lottie 不局限与此场景。</p><p>本文主要从设计师视角和开发者视角讲述 lottie-web 的原理和使用以及 lottie 在 weex/rax 中的使用。</p><p><a href="https://gaohaoyang.github.io/lottie-test/" target="_blank" rel="noopener">Demo</a></p><video src="http://cloud.video.taobao.com//play/u/4121310810/p/1/e/6/t/1/50255502072.mp4" autoplay controls preload loop muted width="300px"></video><p><img src="https://gw.alicdn.com/tfs/TB1xhmyutcnBKNjSZR0XXcFqFXa-300-300.png" alt></p><iframe width="375px" height="500px" src="https://gaohaoyang.github.io/lottie-test/" frameborder="0"></iframe><h2 id="设计师视角"><a href="#设计师视角" class="headerlink" title="设计师视角"></a>设计师视角</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在 AE 中为 lottie 创作动画，你需要以下准备</p><ul><li><a href="https://www.adobe.com/products/aftereffects.html" target="_blank" rel="noopener">Adobe After Effects</a></li><li><a href="http://airbnb.io/lottie/after-effects/bodymovin-installation.html" target="_blank" rel="noopener">Bodymovin AE 插件</a></li><li>Lottiefiles preview app (集成了 lottie sdk 的 app)</li></ul><p>安装 Bodymovin 插件的流程如下：</p><ol><li>关闭 AE</li><li>安装 ZXP installer。 ZXP Installer 就是专门用来安装 Adobe 公司的软件产品的插件的工具。</li><li>下载最新的 bodymovin 扩展。<br><a href="https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp" target="_blank" rel="noopener">https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp</a><br><img src="https://gw.alicdn.com/tfs/TB1Q6dipMZC2uNjSZFnXXaxZpXa-2012-620.png" alt></li><li>打开 ZXP installer 并把 bodymovin 扩展拖拽进来</li><li>打开 AE，在菜单 <code>Window &gt; Extensions</code> 中，你会看到安装好的扩展</li></ol><p>安装插件详见 <a href="http://airbnb.io/lottie/after-effects/bodymovin-installation.html" target="_blank" rel="noopener">http://airbnb.io/lottie/after-effects/bodymovin-installation.html</a></p><h3 id="从-Sketch-SVG-Illustrator-到-Lottie-的工作流"><a href="#从-Sketch-SVG-Illustrator-到-Lottie-的工作流" class="headerlink" title="从 Sketch/SVG/Illustrator 到 Lottie 的工作流"></a>从 Sketch/SVG/Illustrator 到 Lottie 的工作流</h3><p>下面讲讲如何从 Sketch 开始，制作一个 lottie 动画文件。如果你使用 svg 图片，跳到步骤3。如果你使用 AI，跳到步骤4。需要准备好 Sketch，AI，AE，并安装好 Bodymovin 插件。下面开始：</p><ol><li>在 sketch 中确保要导出的内容已经群组为一个 group</li><li>将这个 group 导出为 svg</li><li>在 AI 中打开 svg，并转存为 <code>.ai</code> 文件</li><li>将 <code>.ai</code> 文件导入到 AE 中</li><li>在 AE 中创建组件，设置动画持续时间和帧率</li><li>将 ai 文件转为 shape layers。<br>在组件中选中你的图层，菜单 Layer 中选择 Create shapes from vector layer</li><li><strong>添加你想要的任何动画，这一部分是你主要工作的步骤</strong></li><li>使用 Bodymovin 导出为 json<br>菜单中选择 Window &gt; Extensions &gt; Bodymovin</li><li>测试动画。<br>确保动画中没有<a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">不支持的特性</a>，然后可以拖拽到 <a href="https://www.lottiefiles.com/" target="_blank" rel="noopener">lottieFiles</a> 中查看效果。<br>当然也可以上传到 lottieFiles 里，然后使用 lottie preview app 扫码查看。<br>这时你就可以将动画交付给开发同学啦！</li></ol><p>更多细节可查看官方文档 <a href="http://airbnb.io/lottie/after-effects/artwork-to-lottie-walkthrough.html" target="_blank" rel="noopener">Sketch/SVG/Illustrator to Lottie workflow</a></p><h3 id="注意事项-amp-优化建议"><a href="#注意事项-amp-优化建议" class="headerlink" title="注意事项&amp;优化建议"></a>注意事项&amp;优化建议</h3><p>*AE 特性大部分已经支持，具体可以查看 <a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">Supported Features（支持列表）</a>，设计师应该避免使用不支持 AE 的特性。</p><p>目前开看，支持较好的属性有：</p><ul><li>Shapes</li><li>Fills</li><li>Strokes</li><li>Transforms</li><li>Interpolation</li></ul><p>不完全支持的属性分类有：</p><ul><li>Masks</li><li>Mattes</li><li>Merge Paths</li><li>Layer Effects</li><li>Text</li></ul><p><a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener"><img src="https://gw.alicdn.com/tfs/TB1ndK3uBsmBKNjSZFFXXcT9VXa-795-535.png" alt></a></p><p>*设计过程中的优化建议和注意事项 <a href="http://airbnb.io/lottie/after-effects/general-tips.html" target="_blank" rel="noopener">General tips &amp; guidelines</a></p><ul><li>尽量保持简单小巧<br>在相同的图层上复制相同的关键帧会增加额外的代码，只有在必要时才使用路径关键帧动画。</li><li>导出 1x 图</li><li>No expressions or effects<br>Lottie 还不支持 expressions 或 effects 菜单中的任何 effects</li><li>Matte and mask 尺寸问题<br>使用半透明遮罩会影响性能。如果必须使用遮罩，请覆盖最小的区域。</li><li>不支持 Blending modes 或 Luma mattes</li><li>不支持图层样式<br>图层效果不支持drop shadow, color overlay 或 stroke</li><li>全屏动画，导出比最大屏幕宽度更宽一点的图像，在 Android 和 iOS 上可以分别裁切<br><img src="http://airbnb.io/lottie/images/LottieFullScreen.gif" alt></li></ul><h2 id="开发者视角"><a href="#开发者视角" class="headerlink" title="开发者视角"></a>开发者视角</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先当然是看<a href="http://airbnb.io/lottie/" target="_blank" rel="noopener">开发文档</a>。这里我简单说说其中 lottie-web 的使用。</p><p>可以通过 script 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.com/libraries/bodymovin"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或 npm 包 <a href="https://www.npmjs.com/package/lottie-web" target="_blank" rel="noopener">lottie-web</a> 引用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S lottie-web</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lottie <span class="keyword">from</span> <span class="string">'lottie-web'</span></span><br></pre></td></tr></table></figure><p>调用 loadAnimation()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myLottie = lottie.loadAnimation(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.querySelector(<span class="string">'.img-area'</span>),</span><br><span class="line">  renderer: <span class="string">'svg'</span>,</span><br><span class="line">  name: <span class="string">'myLottieAnim'</span>,</span><br><span class="line">  loop: <span class="literal">true</span>,</span><br><span class="line">  autoplay: <span class="literal">true</span>,</span><br><span class="line">  path: <span class="string">'./assets/cycle_animation.json'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="参数-api-事件"><a href="#参数-api-事件" class="headerlink" title="参数/api/事件"></a>参数/api/事件</h3><p>loadAnimation 的参数</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>container</td><td>用于渲染的容器，一般使用一个 div 即可</td></tr><tr><td>renderer</td><td>渲染器，可以选择 ‘svg’ / ‘canvas’ / ‘html’，个人测试发现 svg 效果和兼容性最好</td></tr><tr><td>name</td><td>动画名称，用于 reference</td></tr><tr><td>loop</td><td>循环</td></tr><tr><td>autoplay</td><td>自动播放</td></tr><tr><td>path</td><td>json 路径，页面会通过一个 http 请求获取 json</td></tr><tr><td>animationData</td><td>json 动画数据，与 path 互斥，建议使用 path，因为 animationData 会将数据打包进来，会使得 js bundle 过大</td></tr></tbody></table><p>获取到 lottie 实例后，可以调用 api 控制动画，例如上述代码中可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myLottie.pause()</span><br></pre></td></tr></table></figure><p>相关 api</p><table><thead><tr><th>名称</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>stop</td><td>无</td><td>停止动画</td></tr><tr><td>play</td><td>无</td><td>播放动画</td></tr><tr><td>pause</td><td>无</td><td>暂停</td></tr><tr><td>setSpeed</td><td>Number</td><td>设置播放速度，1 表示1倍速度，0.5 表示 0.5倍速度</td></tr><tr><td>setDirection</td><td>Number</td><td>正反向播放，1 表示 正向，-1 表示反向</td></tr><tr><td>goToAndStop</td><td>Number, [Boolean]</td><td>跳到某一帧或某一秒停止，第二个参数 iFrame 为是否基于帧模式还是时间，默认为 false</td></tr><tr><td>goToAndPlay</td><td>Number, [Boolean]</td><td>跳到某一帧或某一秒开始，第二个参数 iFrame 为是否基于帧模式还是时间，默认为 false</td></tr><tr><td>playSegments</td><td>Array, [Boolean]</td><td>播放片段，参数1为数组，两个元素为开始帧和结束帧；参数2为，是否立即播放片段，还是等之前的动画播放完成</td></tr><tr><td>destroy</td><td>无</td><td>销毁</td></tr></tbody></table><p>事件</p><ul><li>onComplete</li><li>onLoopComplete</li><li>onEnterFrame</li><li>onSegmentStart</li></ul><p>也可以使用 addEventListener 监听以下事件</p><ul><li>complete</li><li>loopComplete</li><li>enterFrame</li><li>segmentStart</li><li>config_ready (when initial config is done)</li><li>data_ready (when all parts of the animation have been loaded)</li><li>data_failed (when part of the animation can not be loaded)</li><li>loaded_images (when all image loads have either succeeded or errored)</li><li>DOMLoaded (when elements have been added to the DOM)</li><li>destroy</li></ul><p>具体也可以查看<a href="https://github.com/airbnb/lottie-web/" target="_blank" rel="noopener">组件文档</a></p><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><ul><li>使用压缩混淆过的 js，毕竟目前 lottie-web 还是有点大，gzip 后大概 57k</li><li>尽量使用简单小巧的 json，其实也是需要在 AE 中做一些优化，这需要前端和设计一起配合完成，例如<ul><li>避免使用很大的形状，但是用很小的 mask 切出来</li><li>太多的节点也会影响性能</li></ul></li></ul><h2 id="weex-rax-中使用-lottie"><a href="#weex-rax-中使用-lottie" class="headerlink" title="weex/rax 中使用 lottie"></a>weex/rax 中使用 lottie</h2><p>weex/rax 已经提供了 lottie 组件，由于是内部文档，暂不放链接。</p><p>api 支持没有 airbnb 官方完整，投入生产环境时还需要严格测试一下</p><p><a href="http://dotwe.org/vue/946e8283f5cf31cfab2f923ec8cea07c" target="_blank" rel="noopener">vue-weex demo</a></p><p><img src="https://gw.alicdn.com/tfs/TB1h65XuCMmBKNjSZTEXXasKpXa-256-256.png" alt></p><p>使用<a href="http://web.npm.alibaba-inc.com/package/@ali/rax-lottie" target="_blank" rel="noopener">@ali/rax-lottie</a> 的 <a href="https://market.m.taobao.com/app/tmall-wireless/rax-life-progress/pages/my-lottie?wh_weex=true" target="_blank" rel="noopener">rax demo</a> 如下</p><p><a href="https://market.m.taobao.com/app/tmall-wireless/rax-life-progress/pages/my-lottie?wh_weex=true" target="_blank" rel="noopener"><img src="https://gw.alicdn.com/tfs/TB16qbPuBjTBKNjSZFwXXcG4XXa-200-200.png" alt></a></p><video src="http://cloud.video.taobao.com//play/u/4121310810/p/1/e/6/t/1/50255438306.mp4" autoplay controls preload loop muted width="300px"></video><iframe width="375px" height="200px" src="https://market.m.taobao.com/app/tmall-wireless/rax-life-progress/pages/my-lottie?wh_weex=true" frameborder="0"></iframe><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在我看来，追求更精细完美的动画体验一直是设计师和前端开发的使命。lottie 的出现可以替代传统的 gif，并且提供的 api 可以更好的控制动画。lottie 可能不适合用于过于复杂的大场景动画，但是局部的小动画，再适合不过了。</p><p>lottie 应该是一个发展趋势，甚至未来浏览器说不定就原生直接支持了这种 json 动画，设计和开发之间的壁垒也会越来越小。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://gw.alicdn.com/tfs/TB1yLBduDqWBKNjSZFAXXanSpXa-800-600.gif&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://airbnb.design/lottie/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lottie&lt;/a&gt; 是一个可以轻易的给各种 native app 添加高质量动画的类库。可以在 iOS、Android 和 React Native 实时渲染 After Effects 动画，就像使用静态图片一样容易。上图即为 lottie 的 logo。&lt;/p&gt;
&lt;p&gt;简单的说，lottie 动画制作的流程是，通过 Bodymovin 扩展将 AE 动画导出为 json 数据，然后再将这个 json 渲染在客户端或者 web 端。如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="动画 CSS airbnb lottie JavaScript" scheme="https://qccs.github.io/tags/%E5%8A%A8%E7%94%BB-CSS-airbnb-lottie-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 JavaScript 创建并下载文件</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-11-22-js-create-file-and-download/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-11-22-js-create-file-and-download/</id>
    <published>2019-04-14T09:29:00.592Z</published>
    <updated>2019-04-14T09:29:00.593Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。</p><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并下载文件</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125; fileName 文件名</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125; content  文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAndDownloadFile</span>(<span class="params">fileName, content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aTag = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line">    aTag.download = fileName;</span><br><span class="line">    aTag.href = URL.createObjectURL(blob);</span><br><span class="line">    aTag.click();</span><br><span class="line">    URL.revokeObjectURL(blob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。</p><a id="more"></a><p><img src="https://img.alicdn.com/tfs/TB16.GnOpXXXXXdapXXXXXXXXXX-307-134.png" alt></p><h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 对象是一个字节序列。拥有 <code>size</code> 和 <code>type</code> 等属性。</p><p>拥有 2 个只读状态 <code>OPEND</code> 和 <code>CLOSED。</code></p><p>Blob 对象属于 JavaScript Web APIs 中的 File API 规定的部分，可以参考 W3C 文档中的 <a href="https://www.w3.org/TR/2015/WD-FileAPI-20150421/#blob" target="_blank" rel="noopener"> The Blob Interface and Binary Data</a></p><p>再回来看看我们的代码里是这么写的，使用了 Blob 的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([content]);</span><br></pre></td></tr></table></figure><p>使用方括号的原因是，其构造函数的参数为以下4中：</p><ul><li>ArrayBuffer [TypedArrays] elements.</li><li>ArrayBufferView [TypedArrays] elements.</li><li>Blob elements.</li><li>DOMString [WebIDL] elements.</li></ul><p>所谓 <code>ArrayBuffer</code> 是一种用于呈现通用、固定长度的二进制数据的类型。详情可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer -MDN</a> 以及 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arraybuffer-objects" target="_blank" rel="noopener">ECMAScript2015 标准中的 ArrayBuffer</a>。</p><h2 id="Blob-URLs"><a href="#Blob-URLs" class="headerlink" title="Blob URLs"></a>Blob URLs</h2><p>Blob URLs 被创建或注销是使用 <code>URL</code> 对象上的方法。这个 <code>URL</code> 对象被挂在 <code>Window</code> (HTML) 对象下，或者 <code>WorkerGlobalScope</code> (Web Workers)对象下。</p><p>拥有以下静态方法 <code>createObjectURL</code> 和 <code>revokeObjectURL</code>，用于创建一个 blob 对象的 url 和注销这个 blob url。</p><p>详情可查看 <a href="https://www.w3.org/TR/2015/WD-FileAPI-20150421/#creating-revoking" target="_blank" rel="noopener">关于创建和注销 Blob URL 的 W3C 标准文档</a></p><h2 id="模拟-click"><a href="#模拟-click" class="headerlink" title="模拟 click"></a>模拟 click</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.click();</span><br></pre></td></tr></table></figure><p>在 W3C 中很早就有这个<a href="https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-2651361" target="_blank" rel="noopener">规范</a>，不需要写繁琐的模拟事件触发的代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.alloyteam.com/2014/01/use-js-file-download/" target="_blank" rel="noopener">在浏览器端用JS创建和下载文件 -alloyteam</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。&lt;/p&gt;
&lt;h2 id=&quot;先上代码&quot;&gt;&lt;a href=&quot;#先上代码&quot; class=&quot;headerlink&quot; title=&quot;先上代码&quot;&gt;&lt;/a&gt;先上代码&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 创建并下载文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @param  &amp;#123;String&amp;#125; fileName 文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @param  &amp;#123;String&amp;#125; content  文件内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createAndDownloadFile&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fileName, content&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; aTag = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; blob = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Blob([content]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    aTag.download = fileName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    aTag.href = URL.createObjectURL(blob);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    aTag.click();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    URL.revokeObjectURL(blob);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="文件 下载 JavaScript" scheme="https://qccs.github.io/tags/%E6%96%87%E4%BB%B6-%E4%B8%8B%E8%BD%BD-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记3-方法、毒瘤等</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-06-10-JavaScript-good-parts-note3/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-06-10-JavaScript-good-parts-note3/</id>
    <published>2019-04-14T09:29:00.575Z</published>
    <updated>2019-04-14T09:29:00.575Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。</p><a id="more"></a><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这一章主要介绍了一些方法集。这里写几个我不太熟悉的方法和要点吧。</p><ul><li><p><code>array.join()</code></p><blockquote><p>对于IE6/7，使用<code>array.join()</code>连接大量字符串的效率确实优于使用<code>+</code>元素运算符。但是目前主流的浏览器，包括IE8以后的版本，都对<code>+</code>元素运算符连接字符串做了特别优化，性能已经显著高于<code>array.join()</code>。</p></blockquote></li><li><p><code>number.toExponential(fractionDigits)</code></p><p>  把这个<code>number</code>转换成一个指数形式的字符串。</p></li><li><p><code>number.toFixed(fractionDigits)</code></p><p>  将这个<code>number</code>转换成一个十进制形式的字符串。</p></li></ul><h2 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h2><ul><li><p>注意全局变量的引入。</p></li><li><p>JavaScript 中 Unicode 是16位的。包含65536个字符（基本多文种平面 Basic Multilingual Plane）。剩下的百万字符中的每一个都可以用一对字符来表示。Unicode 把一对字符视为一个单一的字符，而 JavaScript 认为一对字符是两个不同的字符。</p></li><li><p>检测<code>null</code>的方式。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line">myValue === <span class="literal">null</span> <span class="comment">//检测 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myValue &amp;&amp; <span class="keyword">typeof</span> myValue === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// myValue 是一个对象或数组！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>parseInt</code> 把字符串转化为整数的函数。它遇到非数字时会停止解析，所以<code>parseInt(&#39;16&#39;)</code>和<code>parseInt(&#39;16ton&#39;)</code>产生相同的结果。</p><p>  如果该字符串第一个字符是0，那么该字符串会基于八进制而不是十进制来求职。在八进制中，8和9不是数字，所以<code>parseInt(&#39;08&#39;)</code>和<code>parseInt(&#39;09&#39;)</code>都产生0作为结果。但<code>parseInt()</code>可以接受基数，因此<code>parseInt(&#39;08&#39;,10)</code>结果为8，建议总是加上这个基数参数。</p></li><li><p>JavaScript 的对象永远不会是真的空对象，因为它们可以送原型链中取得成员属性。</p></li></ul><h2 id="糟粕"><a href="#糟粕" class="headerlink" title="糟粕"></a>糟粕</h2><ul><li><p>避免使用<code>with</code>语句。</p></li><li><p>避免使用<code>eval</code>语句。</p></li><li><p><code>continue</code>可能会降低运算性能。</p></li><li><p>位运算符在 JavaScript 会非常慢。</p><p>  Java 里，位运算符处理的是整数。JavaScript 没有整数类型，它只有双精度的浮点数，因此，位运算符把它们的数字运算数先转换为整数，执行运算，在转换回去。JavaScript 的执行环境一般接触不到硬件，所以非常慢。</p></li><li><p>避免使用包装对象。<code>new Object</code>和<code>new Array</code>等。</p></li><li><p>避免使用<code>void</code>。</p></li></ul><p>本系列结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="函数 JavaScript" scheme="https://qccs.github.io/tags/%E5%87%BD%E6%95%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Fisher–Yates shuffle 洗牌算法</title>
    <link href="https://qccs.github.io/2019/04/14/z/2016-10-16-shuffle-algorithm/"/>
    <id>https://qccs.github.io/2019/04/14/z/2016-10-16-shuffle-algorithm/</id>
    <published>2019-04-14T09:29:00.568Z</published>
    <updated>2019-04-14T09:29:00.568Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p><p>本文主要介绍这个算法的来源、演变、原理。并举出一个例子为大家清晰的描述每次迭代过程。最后使用 JavaScript 代码将算法实现。<br><a id="more"></a><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Riffle_shuffle.jpg/320px-Riffle_shuffle.jpg" alt></p><h2 id="Fisher-and-Yates-的原始版"><a href="#Fisher-and-Yates-的原始版" class="headerlink" title="Fisher and Yates 的原始版"></a>Fisher and Yates 的原始版</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Biologist_and_statistician_Ronald_Fisher.jpg/189px-Biologist_and_statistician_Ronald_Fisher.jpg" alt></p><p>Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher（上图） 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：</p><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。</p><h2 id="现代方法"><a href="#现代方法" class="headerlink" title="现代方法"></a>现代方法</h2><p>Fisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。</p><p>现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。<strong>这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后</strong>。这样就将时间复杂度从 O(n^2) 减小到了 <strong>O(n)</strong>。算法的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- To shuffle an array a of n elements (indices 0..n-1):</span><br><span class="line">for i from n−1 downto 1 do</span><br><span class="line">     j ← random integer such that 0 ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="迭代步骤演示"><a href="#迭代步骤演示" class="headerlink" title="迭代步骤演示"></a>迭代步骤演示</h3><p>根据每次迭代次数可以用下面的表格，描述这个算法的执行过程</p><table><thead><tr><th style="text-align:left">随机数取值范围</th><th style="text-align:left">随机数</th><th style="text-align:right">原始数据</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:right">1 2 3 4 5 6 7 8</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1-8</td><td style="text-align:left">6</td><td style="text-align:right">1 2 3 4 5 7 8</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">1-7</td><td style="text-align:left">2</td><td style="text-align:right">1 7 3 4 5 8</td><td style="text-align:left">2 6</td></tr><tr><td style="text-align:left">1–6</td><td style="text-align:left">6</td><td style="text-align:right">1 7 3 4 5</td><td style="text-align:left">8 2 6</td></tr><tr><td style="text-align:left">1–5</td><td style="text-align:left">1</td><td style="text-align:right">5 7 3 4</td><td style="text-align:left">1 8 2 6</td></tr><tr><td style="text-align:left">1–4</td><td style="text-align:left">3</td><td style="text-align:right">5 7 4</td><td style="text-align:left">3 1 8 2 6</td></tr><tr><td style="text-align:left">1–3</td><td style="text-align:left">3</td><td style="text-align:right">5 7</td><td style="text-align:left">4 3 1 8 2 6</td></tr><tr><td style="text-align:left">1–2</td><td style="text-align:left">1</td><td style="text-align:right">7</td><td style="text-align:left">5 4 3 1 8 2 6</td></tr></tbody></table><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p>下面这个动画就是整个数组 0-19 的随机排序过程</p><iframe height="317" scrolling="no" src="//codepen.io/haoyang/embed/jrvrQq/?height=317&theme-id=dark&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/haoyang/pen/jrvrQq/" target="_blank" rel="noopener">Fisher–Yates shuffle</a> by Chuan shi (<a href="http://codepen.io/haoyang" target="_blank" rel="noopener">@haoyang</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h2 id="JavaScript-代码实现"><a href="#JavaScript-代码实现" class="headerlink" title="JavaScript 代码实现"></a>JavaScript 代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fisher–Yates shuffle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = input.length<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">var</span> itemAtIndex = input[randomIndex];</span><br><span class="line"></span><br><span class="line">        input[randomIndex] = input[i];</span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式也很简单，直接用数组调用这个方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>].shuffle()</span><br><span class="line"></span><br><span class="line"><span class="comment">//[4, 6, 3, 2, 5, 1, 7, 8] // 每次结果都是随机的</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，Fisher–Yates shuffle 算法是一个非常高效又公平的随机排序算法，如果有随机排序数组的需求，用这个就对了！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="noopener">Fisher–Yates shuffle From Wikipedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。&lt;/p&gt;
&lt;p&gt;本文主要介绍这个算法的来源、演变、原理。并举出一个例子为大家清晰的描述每次迭代过程。最后使用 JavaScript 代码将算法实现。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="算法 shuffle 乱序 洗牌" scheme="https://qccs.github.io/tags/%E7%AE%97%E6%B3%95-shuffle-%E4%B9%B1%E5%BA%8F-%E6%B4%97%E7%89%8C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E4%B8%93%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E4%B8%93%E9%A2%98%E4%B9%8BjQuery%E9%80%9A%E7%94%A8%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95each%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://qccs.github.io/2019/04/14/专题系列文章/JavaScript专题之jQuery通用遍历方法each的实现/</id>
    <published>2019-04-14T09:21:22.761Z</published>
    <updated>2019-04-14T09:21:22.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript专题之jQuery通用遍历方法each的实现"><a href="#JavaScript专题之jQuery通用遍历方法each的实现" class="headerlink" title="JavaScript专题之jQuery通用遍历方法each的实现"></a>JavaScript专题之jQuery通用遍历方法each的实现</h1><h2 id="each介绍"><a href="#each介绍" class="headerlink" title="each介绍"></a>each介绍</h2><p>jQuery 的 each 方法，作为一个通用遍历方法，可用于遍历对象和数组。</p><p>语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(object, [callback])</span><br></pre></td></tr></table></figure><a id="more"></a><p>回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">$.each( [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="function"><span class="keyword">function</span>(<span class="params">i, n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Item #"</span> + i + <span class="string">": "</span> + n );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item #0: 0</span></span><br><span class="line"><span class="comment">// Item #1: 1</span></span><br><span class="line"><span class="comment">// Item #2: 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line">$.each(&#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">lang</span>: <span class="string">"JS"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">i, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Name: "</span> + i + <span class="string">", Value: "</span> + n);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Name: name, Value: John</span></span><br><span class="line"><span class="comment">// Name: lang, Value: JS</span></span><br></pre></td></tr></table></figure><h2 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h2><p>尽管 ES5 提供了 forEach 方法，但是 forEach 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。但是对于 jQuery 的 each 函数，如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.each( [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="function"><span class="keyword">function</span>(<span class="params">i, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Item #"</span> + i + <span class="string">": "</span> + n );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item #0: 0</span></span><br><span class="line"><span class="comment">// Item #1: 1</span></span><br><span class="line"><span class="comment">// Item #2: 2</span></span><br></pre></td></tr></table></figure><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>那么我们该怎么实现这样一个 each 方法呢？</p><p>首先，我们肯定要根据参数的类型进行判断，如果是数组，就调用 for 循环，如果是对象，就使用 for in 循环，有一个例外是类数组对象，对于类数组对象，我们依然可以使用 for 循环。</p><p>更多关于类数组对象的知识，我们可以查看<a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">《JavaScript专题之类数组对象与arguments》</a></p><p>那么又该如何判断类数组对象和数组呢？实际上，我们在<a href="https://github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">《JavaScript专题之类型判断(下)》</a>就讲过jQuery 数组和类数组对象判断函数 isArrayLike 的实现。</p><p>所以，我们可以轻松写出第一版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length, i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( isArrayLike(obj) ) &#123;</span><br><span class="line">        length = obj.length;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line">            callback(i, obj[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">            callback(i, obj[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中止循环"><a href="#中止循环" class="headerlink" title="中止循环"></a>中止循环</h2><p>现在已经可以遍历对象和数组了，但是依然有一个效果没有实现，就是中止循环，按照 jQuery each 的实现，当回调函数返回 false 的时候，我们就中止循环。这个实现起来也很简单：</p><p>我们只用把：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(i, obj[i])</span><br></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback(i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轻松实现中止循环的功能。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>我们在实际的开发中，我们有时会在 callback 函数中用到 this，先举个不怎么恰当的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们给每个人添加一个 age 属性，age 的值为 18 + index</span></span><br><span class="line"><span class="keyword">var</span> person = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'kevin'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'daisy'</span>&#125;</span><br><span class="line">]</span><br><span class="line">$.each(person, <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span> + index;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure><p>这个时候，我们就希望 this 能指向当前遍历的元素，然后给每个元素添加 age 属性。</p><p>指定 this，我们可以使用 call 或者 apply，其实也很简单：</p><p>我们把：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback(i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback.call(obj[i], i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 this，我们再举个常用的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.each($(<span class="string">"p"</span>), <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="keyword">this</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>虽然我们经常会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是因为 $(“p”).each() 方法是定义在 jQuery 函数的 prototype 对象上面的，而 $.data()方法是定义 jQuery 函数上面的，调用的时候不从复杂的 jQuery 对象上调用，速度快得多。所以我们推荐使用第一种写法。</p><p>回到第一种写法上，就是因为将 this 指向了当前 DOM 元素，我们才能使用 $(this)将当前 DOM 元素包装成 jQuery 对象，优雅的使用 hover 方法。</p><p>所以最终的 each 源码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length, i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">        length = obj.length;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (callback.call(obj[i], i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (callback.call(obj[i], i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>我们在性能上比较下 for 循环和 each 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">1000000</span>&#125;, (v, i) =&gt; i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'for'</span>)</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; arr.length; i++) &#123;</span><br><span class="line">    i += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'for'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'each'</span>)</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">$.each(arr, <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123;</span><br><span class="line">    j += item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'each'</span>)</span><br></pre></td></tr></table></figure><p>这里显示一次运算的结果：</p><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/each/each1.png" alt="性能比较"></p><p>从上图可以看出，for 循环的性能是明显好于 each 函数的，each 函数本质上也是用的 for 循环，到底是慢在了哪里呢？</p><p>我们再看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> length = obj.length</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        value = callback(i, obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eachWithCall</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> length = obj.length</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        value = callback.call(obj[i], i, obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">1000000</span>&#125;, (v, i) =&gt; i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'each'</span>)</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">each(arr, <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123;</span><br><span class="line">    i += item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'each'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'eachWithCall'</span>)</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">eachWithCall(arr, <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123;</span><br><span class="line">    j += item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'eachWithCall'</span>)</span><br></pre></td></tr></table></figure><p>这里显示一次运算的结果：</p><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/each/each2.png" alt="性能比较"></p><p>each 函数和 eachWithCall 函数唯一的区别就是 eachWithCall 调用了 call，从结果我们可以推测出，call 会导致性能损失，但也正是 call 的存在，我们才能将 this 指向循环中当前的元素。</p><p>有舍有得吧。<br> 或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript专题之jQuery通用遍历方法each的实现&quot;&gt;&lt;a href=&quot;#JavaScript专题之jQuery通用遍历方法each的实现&quot; class=&quot;headerlink&quot; title=&quot;JavaScript专题之jQuery通用遍历方法each的实现&quot;&gt;&lt;/a&gt;JavaScript专题之jQuery通用遍历方法each的实现&lt;/h1&gt;&lt;h2 id=&quot;each介绍&quot;&gt;&lt;a href=&quot;#each介绍&quot; class=&quot;headerlink&quot; title=&quot;each介绍&quot;&gt;&lt;/a&gt;each介绍&lt;/h2&gt;&lt;p&gt;jQuery 的 each 方法，作为一个通用遍历方法，可用于遍历对象和数组。&lt;/p&gt;
&lt;p&gt;语法为：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jQuery.each(object, [callback])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2015-02-26-components-in-webapp/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2015-02-26-components-in-webapp/</id>
    <published>2019-04-14T09:15:10.738Z</published>
    <updated>2019-04-14T09:15:10.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2015前端组件化框架之路"><a href="#2015前端组件化框架之路" class="headerlink" title="2015前端组件化框架之路"></a>2015前端组件化框架之路</h1><h1 id="1-为什么组件化这么难做"><a href="#1-为什么组件化这么难做" class="headerlink" title="1. 为什么组件化这么难做"></a>1. 为什么组件化这么难做</h1><p>Web应用的组件化是一个很复杂的话题。</p><p>在大型软件中，组件化是一种共识，它一方面提高了开发效率，另一方面降低了维护成本。但是在Web前端这个领域，并没有很通用的组件模式，因为缺少一个大家都能认同的实现方式，所以很多框架/库都实现了自己的组件化方式。</p><p>前端圈最热衷于造轮子了，没有哪个别的领域能出现这么混乱而欣欣向荣的景象。这一方面说明前端领域的创造力很旺盛，另一方面却说明了基础设施是不完善的。<br><a id="more"></a><br>我曾经有过这么一个类比，说明某种编程技术及其生态发展的几个阶段：</p><ul><li>最初的时候人们忙着补全各种API，代表着他们拥有的东西还很匮乏，需要在语言跟基础设施上继续完善</li><li>然后就开始各种模式，标志他们做的东西逐渐变大变复杂，需要更好的组织了</li><li>然后就是各类分层MVC，MVP，MVVM之类，可视化开发，自动化测试，团队协同系统等等，说明重视生产效率了，也就是所谓工程化</li></ul><p>那么，对比这三个阶段，看看关注这三种东西的人数，觉得Web发展到哪一步了？</p><p>细节来说，大概是模块化和组件化标准即将大规模落地（好坏先不论），各类API也大致齐备了，终于看到起飞的希望了，各种框架几年内会有非常强力的洗牌，如果不考虑老旧浏览器的拖累，这个洗牌过程将大大加速，然后才能释放Web前端的产能。</p><p>但是我们必须注意到，现在这些即将普及的标准，很多都会给之前的工作带来改变。用工业体系的发展史来对比，前端领域目前正处于蒸汽机发明之前，早期机械（比如《木兰辞》里面的机杼，主要是动力与材料比较原始）已经普及的这么一个阶段。</p><p>所以，从这个角度看，很多框架/库是会消亡的（专门做模块化的AMD和CMD相关库，专注于标准化DOM选择器铺垫的某些库），一些则必须进行革新，还有一些受的影响会比较小（数据可视化等相关方向），可以有机会沿着自己的方向继续演进。</p><h1 id="2-标准的变革"><a href="#2-标准的变革" class="headerlink" title="2. 标准的变革"></a>2. 标准的变革</h1><p>对于这类东西来说，能获得广泛群众基础的关键在于：对将来的标准有怎样的迎合程度。对前端编程方式可能造成重大影响的标准有这些：</p><ul><li>module</li><li>Web Components</li><li>class</li><li>observe</li><li>promise</li></ul><p>module的问题很好理解，JavaScript第一次有了语言上的模块机制，而Web Components则是约定了基于泛HTML体系构建组件库的方式，class增强了编程体验，observe提供了数据和展现分离的一种优秀方式，promise则是目前前端最流行的异步编程方式。</p><p>这里面只有两个东西是绕不过去的，一是module，一是Web Components。前者是模块化基础，后者是组件化的基础。</p><p>module的标准化，主要影响的是一些AMD/CMD的加载和相关管理系统，从这个角度来看，正如seajs团队的@afc163 所说，不管是AMD还是CMD，都过时了。</p><p>模块化相对来说，迁移还比较容易，基本只是纯逻辑的包装，跟AMD或者CMD相比，包装形式有所变化，但组件化就是个比较棘手的问题了。</p><p>Web Components提供了一种组件化的推荐方式，具体来说，就是：</p><ul><li>通过shadow DOM封装组件的内部结构</li><li>通过Custom Element对外提供组件的标签</li><li>通过Template Element定义组件的HTML模板</li><li>通过HTML imports控制组件的依赖加载</li></ul><p>这几种东西，会对现有的各种前端框架/库产生很巨大的影响：</p><ul><li>由于shadow DOM的出现，组件的内部实现隐藏性更好了，每个组件更加独立，但是这使得CSS变得很破碎，LESS和SASS这样的样式框架面临重大挑战。</li><li>因为组件的隔离，每个组件内部的DOM复杂度降低了，所以选择器大多数情况下可以限制在组件内部了，常规选择器的复杂度降低，这会导致人们对jQuery的依赖下降。</li><li>又因为组件的隔离性加强，致力于建立前端组件化开发方式的各种框架/库（除Polymer外），在自己的组件实现方式与标准Web Components的结合，组件之间数据模型的同步等问题上，都遇到了不同寻常的挑战。</li><li>HTML imports和新的组件封装方式的使用，会导致之前常用的以JavaScript为主体的各类组件定义方式处境尴尬，它们的依赖、加载，都面临了新的挑战，而由于全局作用域的弱化，请求的合并变得困难得多。</li></ul><h1 id="3-当下最时髦的前端组件化框架-库"><a href="#3-当下最时髦的前端组件化框架-库" class="headerlink" title="3. 当下最时髦的前端组件化框架/库"></a>3. 当下最时髦的前端组件化框架/库</h1><p>在2015年初这个时间点看，前端领域有三个框架/库引领时尚，那就是Angular，Polymer，React（排名按照首字母），在知乎的这篇<a href="http://www.zhihu.com/question/26644904/answer/33634518" target="_blank" rel="noopener">2014 年末有哪些比较火的 Web 开发技术？</a>里，我大致回答过一些点，其他几位朋友的答案也很值得看。关于这三者的细节分析，<strong>侯振宇</strong>的这篇讲得很好：<a href="http://www.cnblogs.com/sskyy/p/4264371.html" target="_blank" rel="noopener">2015前端框架何去何从</a></p><p>我们可以看到，Polymer这个东西在这方面是有先天优势的，因为它的核心理念就是基于Web Components的，也就是说，它基本没有考虑如何解决当前的问题，直接以未来为发展方向了。</p><p>React的编程模式其实不必特别考虑Web标准，它的迁移成本并不算高，甚至由于其实现机制，屏蔽了UI层实现方式，所以大家能看到在native上的使用，canvas上的使用，这都是与基于DOM的编程方式大为不同的，所以对它来说，处理Web Components的兼容问题要在封装标签的时候解决，反正之前也是要封装。</p><p>Angular 1.x的版本，可以说是跟同时代的多数框架/库一样，对未来标准的兼容基本没有考虑，但是重新规划之后的2.0版本对此有了很多权衡，变成了激进变更，突然就变成一个未来的东西了。</p><p>这三个东西各有千秋，在可以预见的几年内将会鼎足三分，也许还会有新的框架出现，能不能比这几个流行就难说了。</p><p>此外，原Angular 2.0的成员Rob Eisenberg创建了自己的新一代框架<a href="http://aurelia.io/" target="_blank" rel="noopener">aurelia</a>，该框架将成为Angular 2.0强有力的竞争者。</p><h1 id="4-前端组件的复用性"><a href="#4-前端组件的复用性" class="headerlink" title="4. 前端组件的复用性"></a>4. 前端组件的复用性</h1><p>看过了已有的一些东西之后，我们可以大致来讨论一下前端组件化的一些理念。假设我们有了某种底层的组件机制，先不管它是浏览器原生的，或者是某种框架/库实现的约定，现在打算用它来做一个大型的Web应用，应该怎么做呢？</p><p>所谓组件化，核心意义莫过于提取真正有复用价值的东西。那怎样的东西有复用价值呢？</p><ul><li>控件</li><li>基础逻辑功能</li><li>公共样式</li><li>稳定的业务逻辑</li></ul><p>对于控件的可复用性，基本上是没有争议的，因为这是实实在在的通用功能，并且比较独立。</p><p>基础逻辑功能主要指的是一些与界面无关的东西，比如underscore这样的辅助库，或者一些校验等等纯逻辑功能。</p><p>公共样式的复用性也是比较容易认可的，因此也会有bootstrap，foundation，semantic这些东西的流行，不过它们也不是纯粹的样式库了，也带有一些小的逻辑封装。</p><p>最后一块，也就是业务逻辑。这一块的复用是存在很多争议的，一方面是，很多人不认同业务逻辑也需要组件化，另一方面，这块东西究竟怎样去组件化，也很需要思考。</p><p>除了上面列出的这些之外，还有大量的业务界面，这块东西很显然复用价值很低，基本不存在复用性，但仍然有很多方案中把它们“组件化”了，使得它们成为了“不具有复用性的组件”。为什么会出现这种情况呢？</p><p>组件化的本质目的并不一定是要为了可复用，而是提升可维护性。这一点正如面向对象语言，Java要比C++纯粹，因为它不允许例外情况的出现，连main函数都必须写到某个类里，所以Java是纯面向对象语言，而C++不是。</p><p>在我们这种情况下，也可以把组件化分为：全组件化，局部组件化。怎么理解这两个东西的区别呢，有人问过js框架和库的区别是什么，一般来说，有某种较强约定的东西，称为框架，而约定比较松散的，称为库。框架很多都是有全组件化理念的，比如说，很多年前就出现的ExtJS，它是全组件化框架，而jQuery和它的插件体系，则是局部组件化。所以用ExtJS写东西，不管写什么都是差不多一样的写法，而用jQuery的时候，大部分地方是原始HTML，哪里需要有些不一样的东西，就只在那个地方调用插件做一下特殊化。</p><p>对于一个有一定规模的Web应用来说，把所有东西都“组件化”，在管理上会有较大的便利性。我举个例子，同样是编写代码，短代码明显比长代码的可读性更高，所以很多语言里会建议“一个方法一般不要超过多少行，一个类最好不要超过多少行”之类。在Web前端这个体系里，JavaScript这块是做得相对较好的，现在入门水平的人，也已经很少会有把一堆js都写在一起的了。CSS这块，最近在SASS，LESS等框架的引领下，也逐步往模块化方面发展，否则直接编写bootstrap那种css，会非常痛苦。</p><p>这个时候我们再看HTML的部分，如果不考虑模板等技术的使用，某些界面光布局代码写起来就非常多了，像一些表单，都需要一层套一层，很多简单的表单元素都需要套个三层左右，更不必说一些有复杂布局的东西了。尤其是整个系统单页化之后，界面的header，footer，各种nav或者aside，很可能都有一定复杂性。如果这些东西的代码不作切分，那么主界面的HTML一定比较难看。</p><p>我们先不管用什么方式切分了，比如用某种模板，用类似Angular中的include，或者Polymer，React中的标签，或者直接使用原生Web Components，总之是把一块一块都拆开了，然后包含进来。从这个角度看，这些拆出去的东西都像组件，但如果从复用性的角度看，很可能多数东西，每一块都只有一个地方用，压根没有复用度。这个拆出去，纯粹是为了使得整个工程易于管理，易于维护。</p><p>这时候我们再来关注不同框架/库对UI层组件化的处理方式，发现有两个类型，模板和函数。</p><p>模板是一种很常见的东西，它用HTML字符串的方式表达界面的原始结构，然后通过代入数据的方式生成真正的界面，有的是生成目标HTML，有的还生成各种事件的自动绑定。前者是静态模板，后者是动态模板。</p><p>另外有一些框架/库偏爱用函数逻辑来生成界面，早期的ExtJS，现在的React（它内部还是可能使用模板，而且对外提供的是组件创建接口的进一步封装——jsx）等，这种实现技术的优势是不同平台上编程体验一致，甚至可以给每种平台封装相同的组件，调用方轻松写一份代码，在Web和不同Native平台上可用。但这种方式也有比较麻烦的地方，那就是界面调整比较繁琐。</p><p>本文前面部分引用<strong>侯振宇</strong>的那篇文章里，他提出这些问题：</p><blockquote><p>如何能把组件变得更易重用? 具体一点:</p><ul><li>我在用某个组件时需要重新调整一下组件里面元素的顺序怎么办?</li><li>我想要去掉组件里面某一个元素怎么办?<br>如何把组件变得更易扩展? 具体一点:</li><li>业务方不断要求给组件加功能怎么办?</li></ul></blockquote><p>为此，还提出了“模板复写”方案，在这一点上我有不同意见。</p><p>我们来看看如何把一个业务界面切割成组件。</p><p>有这么一个简单场景：一个雇员列表界面包括两个部分，雇员表格和用于填写雇员信息的表单。在这个场景下，存在哪些组件？</p><p>对于这个问题，主要存在两种倾向，一种是仅仅把“控件”和比较有通用性的东西封装成组件，另外一种是整个应用都组件化。</p><p>对前一种方式来说，这里面只存在数据表格这么一个组件。<br>对后一种方式来说，这里面有可能存在：数据表格，雇员表单，甚至还包括雇员列表界面这么一个更大的组件。</p><p>这两种方式，就是我们之前所说的“局部组件化”，“全组件化”。</p><p>我们前面提到，全组件化在管理上是存在优势的，它可以把不同层面的东西都搞成类似结构，比如刚才的这个业务场景，很可能最后写起来是这个样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Employee-Panel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Employee-List</span>&gt;</span><span class="tag">&lt;/<span class="name">Employee-List</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Employee-Form</span>&gt;</span><span class="tag">&lt;/<span class="name">Employee-Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Employee-Panel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于UI层，最好的组件化方式是标签化，比如上面代码中就是三个标签表达了整个界面。但我个人坚决反对滥用标签，并不是把各种东西都尽量封装就一定好。</p><p>全标签化的问题主要有这些：</p><p>第一，语义化代价太大。只要用了标签，就一定需要给它合适的语义，也就是命名。但实际用的时候，很可能只是为了把一堆html简化一下而已，到底简化出来的那东西应当叫什么名字，光是起名也费不知多少脑细胞。比如你说雇员管理的表单，这个表单有heading吗，有footer吗，能折叠吗，等等，很难起一个让别人一看就知道的名字，要么就是特别长。这还算简单的，因为我们是全组件化，所以很可能会有组合了多种东西的一个较复杂的界面，你想来想去也没法给它起个名字，于是写了个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这尼玛……可能我夸张了点，但很多时候项目规模够大，你不起这么复杂的名字，最后很可能没法跟功能类似的一个组件区分开，因为这些该死的组件都存在于同一个命名空间中。如果仅仅是当作一个界面片段来include，就不存在这种心理负担了。</p><p>比如Angular里面的这种：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-include</span>=<span class="string">"'aaa/bbb/ccc.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就不给它什么名字，直接include进来，用文件路径来区分。这个片段的作用可以用其目录结构描述，也就是通过物理名而非逻辑名来标识，目录层次充当了一个很好的命名空间。</p><p>现在的一些主流MVVM框架，比如knockout，angular，avalon，vue等等，都有一种“界面模板”，但这种模板并不仅仅是模板，而是可以视为一种配置文件。某一块界面模板描述了自身与数据模型的关系，当它被解析之后，按照其中的各种设置，与数据建立关联，并且反过来再更新自身所对应的视图。</p><p>不含业务逻辑的UI（或者是业务逻辑已分离的UI）基本不适合作为组件来看待，因为即使在逻辑不变的情况下，界面改版的可能性也太多了。比如即使是换了新的CSS实现方式，从float布局改成flex布局，都有可能把DOM结构少套几层div，因此，在使用模板的方案中，只能把界面层视为配置文件，不能看成组件，如果这么做，就会轻松很多。</p><p>部队行军的时候讲究“逢山开路，遇水搭桥”，这句话的重点在于只有到某些地形才开路搭桥，使用MVVM这类模式解决的业务场景，多数时候是一马平川，横着走都可以，不必硬要造路。所以从整个方案看的话，UI层实现应该是模板与控件并存，大部分地方是模板，少数地方是需要单独花时间搞的路和桥。</p><p>第二，配置过于复杂。有很多东西其实不太适合封装，不但封装的代价大，使用的代价也会很大。有时候会发现，调用代码的绝大部分都是在写各种配置。</p><p>就像刚才的雇员表单，既然你不从标签的命名上去区分，那一定会在组件上加配置。比如你原来想这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EmployeeForm</span> <span class="attr">heading</span>=<span class="string">"雇员表单"</span>&gt;</span><span class="tag">&lt;/<span class="name">EmployeeForm</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在组件内部，判断有没有设置heading，如果没有就不显示，如果有，就显示。过了两天，产品问能不能把heading里面的某几个字加粗或者换色，然后码农开始允许这个heading属性传入html。没多久之后，你会惊奇地发现有人用你的组件，没跟你说，就在heading里面传入了折叠按钮的html，并且用选择器给折叠按钮加了事件，点一下之后还能折叠这个表单了……</p><p>然后你一想，这个不行，我得给他再加个配置，让他能很简单地控制折叠按钮的显示，但是现在这么写太不直观，于是采用对象结构的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EmployeeForm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Option</span> <span class="attr">collapsible</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>雇员<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>表单<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">EmployeeForm</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后又有一天，发现有很多面板都可以折叠，然后特意创建了一个可折叠面板组件，又创建了一种继承机制，其他普通业务面板从它继承，从此一发不可收拾。</p><p>我举这例子的意思是为了说明什么呢，我想说，在规模较大的项目中，企图用全标签化加配置的方式来描述所有的普通业务界面，是一定事倍功半的，并且这个规模越大就越坑，这也正是ExtJS这类对UI层封装过度的体系存在的最大问题。</p><p>这个问题讨论完了，我们来看看另外一个问题：如果UI组件有业务逻辑，应该如何处理。</p><p>比如说，性别选择的下拉框，它是一个非常通用化的功能，照理说是很适合被当做组件来提供的。但是究竟如何封装它，我们就有些犯难了。这个组件里除了界面，还有数据，这些数据应当内置在组件里吗？理论上从组件的封装性来说，是都应当在里面的，于是就这么造了一个组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GenderSelect</span>&gt;</span><span class="tag">&lt;/<span class="name">GenderSelect</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个组件非常美好，只需直接放在任意的界面中，就能显示带有性别数据的下拉框了。性别的数据很自然地是放在组件的实现内部，一个写死的数组中。这个太简单了，我们改一下，改成商品销售的国家下拉框。</p><p>表面上看，这个没什么区别，但我们有个要求，本公司商品销售的国家的信息是统一配置的，也就是说，这个数据来源于服务端。这时候，你是不是想把一个http请求封装到这组件里？</p><p>这样做也不是不可以，但存在至少两个问题：</p><ul><li>如果这类组件在同一个界面中出现多次，就可能存在请求的浪费，因为有一个组件实例就会产生一个请求。</li><li>如果国家信息的配置界面与这个组件同时存在，当我们在配置界面中新增一个国家了，下拉框组件中的数据并不会实时刷新。</li></ul><p>第一个问题只是资源的浪费，第二个就是数据的不一致了。曾经在很多系统中，大家都是手动刷新当前页面来解决这问题的，但到了这个时代，人们都是追求体验的，在一个全组件化的解决方案中，不应再出现此类问题。</p><p>如何解决这样的问题呢？那就是引入一层Store的概念，每个组件不直接去到服务端请求数据，而是到对应的前端数据缓存中去获取数据，让这个缓存自己去跟服务端保持同步。</p><p>所以，在实际做方案的过程中，不管是基于Angular，React，Polymer，最后肯定都做出一层Store了，不然会有很多问题。</p><h1 id="5-为什么MVVM是一种很好的选择"><a href="#5-为什么MVVM是一种很好的选择" class="headerlink" title="5. 为什么MVVM是一种很好的选择"></a>5. 为什么MVVM是一种很好的选择</h1><p>我们回顾一下刚才那个下拉框的组件，发现存在几个问题：</p><ul><li>界面不好调整。刚才的那个例子相对简单，如果我们是一个省市县三级联动的组件，就比较麻烦了。比如说，我们想要把水平布局改成垂直的，又或者，想要把中间的label的字改改，都会非常麻烦。按照传统的做组件的方式，就要加若干配置项，然后组件里面去分别判断，修改DOM结构。</li><li>如果数据的来源不是静态json，而是某个动态的服务接口，那用起来就很麻烦。</li><li>我们更多地需要业务逻辑的复用和纯“控件”的复用，至于那些绑定业务的界面组件，复用性其实很弱。</li></ul><p>所以，从这些角度，会尽量期望在HTML界面层与JavaScript业务逻辑之间，存在一种分离。</p><p>这时候，再看看绝大多数界面组件存在什么问题：</p><p>有时候我们考虑一下DOM操作的类型，会发现其实是很容易枚举的：</p><ul><li>创建并插入节点</li><li>移除节点</li><li>节点的交换</li><li>属性的设置</li></ul><p>多数界面组件封装的绝大部分内容不过是这些东西的重复。这些东西，其实是可以通过某些配置描述出来的，比如说，某个数组以什么形式渲染成一个select或者无序列表之类，当数组变动，这些东西也跟着变动，这些都应当被自动处理，如果某个方案在现在这个时代还手动操作这些，那真的是一种落伍。</p><p>所以我们可以看到，以Angular，Knockout，Vue，Avalon为代表的框架们在这方面做了很多事，尽管理念有所差异，但大方向都非常一致，也就是把大多数命令式的DOM操作过程简化为一些配置。</p><p>有了这种方式之后，我们可以追求不同层级的复用：</p><ul><li>业务模型因为是纯逻辑，所以非常容易复用</li><li>视图模型基本上也是纯逻辑，界面层多数是纯字符串模板，同一个视图模型搭配不同的界面模板，可以实现视图模型的复用</li><li>同一个界面模板与不同的视图模型组合，也能直接组合出完全不同的东西</li></ul><p>所以这么一来，我们的复用粒度就非常灵活了。正因为这样，我一直认为Angular这样的框架战略方向是很正确的，虽然有很多战术失误。我们在很多场景下，都是需要这样的高效生产手段的。</p><h1 id="6-组件的长期积累"><a href="#6-组件的长期积累" class="headerlink" title="6. 组件的长期积累"></a>6. 组件的长期积累</h1><p>我们做组件化这件事，一定是一种长期打算，为了使得当前的很多东西可以作为一种积累，在将来还能继续使用，或者仅仅作较小的修改就能使用，所以必须考虑对未来标准的兼容。主要需要考虑的方面有这几点：</p><ul><li>尽可能中立于语言和框架，使用浏览器的原生特性</li><li>逻辑层的模块化（ECMAScript module）</li><li>界面层的元素化（Web Components）</li></ul><p>之前有很多人对Angular 2.0的激进变更很不认同，但它的变更很大程度上是对标准的全面迎合。这不仅仅是它的问题，其实是所有前端框架的问题。不面对这些问题，不管现在多么好，将来都是死路一条。这个问题的根源是，这几个已有的规范约束了模块化和元素化的推荐方式，并且，如果要对当前和未来两边做适配的话，基本就没法干了，导致以前的都不得不做一定的迁移。</p><p>模块化的迁移成本还比较小，无论是之前AMD还是CMD的，都可以根据一些规则转换过来，但组件化的迁移成本太大了，几乎每种框架都会提出自己的理念，然后有不同的组件化理念。</p><p>还是从三个典型的东西来说：Polymer，React，Angular。</p><p>Polymer中的组件化，其实就是标签化。这里的标签，并不只是界面元素，甚至逻辑组件也可以这样，比如这个代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-panel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">core-ajax</span> <span class="attr">id</span>=<span class="string">"ajax"</span> <span class="attr">url</span>=<span class="string">"http://url"</span> <span class="attr">params</span>=<span class="string">"&#123;&#123;formdata&#125;&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">core-ajax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-panel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到这里的core-ajax标签，很明显这已经是纯逻辑的了，在大多数前端框架或者库中，调用ajax肯定不是这样的，但在浏览器端这么干也不是它独创，比如flash里面的WebService，比如早期IE中基于htc实现的webservice.htc等等，都是这么干的。在Polymer中，这类东西称为非可见元素（non-visual-element）。</p><p>React的组件化，跟Polymer略有不同，它的界面部分是标签化，但如果有单纯的逻辑，还是纯JavaScript模块。</p><p>既然大家的实现方式都那么不一致，那我们怎么搞出尽量可复用的组件呢？问题到最后还是要绕到Web Components上。</p><p>在Web Components与前端组件化框架的关系上，我觉得是这么个样子：</p><p>各种前端组件化框架应当尽可能以Web Components为基石，它致力于组织这些Components与数据模型之间的关系，而不去关注某个具体Component的内部实现，比如说，一个列表组件，它究竟内部使用什么实现，组件化框架其实是不必关心的，它只应当关注这个组件的数据存取接口。</p><p>然后，这些组件化框架再去根据自己的理念，进一步对这些标准Web Components进行封装。换句话说，业务开发人员使用某个组件的时候，他是应当感知不到这个组件内部究竟使用了Web Components，还是直接使用传统方式。（这一点有些理想化，可能并不是那么容易做到，因为我们还要管理像import之类的事情）。</p><h1 id="7-我们需要关注什么"><a href="#7-我们需要关注什么" class="headerlink" title="7. 我们需要关注什么"></a>7. 我们需要关注什么</h1><p>目前来看，前端框架/库仍然处于混战期，可比中国历史上的春秋战国，百家齐放，作为跟随者来说，这是很痛苦的，因为无所适从，很可能你作为一个企业的前端架构师或者技术经理，需要做一些选型工作，但选哪个能保证几年后不被淘汰呢？基本没有。</p><p>虽然我们不知道将来什么框架会流行，但我们可以从一些细节方面去关注，某个具体的方面，将来会有什么，也可以了解一下在某个具体领域存在什么样的方案。一个完整的框架方案，无非是以下多个方面的综合。</p><h2 id="7-1-模块化"><a href="#7-1-模块化" class="headerlink" title="7.1 模块化"></a>7.1 模块化</h2><p>这块还是不讲了，支付宝seajs还有百度ecomfe这两个团队的人应该都能比我讲得好得多。</p><h2 id="7-2-Web-Components"><a href="#7-2-Web-Components" class="headerlink" title="7.2 Web Components"></a>7.2 Web Components</h2><p>本文前面讨论过一些，也不深入了。</p><h2 id="7-3-变更检测"><a href="#7-3-变更检测" class="headerlink" title="7.3 变更检测"></a>7.3 变更检测</h2><p>我们知道，现代框架的一个特点是自动化，也就是把原有的一些手动操作提取。在前端编程中，最常见的代码是在干什么呢？读写数据和操作DOM。不少现代的框架/库都对这方面作了处理，比如说通过某种配置的方式，由框架自动添加一些关联，当数据变更的时候，把DOM进行相应修改，又比如，当DOM发生变动的时候，也更新对应的数据。</p><p>这个关联过程可能会用到几种技术。首先我们看怎么知道数据在变化，这里面有三种途径：</p><p>一、存取器的封装。这个的意思也就是对数据进行一层包装，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">name: <span class="string">"aaa"</span>,</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;,</span><br><span class="line">setName: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不允许用户直接调用data.name，而是调用对应的两个函数。Backbone就是通过这样的机制实现数据变动观测的，这种方式适用于几乎所有浏览器，缺点就是比较麻烦，要对每个数据进行包装。</p><p>这个机制在稍微新一点的浏览器中，也有另外一种实现方式，那就是defineProperty相关的一些方法，使用更优雅的存取器，这样外界可以不用调用函数，而是直接用data.name这样进行属性的读写。</p><p>国产框架avalon使用了这个机制，低版本IE中没有defineProperty，但在低版本IE中不止有JavaScript，还存在VBScript，那里面有存取器，所以他巧妙地使用了VBS做了这么一个兼容封装。</p><p>基于存取器的机制还有个麻烦，就是每次动态添加属性，都必须再添加对应的存取器，否则这个属性的变更就无法获取。</p><p>二、脏检测。</p><p>以Angular 1.x为代表的框架使用了脏检测来获知数据变更，这个机制的大致原理是：</p><p>保存数据的新旧值，每当有一些DOM或者网络、定时器之类的事件产生，用这个事件之后的数据去跟之前保存的数据进行比对，如果相同，就不触发界面刷新，否则就刷新。</p><p>这个方式的理念是，控制所有可能导致数据变更的来源（也就是各种事件），在他们可能对数据进行操作之后，判断新旧数据是否有变化，忽略所有中间变更，也就是说，如果你在同一个事件中，把某个数据任意修改了很多次，但最后改回来了，框架会认为你什么都没干，也就不会通知界面去刷新了。</p><p>不可否认的是，脏检测的效率是比较低的，主要是不能精确获知数据变更的影响，所以当数据量更大的情况下，浪费更严重，需要手动作一些优化。比如说一个很大的数组，生成了一个界面上的列表，当某个项选中的时候，改变颜色。在这种机制下，每次改变这个项的数据状态，就需要把所有的项都跟原来比较一遍，然后，还要再全部比较一次发现没有关联引起的变化了，才能对应刷新界面。</p><p>三、观察机制。</p><p>在ES7里面，引入了Object的observe方法，可以用于监控对象或数组的变动。</p><p>这是目前为止最合理的观测方案。这个机制很精确高效，比如说，连长跟士兵说，你去观察对面那个碉堡里面的动静。这个含义很复杂，包括什么呢？</p><ul><li>是不是加人了</li><li>是不是有人离开了</li><li>谁跟谁换岗了</li><li>上面的旗子从太阳旗换成青天白日了</li></ul><p>所谓观察机制，也就是观测对象属性的变更，数组元素的新增，移除，位置变更等等。我们先思考一下界面和数据的绑定，这本来就应当是一个外部的观察，你是数据，我是界面，你点头我微笑，你伸手我打人。这种绑定本来就应当是个松散关系，不应当因为要绑定，需要破坏原有的一些东西，所以很明显更合理。</p><p>除了数据的变动可以被观察，DOM也是可以的。但是目前绝大多数双向同步框架都是通过事件的方式把DOM变更同步到数据上。比如说，某个文本框绑定了一个对象的属性，那很可能，框架内部是监控了这个文本框的键盘输入、粘贴等相关事件，然后取值去往对象里写。</p><p>这么做可以解决大部分问题，但是如果你直接myInput.value=”111”，这个变更就没法获取了。这个不算大问题，因为在一个双向绑定框架中，一个既被监控，又手工赋值的东西，本身也比较怪，不过也有一些框架会尝试从HTMLInputELement的原型上去覆盖value赋值，尝试把这种东西也纳入框架管辖范围。</p><p>另外一个问题，那就是我们只考虑了特定元素的特定属性，可以通过事件获取变更，如何获得更广泛意义上的DOM变更？比如说，一般属性的变更，或者甚至子节点的增删？</p><p>DOM4引入了MutationObserver，用于实现这种变更的观测。在DOM和数据之间，是否需要这么复杂的观测与同步机制，目前尚无定论，但在整个前端开发逐步自动化的大趋势下，这也是一种值得尝试的东西。</p><p>复杂的关联监控容易导致预期之外的结果：</p><ul><li>慕容复要复国，每天读书练武，各种谋划</li><li>王语嫣观察到了这种现象，认为表哥不爱自己了</li><li>段誉看到神仙姐姐闷闷不乐，每天也茶饭不思</li><li>镇南王妃心疼爱子，到处调查这件事的原委，意外发现段正淳还跟旧爱有联系</li><li>……</li></ul><p>总之这么下来，最后影响到哪里了都不知道，谁让丘处机路过牛家村呢？</p><p>所以，变更的关联监控是很复杂的一个体系，尤其是其中产生了闭环的时候。搭建整个这么一套东西，需要极其精密的设计，否则熟悉整套机制的人只要用特定场景轻轻一推就倒了。灵智上人虽然武功过人，接连碰到欧阳锋，周伯通，黄药师，全部都是上来就直接被抓了后颈要害，大致就是这意思。</p><p>polymer实现了一个<a href="https://github.com/Polymer/observe-js" target="_blank" rel="noopener">observe-js</a>，用于观测数组、对象和路径的变更，有兴趣的可以关注。</p><p>在有些框架，比如aurelia中，是混合使用了存取器和观察模式，把存取器作为观察模式的降级方案，在浏览器不支持observe的情况下使用。值得一提的是，在脏检测方式中，变更是合并后批量提交的，这一点常常被另外两种方案的使用者忽视。其实，即使用另外两种方式，也还是需要一个合并与批量提交过程。</p><p>怎么理解这个事情呢？数据的绑定，最终都是要体现到界面上的，对于界面来说，其实只关注你每一次操作所带来的数据变更的始终，并不需要关心中间过程。比如说，你写了这么一个循环，放在某个按钮的点击中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">obj.a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>界面有一个东西绑定到这个a，对框架来说，绝对不应当把中间过程直接应用到界面上，以刚才这个例子来说，合理的情况只应当存在一次对界面DOM的赋值，这个值就是对obj.a进行了10000次赋值之后的值。尽管用存取器或者观察模式，发现了对obj上a属性的这10000次赋值过程，这些赋值还是都必须被舍弃，否则就是很可怕的浪费。</p><p>React使用虚拟DOM来减少中间的DOM操作浪费，本质跟这个是一样的，界面只应当响应逻辑变更的结束状态，不应当响应中间状态。这样，如果有一个ul，其中的li绑定到一个1000元素的数组，当首次把这个数组绑定到这个ul上的时候，框架内部也是可以优化成一次DOM写入的，类似之前常用的那种DocumentFragment，或者是innerHTML一次写入整个字符串。在这个方面，所有优化良好的框架，内部实现机制都应当类似，在这种方案下，是否使用虚拟DOM，对性能的影响都是很小的。</p><h2 id="7-4-Immutable-Data"><a href="#7-4-Immutable-Data" class="headerlink" title="7.4 Immutable Data"></a>7.4 Immutable Data</h2><p>Immutable Data是函数式编程中的一个概念，在前端组件化框架中能起到一些很独特的作用。</p><p>它的大致理念是，任何一种赋值，都应当被转化成复制，不存在指向同一个地方的引用。比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a==b);</span><br></pre></td></tr></table></figure><p>这个我们都知道，b跟a的内存地址是不一致的，简单类型的赋值会进行复制，所以a跟b不相等。但是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">counter : <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">b.counter++;</span><br><span class="line"><span class="built_in">console</span>.log(a.counter==b.counter);</span><br></pre></td></tr></table></figure><p>这时候因为a和b指向相同的内存地址，所以只要修改了b的counter，a里面的counter也会跟着变。</p><p>Immutable Data的理念是，我能不能在这种赋值情况下，直接把原来的a完全复制一份给b，然后以后大家各自变各自的，互相不影响。光凭这么一句话，看不出它的用处，看例子：</p><p>对于全组件化的体系，不可避免会出现很多嵌套的组件。嵌套组件是一个很棘手的问题，在很多时候，是不太好处理的。嵌套组件所存在的问题主要在于生命周期的管理和数据的共享，很多已有方案的上下级组件之间都是存在数据共享的，但如果内外层存在共享数据，那么就会破坏组件的独立性，比如下面的一个列表控件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-list</span> <span class="attr">list-data</span>=<span class="string">"&#123;arr&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-listitem</span>&gt;</span><span class="tag">&lt;/<span class="name">my-listitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-listitem</span>&gt;</span><span class="tag">&lt;/<span class="name">my-listitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-listitem</span>&gt;</span><span class="tag">&lt;/<span class="name">my-listitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在赋值的时候，一般是在外层整体赋值一个类似数组的数据，而不是自己挨个在每个列表项上赋值，不然就很麻烦。但是如果内外层持有相同的引用，对组件的封装性很不利。</p><p>比如在刚才这个例子里，假设数据源如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">"Item1"</span>&#125;, </span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">"Item2"</span>&#125;, </span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">"Item3"</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>通过类似这样的方式赋值给界面组件，并且由它在内部给每个子组件分别进行数据项的赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.data = arr;</span><br></pre></td></tr></table></figure><p>赋值之后会有怎样的结果呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(list.data == arr);</span><br><span class="line"><span class="built_in">console</span>.log(listitem0.data == arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(listitem1.data == arr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(listitem2.data == arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>这种方案里面，后面那几个log输出的结果都会是true，意思就是内层组件与外层共享数据，一旦内层组件对数据进行改变，外层中的也就改变了，这明显是违背组件的封装性的。</p><p>所以，有一些方案会引入Immutable Data的概念。在这些方案里，内外层组件的数据是不共享的，它们的引用不同，每个组件实际上是持有了自己的数据，然后引入了自动的赋值机制。</p><p>这时候再看看刚才那个例子，就会发现两层的职责很清晰：</p><ul><li>外层持有一个类似数组的东西arr，用于形成整个列表，但并不关注每条记录的细节</li><li>内层持有某条记录，用于渲染列表项的界面</li><li>在整个列表的形成过程中，list组件根据arr的数据长度，实例化若干个listitem，并且把arr中的各条数据赋值给对应的listitem，而这个赋值，就是immutable data起作用的地方，其实是把这条数据复制了一份给里面，而不是把外层这条记录的引用赋值进去。内层组件发现自己的数据改变之后，就去进行对应的渲染</li><li>如果arr的条数变更了，外层监控这个数据，并且根据变更类型，添加或者删除某个列表项</li><li>如果从外界改变了arr中某一条记录的内容，外层组件并不直接处理，而是给对应的内层进行了一次赋值</li><li>如果列表项中的某个操作，改变了自身的值，它首先是把自己持有的数据进行改变，然后，再通过immutable data把数据往外同步一份，这样，外层组件中的数据也就更新了。</li></ul><p>所以我们再看这个过程，真是非常清晰明了，而且内外层各司其职，互不干涉。这是非常有利于我们打造一个全组件化的大型Web应用的。各级组件之间存在比较松散的联系，而每个组件的内部则是封闭的，这正是我们所需要的结果。</p><p>说到这里，需要再提一个容易混淆的东西，比如下面这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">outer-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inner-component</span>&gt;</span><span class="tag">&lt;/<span class="name">inner-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">outer-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们为了给inner-component做一些样式定位之类的事情，很可能在内外层组件之间再加一些额外的布局元素，比如变成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">outer-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inner-component</span>&gt;</span><span class="tag">&lt;/<span class="name">inner-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">outer-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里中间多了一级div，也可能是若干级元素。如果有用过Angular 1.x的，可能会知道，假如这里面硬造一级作用域，搞个ng-if之类，就可能存在多级作用域的赋值问题。在上面这个例子里，如果在最外层赋值，数据就会是outer -&gt; div -&gt; inner这样，那么，从框架设计的角度，这两次赋值都应当是immutable的吗？</p><p>不是，第一次赋值是非immutable，第二次才需要是，immutable赋值应当仅存在于组件边界上，在组件内部不是特别有必要使用。刚才的例子里，依附于div的那层变量应当还是跟outer组件在同一层面，都属于outer组件的人民内部矛盾。</p><p>这里是facebook实现的<a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">immutable-js库</a></p><h2 id="7-5-Promise与异步"><a href="#7-5-Promise与异步" class="headerlink" title="7.5 Promise与异步"></a>7.5 Promise与异步</h2><p>前端一般都习惯于用事件的方式处理异步，但很多时候纯逻辑的“串行化”场景下，这种方式会让逻辑很难阅读。在新的ES规范里，也有yield为代表的各种原生异步处理方案，但是这些方案仍然有很大的理解障碍，流行度有限，很大程度上会一直停留在基础较好的开发人员手中。尤其是在浏览器端，它的受众应该会比node里面还要狭窄。</p><p>前端里面，处理连续异步消息的最能被广泛接受的方案是promise，我这里并不讨论它的原理，也不讨论它在业务中的使用，而是要提一下它在组件化框架内部所能起到的作用。</p><p>现在已经没有哪个前端组件化框架可以不考虑异步加载问题了，因为，在前端这个领域，加载就是一个绕不过去的坎，必须有了加载，才能有执行过程。每个组件化框架都不能阻止自己的使用者规模膨胀，因此也应当在框架层面提出解决方案。</p><p>我们可能会动态配置路由，也可能在动态加载的路由中又引入新的组件，如何控制这些东西的生命周期，值得仔细斟酌，如果在框架层面全异步化，对于编程体验的一致性是有好处的。将各类接口都promise化，能够在可维护性和可扩展性上提供较多便利。</p><p>我们之前可能熟知XMLHTTP这样的通信接口，这个东西虽然被广为使用，但是在优雅性等方面，存在一些问题，所以最近出来了替代方案，那就是fetch。</p><p>细节可以参见月影翻译的这篇<a href="http://www.w3ctech.com/topic/854" target="_blank" rel="noopener">【翻译】这个API很“迷人”——(新的Fetch API)</a></p><p>在不支持的浏览器上，也有github实现的一个polyfill，虽然不全，但可以凑合用<a href="https://github.com/github/fetch" target="_blank" rel="noopener">window.fetch polyfill</a></p><p>大家可以看到，fetch的接口就是基于promise的，这应当是前端开发人员最容易接受的方案了。</p><h1 id="7-6-Isomorphic-JavaScript"><a href="#7-6-Isomorphic-JavaScript" class="headerlink" title="7.6 Isomorphic JavaScript"></a>7.6 Isomorphic JavaScript</h1><p>这个东西的意思是前后端同构的JavaScript，也就是说，比如一块界面，可以选择在前端渲染，也可以选择在后端渲染，值得关注，可以解决像seo之类的问题，但现在还不能处理很复杂的状况，持续关注吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2015前端组件化框架之路&quot;&gt;&lt;a href=&quot;#2015前端组件化框架之路&quot; class=&quot;headerlink&quot; title=&quot;2015前端组件化框架之路&quot;&gt;&lt;/a&gt;2015前端组件化框架之路&lt;/h1&gt;&lt;h1 id=&quot;1-为什么组件化这么难做&quot;&gt;&lt;a href=&quot;#1-为什么组件化这么难做&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么组件化这么难做&quot;&gt;&lt;/a&gt;1. 为什么组件化这么难做&lt;/h1&gt;&lt;p&gt;Web应用的组件化是一个很复杂的话题。&lt;/p&gt;
&lt;p&gt;在大型软件中，组件化是一种共识，它一方面提高了开发效率，另一方面降低了维护成本。但是在Web前端这个领域，并没有很通用的组件模式，因为缺少一个大家都能认同的实现方式，所以很多框架/库都实现了自己的组件化方式。&lt;/p&gt;
&lt;p&gt;前端圈最热衷于造轮子了，没有哪个别的领域能出现这么混乱而欣欣向荣的景象。这一方面说明前端领域的创造力很旺盛，另一方面却说明了基础设施是不完善的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2014-10-01-From%20HTC%20to%20Web%20Components/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2014-10-01-From HTC to Web Components/</id>
    <published>2019-04-14T09:15:10.731Z</published>
    <updated>2019-04-14T09:15:10.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从HTML-Components的衰落看Web-Components的危机"><a href="#从HTML-Components的衰落看Web-Components的危机" class="headerlink" title="从HTML Components的衰落看Web Components的危机"></a>从HTML Components的衰落看Web Components的危机</h1><p>搞前端时间比较长的同学都会知道一个东西，那就是HTC（HTML Components），这个东西名字很现在流行的Web Components很像，但却是不同的两个东西，它们的思路有很多相似点，但是前者已是昨日黄花，后者方兴未艾，是什么造成了它们的这种差距呢？</p><h2 id="HTML-Components的一些特性"><a href="#HTML-Components的一些特性" class="headerlink" title="HTML Components的一些特性"></a>HTML Components的一些特性</h2><p>因为主流浏览器里面只有IE支持过HTC，所以很多人潜意识都认为它不标准，但其实它也是有标准文档的，而且到现在还有链接，注意它的时间！</p><p><a href="http://www.w3.org/TR/NOTE-HTMLComponents" title="HTML Components" target="_blank" rel="noopener">http://www.w3.org/TR/NOTE-HTMLComponents</a></p><p>我们来看看它主要能做什么呢？</p><p>它可以以两种方式被引入到HTML页面中，一种是作为“行为”被附加到元素，使用CSS引入，一种是作为“组件”，扩展HTML的标签体系。<br><a id="more"></a></p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>行为（Behavior）是在IE5中引入的一个概念，主要是为了做文档结构和行为的分离，把行为通过类似样式的方式隔离出去，详细介绍在这里可以看：</p><p><a href="http://msdn.microsoft.com/en-us/library/ms531079(v=vs.85" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/ms531079(v=vs.85).aspx</a>.aspx)</p><p>行为里可以引入HTC文件，刚才的HTC规范里就有，我们把它摘录出来，能看得清楚一些：</p><p><em>engine.htc</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span> <span class="attr">xmlns:PUBLIC</span>=<span class="string">"urn:HTMLComponent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PUBLIC:EVENT</span> <span class="attr">NAME</span>=<span class="string">"onResultChange"</span> <span class="attr">ID</span>=<span class="string">"eventOnResultChange"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">LANGUAGE</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doCalc</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="undefined">   :</span></span><br><span class="line"><span class="undefined">   oEvent = createEventObject();</span></span><br><span class="line"><span class="undefined">   oEvent.result = sResult;</span></span><br><span class="line"><span class="undefined">   eventOnResultChange.fire (oEvent);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span> <span class="attr">xmlns:LK</span>=<span class="string">"urn:com.microsoft.htc.samples.calc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">   <span class="selector-tag">LK</span>\<span class="selector-pseudo">:CALC</span>    &#123; <span class="attribute">behavior</span>:<span class="built_in">url</span>(engine.htc); &#125; </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LK:CALC</span> <span class="attr">ID</span>=<span class="string">"myCalc"</span> <span class="attr">onResultChange</span>=<span class="string">"resultWindow.innerText=window.event.result"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TABLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">ID</span>=<span class="string">"resultWindow"</span> <span class="attr">STYLE</span>=<span class="string">"border: '.025cm solid gray'"</span> <span class="attr">ALIGN</span>=<span class="string">RIGHT</span>&gt;</span>0.<span class="tag">&lt;/<span class="name">DIV</span>&gt;</span><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 7 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 8 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 9 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" / "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" C "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 4 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 5 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 6 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" * "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" % "</span> <span class="attr">DISABLED</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 1 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 2 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 3 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" - "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">"1/x"</span> <span class="attr">DISABLED</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 0 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">"+/-"</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" . "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" + "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" = "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">TABLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LK:CALC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个计算器的例子，我们先大致看一下代码结构，是不是很清晰？再看看现在用jQuery，我们是怎么实现这种东西的：是用选择器选择这些按钮，然后添加事件处理函数。注意你多了一步选择的过程，而且，整个过程混杂了声明式和命令式两种代码风格。如果按照它这样，你所有的JS基本都丢在了隔离的不相关的文件中，整个是一个配置的过程，分离得很干净。</p><p>除了这种计算器，还有规范文档中举例的改变界面展示，或者添加动画之类，注意它们的切入点，都是相当于附加在特定选中元素上的行为，即使DOM不给JS暴露任何选择器，也毫无影响，因为它们直接就通过CSS的选择器挂到元素上了。</p><p>这种在现在看来，意义不算明显，现在广为使用的先选择元素再添加事件，也是不错的展现和行为分离方式。</p><p>但另外一种使用方式就不同了。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>狭义的HTML5给我们带来了什么？是很多新增的元素标签，比如section，nav，acticle，那这些东西跟原先直接用div实现的，好处在哪里呢？在于语义化。</p><p>所谓语义化，就是一个元素能清晰表达自己是干什么的，不会让人有歧义，像div那种，可以类比成是一个Object，它不具体表示什么东西，但可以当成各种东西来用。而nav一写，就知道，它是导航，它就像有class定义的一个实体类，能表达具体含义。</p><p>那么，原有的HTML元素显然是不够的，因为实际开发过程中要表达的东西显然远远超出这些元素，比如日历，这种东西就没有一个元素用来描述它，更不用说在一些企业应用中可能会出现的树之类复杂控件了。</p><p>不提供原生元素，对开发造成的困扰是代码写起来麻烦，具体可以看之前我在知乎的一个回复，第三点：</p><p><a href="http://www.zhihu.com/question/22426434/answer/21433867" target="_blank" rel="noopener">http://www.zhihu.com/question/22426434/answer/21433867</a></p><p>所以，大家都想办法去提供自己的扩充元素的方式，现在我们是知道典型的有angularjs，polymer，但很早的时候也不是没有啊：</p><p><a href="http://msdn.microsoft.com/en-us/library/ms531076(v=vs.85" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/ms531076(v=vs.85).aspx</a>.aspx)</p><p>看，这就是HTC的添加自定义元素的方式，每个元素可以定义自己对外提供的属性、方法，还有事件，自己内部可以像写一个新页面一样，专注于实现功能。而且你发现没有，它考虑得很长远，提供了命名空间，防止你在一个页面引入两个不同组织提供的同名自定义元素。</p><p>这个东西就可以称为组件了，它跟外界是完全隔离的，外界只要把它拿来就可以用，就像用原生元素一样，用选择器选择，设置属性，调用方法，添加事件处理等等，而且，注意到没有，它的属性是带get和set的，这是多么梦寐以求的东西！</p><p>正是因为它这么好用，所以在那个时代，我们用它干了很多东西，封装了各种基础控件，比如树，数据表格，日期选择，等等，甚至当时也有人嫌弃浏览器原生select和radio不好看，用这么个东西，里面封装了图片来模拟功能，替换原生的来用。</p><p>当时也有人，比如我在04年就想过，能不能把这些扩大化，扩展到除了基础控件之外的地方，把业务的组件也这么搞一下，一切皆组件，多好？</p><p>但有些事情我直到后来很久以后才想明白，基于业务的端到端组件虽然写起来很方便，却是有致命缺陷的。</p><p>到这里为止，对HTML Components的回顾告一段落，也不讨论它为什么就没了之类，这里面争议太大，我只想谈谈从这里面，能看到Web Components这么个大家寄予厚望的新标准需要面对一些什么问题。</p><h2 id="Web-Components的挑战"><a href="#Web-Components的挑战" class="headerlink" title="Web Components的挑战"></a>Web Components的挑战</h2><p>以下逐条列出，挨个说明，有的已经有了，有的差一些，有的没有，不管这么多，总之谈谈我心目中的这个东西应当是怎样的。</p><h3 id="自定义元素标签支持命名空间"><a href="#自定义元素标签支持命名空间" class="headerlink" title="自定义元素标签支持命名空间"></a>自定义元素标签支持命名空间</h3><p>原因我前面已经说了，可能会有不同组织实现同类功能的组件，存在于同一个页面内，引起命名歧义，所以我想了很久，还是觉得有前缀比较好：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yours:ComponentA</span>&gt;</span><span class="tag">&lt;/<span class="name">yours:ComponentA</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">his:ComponentA</span>&gt;</span><span class="tag">&lt;/<span class="name">his:ComponentA</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至，这里的前缀还可以是个简称别名，比如yours=com.aaa.productA，这可能只有复杂到一定程度才会出现，大家不要以为这太夸张，但总有一天Web体系能构建超大型软件，到那时候你就知道是不是可能了。</p><h3 id="样式的局部作用域"><a href="#样式的局部作用域" class="headerlink" title="样式的局部作用域"></a>样式的局部作用域</h3><p>这个前一段时间有的浏览器实现过，在组件内部，style上加一个scoped属性，这是正确的方向。为什么要这么干呢，所谓组件，引入成本越小越好，在无约定的情况下都能引入，不造成问题，那是最佳的结果。</p><p>如果你一个组件的样式不是局部的，很可能就跟主界面的冲突了，就算你不跟主界面的冲突，怎么保证不跟主界面中包含的其他组件的样式冲突？靠命名约定是不现实的，看长远一些，等你的系统够大，这就是大问题了。</p><h3 id="跟主文档的通讯"><a href="#跟主文档的通讯" class="headerlink" title="跟主文档的通讯"></a>跟主文档的通讯</h3><p>一个自定义组件，应当能够跟主文档进行通讯，这个过程包括两个方向，分别可以有多种不同的方式。</p><h4 id="从内向外"><a href="#从内向外" class="headerlink" title="从内向外"></a>从内向外</h4><p>除了事件，真没有什么好办法可以做这个方向的通讯，但事件也可以有两种定义方式，一种是类似onclick那种，主文档应当能够在它上面直接添加对应的事件监听函数，就像对原生元素那样，每个事件都能单独使用。另一种是像postMessage那样，只提供一个通道，具体怎么处理，自己去定义消息格式和处理方式。</p><p>这两种实现方式都可行，后者比较偷懒，但也够用了，前者也没有明显优势。</p><h4 id="从外向内"><a href="#从外向内" class="headerlink" title="从外向内"></a>从外向内</h4><p>这个也可以有两种方式，一种是组件对外暴露属性或者方法，让主文档调用，一种是外部也通过postMessage往里传。前者用起来会比较方便，后者也能凑合用用。</p><p>所以，如果特别偷懒，这个组件就变得像一个iframe那样，跟外部基本都通过postMessage交互。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>写到这里我是很纠结的，因为终于来到争议最大的地方了。按照很多人的思路，我这里应该也写隔离成局部作用域的JavaScript才对，但真不行，我们可以先假设组件内部的所有JavaScript都跑在局部作用域，它不能访问主文档中的对象。</p><p>我这里解释一下之前那个坑，为什么端到端组件是有缺陷的。</p><p>先解释什么叫端到端组件。比如说，我有这么一个组件，它封装了对后端某接口的调用，还有自身的一些展示处理，跟外界通过事件通信。它整个是不需要依赖别人的，初始加载数据都是自己内部做，别人要用它也很简单，直接拿来放在页面里就可以了。</p><p>照理说，这东西应当非常好才对，使用起来这么方便，到底哪里不对？我来举个场景。</p><p>在页面上同时存在这个组件的多个实例，每个组件都去加载了初始数据，假设它们是不带参数的，每个组件加载的数据都一样，这里是不是就有浪费的请求了？有人可能觉得一点点浪费不算问题，那么继续。</p><p>假设这个组件就是一个很普通的下拉列表，用于选取人员的职业，初始可能有医生，教师，警察等等，我把这个组件直接放在界面上，它一出现，就自己去加载了所需的列表信息并且展示了。有另外一个配置界面，用于配置这些职业信息，这时候我在里面添加了一个护士，并且提交了。假设为了数据一致性，我们把这个变更推回到页面，麻烦就出现了。</p><p>界面只有一个职业下拉列表的时候可能还好办，有多个的时候，这个更新的策略就有问题了。</p><p>如果在组件的内部做这个推送的对接，就会出现要推送多份一致的数据给组件的不同实例的问题。如果把这个放在外面，那我们也有两种方式：</p><ul><li>订阅发布模式，组件订阅某个数据源，数据源跟服务端对接，当数据变更的时候，发给每个订阅者</li><li>观察者模式，组件观察某个数据源，当数据变更的时候，去取回来</li></ul><p>这两种很类似，不管哪种，都面临一个问题：</p><p>数据源放在哪？</p><p>很明显不能放在组件内部了，只能放在某个“全局”的地方，但刚才我们假设的是，组件内部的JavaScript代码不能访问外界的对象，所以……</p><p>但要是让它能访问，组件的隔离机制等于白搭。最好的方式，也许是两种都支持，默认是局部作用域，另外专门有一个作用域放给JS框架之类的东西用，但浏览器实现的难度可能就大了不少。</p><p>可能有人会说，你怎么把问题搞这么复杂，用这么BT的场景来给我们美好的未来出难题。我觉得问题总是要面对的，能在做出来之前就面对问题，结果应该会好一些。</p><p>我注意观察了很多朋友对Web Components的态度，大部分都是完全叫好，但其中有一部分，主要是搞前端MV*的同学对它的态度很保守，主要原因应该是我说的这几点。因为这个群体主要都在做单页型的应用，这个里面会遇到的问题是跟传统前端不同的。</p><p>那么，比如Angular，或者React，它们跟Web Components的协作点在哪里呢？我个人觉得是把引擎保留下来，上层部分逐步跟Web Components融合，所以它们不是谁吃掉谁的问题，而是怎样去融合。最终就是在前端有两层，一层是数据和业务逻辑层，一层是偏UI的，在那个层里面，可以存在像Web Components那样的垂直切分，这样会很适宜。</p><p>最后说说自己对Polymer的意见，我的看法没有@司徒正美 那么粗暴，但我是认同他的观点的，因为Polymer的根本理念就是在做端到端组件，它会面临很多的挑战。虽然它是一个组件化框架，组件化最适宜于解决大规模协作问题，但是如果是以走向大型单页应用这条路来看，它比Angular和React离目标的距离还远很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从HTML-Components的衰落看Web-Components的危机&quot;&gt;&lt;a href=&quot;#从HTML-Components的衰落看Web-Components的危机&quot; class=&quot;headerlink&quot; title=&quot;从HTML Components的衰落看Web Components的危机&quot;&gt;&lt;/a&gt;从HTML Components的衰落看Web Components的危机&lt;/h1&gt;&lt;p&gt;搞前端时间比较长的同学都会知道一个东西，那就是HTC（HTML Components），这个东西名字很现在流行的Web Components很像，但却是不同的两个东西，它们的思路有很多相似点，但是前者已是昨日黄花，后者方兴未艾，是什么造成了它们的这种差距呢？&lt;/p&gt;
&lt;h2 id=&quot;HTML-Components的一些特性&quot;&gt;&lt;a href=&quot;#HTML-Components的一些特性&quot; class=&quot;headerlink&quot; title=&quot;HTML Components的一些特性&quot;&gt;&lt;/a&gt;HTML Components的一些特性&lt;/h2&gt;&lt;p&gt;因为主流浏览器里面只有IE支持过HTC，所以很多人潜意识都认为它不标准，但其实它也是有标准文档的，而且到现在还有链接，注意它的时间！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/NOTE-HTMLComponents&quot; title=&quot;HTML Components&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.w3.org/TR/NOTE-HTMLComponents&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们来看看它主要能做什么呢？&lt;/p&gt;
&lt;p&gt;它可以以两种方式被引入到HTML页面中，一种是作为“行为”被附加到元素，使用CSS引入，一种是作为“组件”，扩展HTML的标签体系。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2014-10-04-to-be-a-fe/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2014-10-04-to-be-a-fe/</id>
    <published>2019-04-14T09:15:10.725Z</published>
    <updated>2019-04-14T09:15:10.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给一位打算从事前端，但是又有疑惑的在校大学生的回信"><a href="#给一位打算从事前端，但是又有疑惑的在校大学生的回信" class="headerlink" title="给一位打算从事前端，但是又有疑惑的在校大学生的回信"></a>给一位打算从事前端，但是又有疑惑的在校大学生的回信</h1><p>抱歉这么晚才回复这个邮件，主要是觉得你的问题有典型性，想要详细一点给出答复。</p><p>所谓的前端，在不同的公司，定义是不同的，工作内容也会有差异，有的还很大。比如有很多公司，没有专门的前端分类，所有的都属于开发人员，一些比较传统的公司，还有一些人数较少的小公司会是这样。又比如有些公司，前端人员的职责仅限于静态页面和交互效果，然后把这些东西交给业务开发人员去编写业务的JS代码。还有一些公司，前端除了PC和移动端的Web，还包括各种移动终端的开发。<br><a id="more"></a><br>这些种种不同，都是各公司自身的业务特点决定的，大体上比较适合各自的业务场景，越大的公司，内部的分工可能越明确，所以也就有了你看到的，有比较偏向JS的，有比较偏向CSS的。</p><p>个人选择什么方向，我觉得需要问自己两个问题：</p><ol><li>你是一个怎样的人</li></ol><p>这个的意思是，你觉得自己学js和css的时候，哪种觉得更轻松愉快，容易领悟。一个人选择自己最容易领悟的方面去学习，会事半功倍。</p><ol start="2"><li>你希望成为一个怎样的人</li></ol><p>人的一生，实际上很大程度是职业细分的过程，每个人在他工作的前10年，都可能会逐步深入到某些领域，他的知识广度可能会逐步增加，但能够深入的，往往在一两个分支上。</p><p>从大的方面看，最初的软件体系基本都是以服务端为主，客户端通过字符界面去进行操作，后来桌面程序迅速发展，再后来Web兴起，最近各种终端的流行，更加促使广义的“前端”这个领域有更多的发挥空间。整体来说，后端的发展趋势是服务化，前端的发展趋势是多样化。因为消费者的促进，前端的需求和发展会是非常乐观的，无论在其中选择哪个细分方向，只要努力下去，成为这个领域的专家，肯定都会有所成就。</p><p>目前，在很多公司，搞CSS一般还没有独立职位，或者即使有，暂时比搞JS的还是稍微弱势一些，正如前端部门一般比后端部门弱势，但这种状况会好转的，每个领域都会得到适合自己的发挥。</p><p>关于原生JS和某些库的学习，我的观点是这样，除了一些很特别很怪异的点，对于语言本身的常规用法是需要都掌握的，其实也不多，常用到的就那么些。一般说的原生JS，是包括JS语言本身，还有它对DOM和BOM的操作，比如元素的创建移除，事件的添加等等，这些应该都需要懂。至于说对于某个库的学习，更重要的是学习它的思维方式，每看一个例子，就先想一想如果自己写，会把代码写成怎样，再与真实的例子进行对照，举一反三，这样的学习会是很快的过程。</p><p>现在这个时代，各种浏览器还在混战，但低版本IE的淘汰已经成为了必然，如果是现在开始学习，一定要着眼于将来，多看看CSS3各子集的规范，了解ES新版本的特性，因为世界迟早是它们的。对于低版本浏览器的兼容，一般都会有成熟的解决方案，当遇到具体问题的时候再去看也可以。</p><p>很多人看待前端，是把它当作一个很浅的层面来看的，其实前端的人多了解一些别的领域也是有好处的，从中能得到很多领悟，比如软件工程，设计模式，它们对不管什么方面的开发人员而言，都是很好的指导。</p><p>一个成熟的前端开发人员，他应当有比较宽的知识面，同时至少在某一两个细分领域有专注的研究和见解。平时在日常生活中，也可以多注意观察一些产品，对自己正在做的整个产品有深刻认识，对生活常识有充分了解，有时候也会有助于减少开发过程中走的弯路。</p><p>能够对自己的未来有所预期，并且主动寻找学习的途径，这说明你有很好的开始，在前端这条道路上认真走下去，相信会有美好的未来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给一位打算从事前端，但是又有疑惑的在校大学生的回信&quot;&gt;&lt;a href=&quot;#给一位打算从事前端，但是又有疑惑的在校大学生的回信&quot; class=&quot;headerlink&quot; title=&quot;给一位打算从事前端，但是又有疑惑的在校大学生的回信&quot;&gt;&lt;/a&gt;给一位打算从事前端，但是又有疑惑的在校大学生的回信&lt;/h1&gt;&lt;p&gt;抱歉这么晚才回复这个邮件，主要是觉得你的问题有典型性，想要详细一点给出答复。&lt;/p&gt;
&lt;p&gt;所谓的前端，在不同的公司，定义是不同的，工作内容也会有差异，有的还很大。比如有很多公司，没有专门的前端分类，所有的都属于开发人员，一些比较传统的公司，还有一些人数较少的小公司会是这样。又比如有些公司，前端人员的职责仅限于静态页面和交互效果，然后把这些东西交给业务开发人员去编写业务的JS代码。还有一些公司，前端除了PC和移动端的Web，还包括各种移动终端的开发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2014-05-20-%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2014-05-20-前端架构那些事儿/</id>
    <published>2019-04-14T09:15:10.718Z</published>
    <updated>2019-04-14T09:15:10.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端架构那些事儿"><a href="#前端架构那些事儿" class="headerlink" title="前端架构那些事儿"></a>前端架构那些事儿</h1><p>在谈前端架构之前，需要先探讨一下不同人群对前端产生的困惑。前端这个职业最近几年才逐渐被认可，之前一直是低端的代名词，所以多数高手很不屑搞这个。之前的很多项目，人们对前端这块的要求也只是能用就行，所以很少会在上面去细致、深入地建立一套完善体系。而多数产品的技术经理也会是后端出身的，往往对前端的认识还停留在Java Struts那个原始的MVC模型上，或者首先想到的就是GWT和JSF，这是从后端角度出发的一种视角。用这类思维方式做出来的产品，一般用户体验都不会很好。</p><p>另一方面，从界面层上手的人群，他对用户体验这方面会把控得比较好，但通常缺架构意识，或者说是软件工程的意识。在界面层比较复杂的情况下，很可能会有失控的趋势。对整个系统结构的认知程度通常不够深入，也缺乏设计模式等方面的知识。<br><a id="more"></a><br>开发人员会有一些困惑：</p><ul><li><p>创建项目的时候，一般没有人作前端的技术选型</p><ul><li>拿到项目之后，没有直接可复制的基础版本</li></ul></li><li><p>习惯于引用第三方组件</p><ul><li>赶功能，需要某个组件或者特效</li><li>上网搜到一个合适的，加进来</li><li>它还依赖一些别的库</li><li>文件大还是次要的</li><li>可能会产生冲突，样式也不一致</li></ul></li></ul><p>开发经理也会有一些困惑：</p><ul><li><p>协作过程感觉有问题</p><ul><li>前端人员写原始界面，包含静态界面和特效</li><li>开发人员接着改，加逻辑</li><li>发现有问题要返工了</li><li>在谁的代码基础上继续改？如何合并？</li></ul></li><li><p>2014年了，为什么还有这么多人工环节？</p><ul><li>能自动单元测试吗？</li><li>能自动发布打包吗？</li></ul></li></ul><p>用户会对这些事情感到烦恼：</p><ul><li><p>长得丑</p><ul><li>界面老土</li><li>风格不一致</li></ul></li><li><p>速度慢</p><ul><li>加载慢</li><li>渲染慢</li><li>执行慢</li></ul></li><li><p>出错</p></li></ul><p>架构的本质是什么？其实也是一种管理。通常我们所说的管理，都是指对于任务和人员的管理，而架构管的是机器和代码。比如说，机器的部署属于运维的物理架构，SOA属于服务架构，那么，前端的架构指什么呢？</p><p>长期以来，前端所处的位置是比较偏应用层，而且是很薄的一层，而架构又要求深度和广度，所以之前在前端里面做架构，好比在小水塘里游泳，稍微扑腾两下就到处碰壁。但最近这几年来，前端的范围被大大拓展了，所以这一层逐渐变得大有可为。</p><p>怎样去理解架构呢？在早期的文字MUD游戏里，有这么一句话：“你感觉哪里不对，但是又说不上来。”在我们开发和使用软件系统的过程中，或多或少会遇到这样的感觉，有这种感觉就说明架构方面可能有些问题。</p><p>在狭义的前端领域，架构要处理的很重要的事情是组件的集成。由于JavaScript本身缺乏命名空间这样的机制，多数框架都倾向于自己搞一套，所以这方面的碎片化是很严重的。如果一个公司的实力不足以自研所有用到的组件，就会一直面临这方面的问题。</p><p>比如说，在做某个功能的过程中，发现需要一个组件，时间来不及做，就到网上搜了个，加到代码里面，先运行起来再说。一不小心，等功能做完的时候，已经引入了无数种组件了，有很多代码是重叠的，可能有的还有冲突，外观也不一致。</p><p>环顾四周的大型互联网公司，基本上都有自己的前端框架，比如阿里的Kissy和Arale，腾讯的JX，百度的Tangram，360的QWrap等，为什么？因为要整合别的框架，并且在此基础上发展适合自己的组件库，代价非常大，初期没办法的时候只能凑合，长期来说，所有代码都可控的意义非常重要。</p><p>那么，是不是一套框架可以包打天下呢，这个真的很难。对于不同的产品形态，如果想要用一套框架去适应，有的会偏轻，有的又偏重，有的要兼容低端浏览器，有的又不要，很难取舍。</p><p>常见的前端产品形态包括：</p><ul><li>内容型Web站点 侧重渲染方面的优化，前端逻辑比重小</li><li>操作型B/S系统 以数据和逻辑为中心，界面较规整</li><li>内嵌Web的本地应用 要处理缓存和一些本地接口，包括PC客户端和移动端</li></ul><p>另外有Web游戏，因为跟我们的企业形态关系不大，而且也比较独特，所以不包含在内。这三种产品的前端框架要处理的事情显然是不太一样的，所以可以细分成2-3种项目模板，整理出对应的种子项目，供同类产品初始化用。</p><p>最近我们经常在前端领域听说两个词：全端、全栈。</p><p>全端的意思是，原来的只做在浏览器中运行的Web程序不够，还要做各种终端，包括iOS，Android等本地应用，甚至PC桌面应用。</p><p>为什么广义的前端应当包含本地应用呢？因为现在的本地应用，基于很多考虑，都变成了混合应用，也就是说，开发这个应用的技术，既包含原生的代码，也包含了嵌入的HTML5代码。这么一来，就造成了开发本地应用的人技能要求较广，能够根据产品的场景，合理选择每个功能应当使用的技术。</p><p>现在有一些PC端的混合应用开发技术，比如node-webkit和hex，前者的典型应用是Intel® XDK，后者的典型应用是有道词典，此外，豌豆荚的PC客户端也是采用类似技术的，也有一些产品是用的qt-webkit。这类技术可以方便做跨平台，极大减少开发工作量。</p><p>所以，我们可以看到，在很多公司，开发安卓、iOS应用的人员跟Web前端的处于同一个团队中，这很大程度上就是考虑到这种情况。</p><p>全栈的意思是，除了只做在浏览器中运行的代码，还写一些服务端的代码，这个需求又是从哪里来的呢？</p><p>这个需求其实来自优化。我们要优化一个系统的前端部分，有这么一些事情可以做：</p><ul><li>HTML结构的优化，减少DOM树的层次等等</li><li>CSS渲染性能的优化，批量写入DOM变更之类</li><li>资源文件的优化，比如小图片的合并，图像格式的处理，图标字体的使用等</li><li>JavaScript逻辑的优化，模块化，异步加载，性能优化</li><li>加载字节量的优化，主要是分摊的策略</li><li>HTTP请求的优化</li></ul><p>这里面，除了前三条，其他都可能跟后端有些关系，尤其是最后一条。但是前端的人没法去优化后端的东西，这是不同的协作环节，所以就很麻烦。</p><p>那么，如果有了全栈，这个问题可以怎么解决呢？</p><p>比如说，我们要做最原始的小文件合并，可以在服务器做一些配置，把多个合并成一个请求，比如天猫的某个url：</p><p><a href="http://g.tbcdn.cn/kissy/k/1.4.1/??dom/base-min.js,event-min.js,event/dom/base-min.js,event/base-min.js,event/dom/touch-min.js,event/dom/shake-min.js,event/dom/focusin-min.js,event/custom-min.js,cookie-min.js?t=1.js" target="_blank" rel="noopener">http://g.tbcdn.cn/kissy/k/1.4.1/??dom/base-min.js,event-min.js,event/dom/base-min.js,event/base-min.js,event/dom/touch-min.js,event/dom/shake-min.js,event/dom/focusin-min.js,event/custom-min.js,cookie-min.js?t=1.js</a></p><p>这个就很明显是多个文件合并而成的，9个小文件的请求，合并成了一个64k的文件请求。</p><p>这种简单的事情可以在静态代理服务器上配置出来，更复杂的就比较难了，需要一定的服务端逻辑。比如说，我们有多个ajax请求，请求不同的服务，每个请求的数据量都非常少，但因为请求数很多，可能会影响加载性能，如果能把它们在服务端就合并成一个就好了。但这个优化是前端发起的，传统模式下，他的职责范围有限，优化不到服务端去，而这多个服务很可能是跨产品模块的，想要合并，放在哪个后端团队都很怪异。</p><p>这可真难办，就像老虎追猴子，猴子上了树，老虎只能在下面干瞪眼。但是如果我们能让老虎上树，这就不是个问题了。如果有这么一层NodeJS，这一层完全由前端程序员控制，他就可以在这个地方做这种合并，非常的合理。</p><p>除此之外，我们常常会用到HTML模板，但使用它的最佳位置是随着产品的场景而不同的，可能某个地方在前端更好，可能某个地方在后端好些。到底放在哪合适，只有前端开发人员才会知道，如果前端开发人员不能参与一部分后端代码的开发，优化工作也还是做不彻底。有NodeJS之后会怎样呢，因为不管前端模板还是后端模板，都是JavaScript的，可以使用同一套库，这样在做调整的时候不会有代码迁移的烦恼，直接把模板换地方即可。</p><p>现在，也有很多业务场景有实时通信的需求，目前来说最合适的方案是Socket.io，它默认使用NodeJS来当服务端，这也是NodeJS的一个重要使用场景。</p><p>这样，前端开发人员也部分参与了运行在服务端的代码，他的工作范围从原先客户端浏览器，向后拓展了一个薄层，所以就有了全栈的称呼。至于说这个称呼还继续扩展，一个前端开发人员从视觉到交互到静态HTML到JavaScript包办的情况，这个就有些过头了。</p><p>以上这些，主要解决的都是代码层面的事情。另外有一个方面，也是需要关注，但却常常不能引起重视的，那就是前端的工程化问题。</p><p>早期为什么没有这些问题？因为那时候前端很简单，复杂度不高，现在整个很复杂了，就带来了很多管理问题。比如说整个系统的前端都组件化了之后，HTML会拆分成各种模板，JavaScript会拆分成各种模块，而CSS也通过LESS或者SASS这种方式，变成了一种编译式的语言。</p><p>这时候，我们考虑一个所谓的组件，它就比较麻烦了。它可能是一个或者多个HTML模板，加上一个或者多个JavaScript模块，再包含CSS中的一部分构成的，而前两者都可能有依赖项，三个部分也都要避免与其他组件的冲突。</p><p>这些东西都需要管理，并且提供一种比较好的方案去维护。在JavaScript被模块化之后，也可以通过单元测试来控制它们的质量，并且把这个过程自动化，每次版本有变更之前，保证它们最基本的正确性。最终，需要有一种自动化的发布机制，把这几类代码提取，打包合并，压缩，发布。</p><p>这个主题展开可以讲很多，所以我们不在本次分享中涉及。在我之前的几篇文章中，也阐述过观点。</p><p>目前这方面研究最深入的是之前百度FIS团队的张云龙，他的几篇文章在<a href="https://github.com/fouber/blog" title="这里" target="_blank" rel="noopener">这里</a>，强烈推荐阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端架构那些事儿&quot;&gt;&lt;a href=&quot;#前端架构那些事儿&quot; class=&quot;headerlink&quot; title=&quot;前端架构那些事儿&quot;&gt;&lt;/a&gt;前端架构那些事儿&lt;/h1&gt;&lt;p&gt;在谈前端架构之前，需要先探讨一下不同人群对前端产生的困惑。前端这个职业最近几年才逐渐被认可，之前一直是低端的代名词，所以多数高手很不屑搞这个。之前的很多项目，人们对前端这块的要求也只是能用就行，所以很少会在上面去细致、深入地建立一套完善体系。而多数产品的技术经理也会是后端出身的，往往对前端的认识还停留在Java Struts那个原始的MVC模型上，或者首先想到的就是GWT和JSF，这是从后端角度出发的一种视角。用这类思维方式做出来的产品，一般用户体验都不会很好。&lt;/p&gt;
&lt;p&gt;另一方面，从界面层上手的人群，他对用户体验这方面会把控得比较好，但通常缺架构意识，或者说是软件工程的意识。在界面层比较复杂的情况下，很可能会有失控的趋势。对整个系统结构的认知程度通常不够深入，也缺乏设计模式等方面的知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2014-10-21-build-single-page-application/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2014-10-21-build-single-page-application/</id>
    <published>2019-04-14T09:15:10.710Z</published>
    <updated>2019-04-14T09:15:10.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建单页Web应用"><a href="#构建单页Web应用" class="headerlink" title="构建单页Web应用"></a>构建单页Web应用</h1><h2 id="单页应用是什么？"><a href="#单页应用是什么？" class="headerlink" title="单页应用是什么？"></a>单页应用是什么？</h2><p>让我们先来看几个网站：</p><p><a href="https://coding.net/" target="_blank" rel="noopener">coding</a></p><p><a href="https://www.teambition.com/" target="_blank" rel="noopener">teambition</a></p><p><a href="https://c9.io/" target="_blank" rel="noopener">cloud9</a></p><p>注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。<br><a id="more"></a><br>所谓单页应用，指的是在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。它是AJAX技术的进一步升华，把AJAX的无刷新机制发挥到极致，因此能造就与桌面程序媲美的流畅用户体验。</p><p>其实单页应用我们并不陌生，很多人写过ExtJS的项目，用它实现的系统，很天然的就已经是单页的了，也有人用jQuery或者其他框架实现过类似的东西。用各种JS框架，甚至不用框架，都是可以实现单页应用的，它只是一种理念。有些框架适用于开发这种系统，如果使用它们，可以得到很多便利。</p><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成整个前端部分，甚至包括布局。随着功能逐渐增加，ExtJS的体积也逐渐增大，即使用于内部系统的开发，有时候也显得笨重了，更不用说开发以上这类运行在互联网上的系统。</p><p>jQuery由于偏重DOM操作，它的插件体系又比较松散，所以比ExtJS这个体系更适合开发在公网运行的单页系统，整个解决方案会相对比较轻量、灵活。</p><p>但由于jQuery主要面向上层操作，它对代码的组织是缺乏约束的。如何在代码急剧膨胀的情况下控制每个模块的内聚性，并且适当在模块之间产生数据传递与共享，就成为了一种有挑战的事情。</p><p>为了解决单页应用规模增大时候的代码逻辑问题，出现了不少MV*框架，他们的基本思路都是在JS层创建模块分层和通信机制。有的是MVC，有的是MVP，有的是MVVM，而且，它们几乎都在这些模式上产生了变异，以适应前端开发的特点。</p><p>这类框架包括Backbone，Knockout，AngularJS，Avalon等。</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>这些在前端做分层的框架推动了代码的组件化，所谓组件化，在传统的Web产品中，更多的指UI组件，但其实组件是一个广泛概念，传统Web产品中UI组件占比高的原因是它的厚度不足，随着客户端代码比例的增加，相当一部分的业务逻辑也前端化，由此催生了很多非界面型组件的出现。</p><p>分层带来的一个优势是，每层的职责更专一了，由此，可以对其作单元测试的覆盖，以保证其质量。传统UI层测试最头疼的问题是UI层和逻辑混杂在一起，比如往往会在远程请求的回调中更改DOM，当引入分层之后，这些东西都可以分别被测试，然后再通过场景测试来保证整体流程。</p><h2 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h2><p>与开发传统页面型网站相比，实现单页应用的过程中，有一些比较值得特别关注的点。</p><p>从单页应用的特点来看，它比页面型网站更加依赖于JavaScript，而由于页面的单页化，各种子功能的JavaScript代码聚集到了同一个作用域，所以代码的隔离、模块化变得很重要。</p><p>在单页应用中，页面模板的使用是很普遍的。很多框架内置了特定的模板，也有的框架需要引入第三方的模板。这种模板是界面片段，我们可以把它们类比成JavaScript模块，它们是另一种类型的组件。</p><p>模板也一样有隔离的需要。不隔离模板，会造成什么问题呢？模板间的冲突主要存在于id属性上，如果一个模板中包含固定的id，当它被批量渲染的时候，会造成同一个页面的作用域中出现多个相同id的元素，产生不可预测的后果。因此，我们需要在模板中避免使用id，如果有对DOM的访问需求，应当通过其他选择器来完成。如果一个单页应用的组件化程度非常高，很可能整个应用中都没有元素id的使用。</p><h2 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h2><p>人们对于单页系统的加载时间容忍度与Web页面不同，如果说他们愿意为购物页面的加载等待3秒，有可能会愿意为单页应用的首次加载等待5-10秒，但在此之后，各种功能的使用应当都比较流畅，所有子功能页面尽量要在1-2秒时间内切换成功，否则他们就会感觉这个系统很慢。</p><p>从这些特点来看，我们可以把更多的公共功能放到首次加载，以减小每次加载的载入量，有一些站点甚至把所有的界面和逻辑全部放到首页加载，每次业务界面切换的时候，只产生数据请求，因此它的响应是非常迅速的，比如青云的控制台就是这么做的。</p><p>通常在单页应用中，无需像网站型产品一样，为了防止文件加载阻塞渲染，把js放到html后面加载，因为它的界面基本都是动态生成的。</p><p>当切换功能的时候，除了产生数据请求，还需要渲染界面，这个新渲染的界面部件一般是界面模板，它从哪里来呢？来源无非是两种，一种是即时请求，像请求数据那样通过AJAX获取过来，另一种是内置于主界面的某些位置，比如script标签或者不可见的textarea中，后者在切换功能的时候速度有优势，但是加重了主页面的负担。</p><p>在传统的页面型网站中，页面之间是互相隔离的，因此，如果在页面间存在可复用的代码，一般是提取成单独的文件，并且可能会需要按照每个页面的需求去进行合并。单页应用中，如果总的代码量不大，可以整体打包一次在首页载入，如果大到一定规模，再作运行时加载，加载的粒度可以搞得比较大，不同的块之间没有重复部分。</p><h2 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h2><p>我们最开始看到的几个在线应用，有的是对路由作了管理的，有的没有。</p><p>管理路由的目的是什么呢？是为了能减少用户的导航成本。比如说我们有一个功能，经历过多次导航菜单的点击，才呈现出来。如果用户想要把这个功能地址分享给别人，他怎么才能做到呢？</p><p>传统的页面型产品是不存在这个问题的，因为它就是以页面为单位的，也有的时候，服务端路由处理了这一切。但是在单页应用中，这成为了问题，因为我们只有一个页面，界面上的各种功能区块是动态生成的。所以我们要通过对路由的管理，来实现这样的功能。</p><p>具体的做法就是把产品功能划分为若干状态，每个状态映射到相应的路由，然后通过pushState这样的机制，动态解析路由，使之与功能界面匹配。</p><p>有了路由之后，我们的单页面产品就可以前进后退，就像是在不同页面之间一样。</p><p>其实在Web产品之外，早就有了管理路由的技术方案，Adobe Flex中，就会把比如TabNavigator，甚至下拉框的选中状态对应到url上，因为它也是单“页面”的产品模式，需要面对同样的问题。</p><p>当产品状态复杂到一定程度的时候，路由又变得很难应用了，因为状态的管理极其麻烦，比如开始的时候我们演示的c9.io在线IDE，它就没法把状态对应到url上。</p><h2 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h2><p>在单页应用的运作机制中，缓存是一个很重要的环节。</p><p>由于这类系统的前端部分几乎全是静态文件，所以它能够有机会利用浏览器的缓存机制，而比如动态加载的界面模板，也完全可以做一些自定义的缓存机制，在非首次的请求中直接取缓存的版本，以加快加载速度。</p><p>甚至，也出现了一些方案，在动态加载JavaScript代码的同时，把它们也缓存起来。比如Addy Osmani的这个<a href="https://github.com/addyosmani/basket.js" target="_blank" rel="noopener">basket.js</a>，就利用了HTML5 localStorage作了js和css文件的缓存。</p><p>在单页产品中，业务代码也常常会需要跟本地存储打交道，存储一些临时数据，可以使用<a href="https://github.com/mortzdk/localStorage" target="_blank" rel="noopener">localStorage</a>或者<a href="https://github.com/knadh/localStorageDB" target="_blank" rel="noopener">localStorageDB</a>来简化自己的业务代码。</p><h2 id="服务端通信"><a href="#服务端通信" class="headerlink" title="服务端通信"></a>服务端通信</h2><p>传统的Web产品通常使用JSONP或者AJAX这样的方式与服务端通信，但在单页Web应用中，有很大一部分采用WebSocket这样的实时通讯方式。</p><p>WebSocket与传统基于HTTP的通信机制相比，有很大的优势。它可以让服务端很便利地使用反向推送，前端只响应确实产生业务数据的事件，减少一遍又一遍无意义的AJAX轮询。</p><p>由于WebSocket只在比较先进的浏览器上被支持，有一些库提供了在不同浏览器中的兼容方案，比如socket.io，它在不支持WebSocket的浏览器上会降级成使用AJAX或JSONP等方式，对业务代码完全透明、兼容。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>传统的Web页面一般是不需要考虑内存的管理的，因为用户的停留时间相对少，即使出现内存泄漏，可能很快就被刷新页面之类的操作冲掉了，但单页应用是不同的，它的用户很可能会把它开一整天，因此，我们需要对其中的DOM操作、网络连接等部分格外小心。</p><h2 id="样式的规划"><a href="#样式的规划" class="headerlink" title="样式的规划"></a>样式的规划</h2><p>在单页应用中，因为页面的集成度高，所有页面聚集到同一作用域，样式的规划也变得重要了。</p><p>样式规划主要是几个方面：</p><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>这里面主要包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式支持。</p><h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>这里面是两个层面的规划，首先是各种界面组件及其子元素的样式，其次是一些修饰样式。组件样式应当尽量减少互相依赖，各组件的样式允许冗余。</p><h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>传统Web页面的特点是元素多，但是层次少，单页应用会有些不同。</p><p>在单页应用中，需要提前为各种UI组件规划堆叠次序，也就是z-index，比如说，我们可能会有各种弹出对话框，浮动层，它们可能组合成各种堆叠状态。新的对话框的z-index需要比旧的高，才能确保盖在它上面。诸如此类，都需要我们对这些可能的遮盖作规划，那么，怎样去规划呢？</p><p>了解通信知识的人，应当会知道，不同的频率段被划分给不同的通信方式使用，在一些国家，领空的使用也是有划分的，我们也可以用同样的方式来预先分段，不同类型的组件的z-index落到各自的区间，以避免它们的冲突。</p><h2 id="单页应用的产品形态"><a href="#单页应用的产品形态" class="headerlink" title="单页应用的产品形态"></a>单页应用的产品形态</h2><p>我们在开始的时候提到，存在着很多新型Web产品，使用单页应用的方式构建，但实际上，这类产品不仅仅存在于Web上。点开Chrome商店，我们会发现很多离线应用，这些产品都可以算是单页应用的体现。</p><p>除了各种浏览器插件，借助node-webkit这样的外壳平台，我们可以使用Web技术来构建本地应用，产品的主要部分仍然是我们熟悉的单页应用。</p><p>单页应用的流行程度正在逐渐增加，大家如果关注了一些初创型互联网企业，会发现其中很大一部分的产品模式是单页化的。这种模式能带给用户流畅的体验，在开发阶段，对JavaScript技能水平要求较高。</p><p>单页应用开发过程中，前后端是天然分离的，双方以API为分界。前端作为服务的消费者，后端作为服务的提供者。在此模式下，前端将会推动后端的服务化。当后端不再承担模板渲染、输出页面这样工作的情况下，它可以更专注于所提供的API的实现，而在这样的情况下，Web前端与各种移动终端的地位对等，也逐渐使得后端API不必再为每个端作差异化设计了。</p><h2 id="部署模式的改变"><a href="#部署模式的改变" class="headerlink" title="部署模式的改变"></a>部署模式的改变</h2><p>在现在这个时代，我们已经可以看到一种产品的出现了，那就是“无后端”的Web应用。这是一种什么东西呢？基于这种理念，你的产品很可能只需要自己编写静态Web页面，在某种BaaS（Backend as a Service）云平台上定制服务端API和云存储，集成这个平台提供的SDK，通过AJAX等方式与之打交道，实现注册认证、社交、消息推送、实时通信、云存储等功能。</p><p>我们观察一下这种模式，会发现前后端的部署已经完全分离了，前端代码完全静态化，这意味着可以把它们放置到CDN上，访问将大大地加速，而服务端托管在BaaS云上，开发者也不必去关注一些部署方面的繁琐细节。</p><p>假设你是一名创业者，正在做的是一种实时协同的单页产品，可以在云平台上，快速定制后端服务，把绝大部分宝贵的时间花在开发产品本身上。</p><h2 id="单页应用的缺陷"><a href="#单页应用的缺陷" class="headerlink" title="单页应用的缺陷"></a>单页应用的缺陷</h2><p>单页应用最根本的缺陷就是不利于SEO，因为界面的绝大部分都是动态生成的，所以搜索引擎很不容易索引它。</p><h2 id="产品单页化带来的挑战"><a href="#产品单页化带来的挑战" class="headerlink" title="产品单页化带来的挑战"></a>产品单页化带来的挑战</h2><p>一个产品想要单页化，首先是它必须适合单页的形态。其次，在这个过程中，对开发模式会产生一些变更，对开发技能也会有一些要求。</p><p>开发者的JavaScript技能必须过关，同时需要对组件化、设计模式有所认识，他所面对的不再是一个简单的页面，而是一个运行在浏览器环境中的桌面软件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构建单页Web应用&quot;&gt;&lt;a href=&quot;#构建单页Web应用&quot; class=&quot;headerlink&quot; title=&quot;构建单页Web应用&quot;&gt;&lt;/a&gt;构建单页Web应用&lt;/h1&gt;&lt;h2 id=&quot;单页应用是什么？&quot;&gt;&lt;a href=&quot;#单页应用是什么？&quot; class=&quot;headerlink&quot; title=&quot;单页应用是什么？&quot;&gt;&lt;/a&gt;单页应用是什么？&lt;/h2&gt;&lt;p&gt;让我们先来看几个网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://coding.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;coding&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teambition.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;teambition&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://c9.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cloud9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2013-07-01-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2013-07-01-从零开始编写自己的JavaScript框架（一）/</id>
    <published>2019-04-14T09:10:49.496Z</published>
    <updated>2019-04-14T09:10:49.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始编写自己的JavaScript框架（一）"><a href="#从零开始编写自己的JavaScript框架（一）" class="headerlink" title="从零开始编写自己的JavaScript框架（一）"></a>从零开始编写自己的JavaScript框架（一）</h1><p>#1. 模块的定义和加载</p><p>##1.1 模块的定义</p><p>一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。</p><p>先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？</p><p>我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。</p><p>考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。<br><a id="more"></a><br>JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？</p><p>在很多传统高级语言里，变量作用域的边界是大括号，在{}里面定义的变量，作用域不会传到外面去，但我们的JavaScript大人不是这样的，他的边界是function。所以我们这段代码，i仍然能打出值：</p><pre><code>for (var i=0; i&lt;5; i++) {    //do something}alert(i);</code></pre><p>那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。</p><p>我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过：<br>C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！”<br>Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！”<br>C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！</p><p>啊，我们发现了什么，既然无法避免全局的作用域，那与其让100个function都全局，不如只让一个来全局，其他的都由它管理。</p><p>本来我们打算自己当上帝的，现在只好改行先当个工商局长。你想开店吗？先来注册，不然封杀你！于是良民们纷纷来注册。店名叫什么，从哪进货，卖什么的，一一登记在案，为了方便下面的讨论，我们连进货的过程都让工商局管理起来。</p><p>店名，指的就是这里的模块名，从哪里进货，代表它依赖什么其他模块，卖什么，表示它对外提供一些什么特性。</p><p>好了，考虑到我们的这个注册管理机构是个全局作用域，我们还得把它挂在window上作为属性，然后再用一个function隔离出来，要不然，别人也定义一个同名的，就把我们覆盖掉了。</p><pre><code>(function() {    window.thin = {        define: function(name, dependencies, factory) {            //register a module        }    };})();</code></pre><p>在这个module方法内部，应当怎么去实现呢？我们的module应当有一个地方存储，但存储是要在工商局内部的，不是随便什么人都可以看到的，所以，这个存储结构也放在工商局同样的作用域里。</p><p>用什么结构去存储呢？工商局备案的时候，店名不能跟已有的重复，所以我们发现这是用map的很好场景，考虑到JavaScript语言层面没有map，我们弄个Object来存。</p><pre><code>(function() {    var moduleMap = {};    window.thin = {        define: function(name, dependencies, factory) {            if (!moduleMap[name]) {                var module = {                    name: name,                    dependencies: dependencies,                    factory: factory                };                moduleMap[name] = module;            }            return moduleMap[name];        }    };})();</code></pre><p>现在，模块的存储结构就搞好了。</p><p>##1.2 模块的使用</p><p>存的部分搞好了，我们来看看怎么取。现在来了一个商家，卖木器的，他需要从一个卖钉子的那边进货，卖钉子的已经来注册过了，现在要让这个木器厂能买到钉子。现在的问题是，两个商家处于不同的作用域，也就是说，它们互相不可见，那通过什么方式，我们才能让他们产生调用关系呢？</p><p>个人解决不了的问题还是得靠政府，有困难要坚决克服，没有困难就制造困难来克服。现在困难有了，该克服了。商家说，我能不能给你我的进货名单，你帮我查一下它们在哪家店，然后告诉我？这么简单的要求当然一口答应下来，但是采用什么方式传递给你呢？这可犯难了。</p><p>我们参考AngularJS框架，写了一个类似的代码：</p><pre><code>thin.define(&quot;A&quot;, [], function() {    //module A});thin.define(&quot;B&quot;, [&quot;A&quot;], function(A) {    //module B    var a = new A();});</code></pre><p>看这段代码特别在哪里呢？模块A的定义，毫无特别之处，主要看模块B。它在依赖关系里写了一个字符串的A，然后在工厂方法的形参写了一个真真切切的A类型。嗯？这个有些奇怪啊，你的A类型要怎么传递过来呢？其实是很简单的，因为我们声明了依赖项的数组，所以可以从依赖项，挨个得到对应的工厂方法，然后创建实例，传进来。</p><pre><code>use: function(name) {    var module = moduleMap[name];    if (!module.entity) {        var args = [];        for (var i=0; i&lt;module.dependencies.length; i++) {            if (moduleMap[module.dependencies[i]].entity) {                args.push(moduleMap[module.dependencies[i]].entity);            }            else {                args.push(this.use(module.dependencies[i]));            }        }        module.entity = module.factory.apply(noop, args);    }    return module.entity;}</code></pre><p>我们可以看到，这里面递归获取了依赖项，然后当作参数，用这个模块的工厂方法来实例化了一下。这里我们多做了一个判断，如果模块工厂已经执行过，就缓存在entity属性上，不需要每次都创建。以此类推，假如一个模块有多个依赖项，也可以用类似的方式写，毫无压力：</p><pre><code>thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(A, B, C) {    //module D    var a = new A();    var b = new B();    var c = new C();});</code></pre><p>注意了，D模块的工厂，实参的名称未必就要是跟依赖项一致，比如，以后我们代码较多，可以给依赖项和模块名称加命名空间，可能变成这样：</p><pre><code>thin.define(&quot;foo.D&quot;, [&quot;foo.A&quot;, &quot;foo.B&quot;, &quot;foo.C&quot;], function(A, B, C) {    //module D    var a = new A();    var b = new B();    var c = new C();});</code></pre><p>这段代码仍然可以正常运行。我们来做另外一个测试，改变形参的顺序：</p><pre><code>thin.define(&quot;A&quot;, [], function() {    return &quot;a&quot;;});thin.define(&quot;B&quot;, [], function() {    return &quot;b&quot;;});thin.define(&quot;C&quot;, [], function() {    return &quot;c&quot;;});thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(B, A, C) {    return B + A + C;});var D = thin.use(&quot;D&quot;);alert(D);</code></pre><p>试试看，我们的D打出什么结果呢？结果是”abc”，所以说，模块工厂的实参只跟依赖项的定义有关，跟形参的顺序无关。我们看到，在AngularJS里面，并非如此，实参的顺序是跟形参一致的，这是怎么做到的呢？</p><p>我们先离开代码，思考这么一个问题：如何得知函数的形参名数组？对，我们是可以用func.length得到形参个数，但无法得到每个形参的变量名，那怎么办呢？</p><p>AngularJS使用了一种比较极端的办法，分析了函数的字面量。众所周知，在JavaScript中，任何对象都隐含了toString方法，对于一个函数来说，它的toString就是自己的实现代码，包含函数签名和注释。下面我贴一下AngularJS里面的这部分代码：</p><pre><code>var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;var FN_ARG_SPLIT = /,/;var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;function annotate(fn) {  var $inject,      fnText,      argDecl,      last;  if (typeof fn == &apos;function&apos;) {    if (!($inject = fn.$inject)) {      $inject = [];      fnText = fn.toString().replace(STRIP_COMMENTS, &apos;&apos;);      argDecl = fnText.match(FN_ARGS);      forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){        arg.replace(FN_ARG, function(all, underscore, name){          $inject.push(name);        });      });      fn.$inject = $inject;    }  } else if (isArray(fn)) {    last = fn.length - 1;    assertArgFn(fn[last], &apos;fn&apos;);    $inject = fn.slice(0, last);  } else {    assertArgFn(fn, &apos;fn&apos;, true);  }  return $inject;}</code></pre><p>可以看到，这个代码也不长，重点是类型为function的那段，首先去除了注释，然后获取了形参列表字符串，这段正则能获取到两个结果，第一个是全函数的实现，第二个才是真正的形参列表，取第二个出来split，就得到了形参的字符串列表了，然后按照这个顺序再去加载依赖模块，就可以让形参列表不对应于依赖项数组了。</p><p>AngularJS的这段代码很强大，但是要损耗一些性能，考虑到我们的框架首要原则是简单，甚至可以为此牺牲一些灵活性，我们不做这么复杂的事情了。</p><p>##1.3 模块的加载</p><p>到目前为止，我们可以把多个模块都定义在一个文件中，然后手动引入这个js文件，但是如果一个页面要引用很多个模块，引入工作就变得比较麻烦，比如说，单页应用程序（SPA）一般比较复杂，往往包含数以万计行数的js代码，这些代码至少分布在几十个甚至成百上千的模块中，如果我们也在主界面就加载它们，载入时间会非常难以接受。但我们可以这样看：主界面加载的时候，并不是用到了所有这些功能，能否先加载那些必须的，而把剩下的放在需要用的时候再去加载？</p><p>所以我们可以考虑万能的AJAX，从服务端获取一个js的内容，然后……，怎么办，你当然说不能eval了，因为据说eval很evil啦，但是它evil在哪里呢？主要是破坏全局作用域啦，怎么怎么，但是如果这些文件里面都是按照我们规定的模块格式写，好像也没有什么在全局作用域的……，好吧。</p><p>算了，我们还是用最简单的方式了，就是动态创建script标签，然后设置src，添加到document.head里，然后监听它们的完成事件，做后续操作。真的很简单，因为我们的框架不需要考虑那么多种情况，不需要AMD，不需要require那么麻烦，用这框架的人必须按照这里的原则写。</p><p>我也偷懒了，只是贴一下代码，顺便解释一下，界面把所依赖的js文件路径放在数组里，然后挨个创建script标签，src设置为路径，添加到head中，监听它们的完成事件。在这个完成时间里，我们要做这么一些事情：在fileMap里记录当前js文件的路径，防止以后重复加载，检查列表中所有文件，看看是否全部加载完了，如果全加载好了，就执行回调。</p><pre><code>require: function (pathArr, callback) {    for (var i = 0; i &lt; pathArr.length; i++) {        var path = pathArr[i];        if (!fileMap[path]) {            var head = document.getElementsByTagName(&apos;head&apos;)[0];            var node = document.createElement(&apos;script&apos;);            node.type = &apos;text/javascript&apos;;            node.async = &apos;true&apos;;            node.src = path + &apos;.js&apos;;            node.onload = function () {                fileMap[path] = true;                head.removeChild(node);                checkAllFiles();            };            head.appendChild(node);        }    }    function checkAllFiles() {        var allLoaded = true;        for (var i = 0; i &lt; pathArr.length; i++) {            if (!fileMap[pathArr[i]]) {                allLoaded = false;                break;            }        }        if (allLoaded) {            callback();        }    }}</code></pre><p>##1.4 小结</p><p>到此为止，我们的简易框架的模块定义系统就完成了。完整的代码如下：</p><pre><code>(function () {    var moduleMap = {};    var fileMap = {};    var noop = function () {    };    var thin = {        define: function(name, dependencies, factory) {            if (!moduleMap[name]) {                var module = {                    name: name,                    dependencies: dependencies,                    factory: factory                };                moduleMap[name] = module;            }            return moduleMap[name];        },        use: function(name) {            var module = moduleMap[name];            if (!module.entity) {                var args = [];                for (var i=0; i&lt;module.dependencies.length; i++) {                    if (moduleMap[module.dependencies[i]].entity) {                        args.push(moduleMap[module.dependencies[i]].entity);                    }                    else {                        args.push(this.use(module.dependencies[i]));                    }                }                module.entity = module.factory.apply(noop, args);            }            return module.entity;        },        require: function (pathArr, callback) {            for (var i = 0; i &lt; pathArr.length; i++) {                var path = pathArr[i];                if (!fileMap[path]) {                    var head = document.getElementsByTagName(&apos;head&apos;)[0];                    var node = document.createElement(&apos;script&apos;);                    node.type = &apos;text/javascript&apos;;                    node.async = &apos;true&apos;;                    node.src = path + &apos;.js&apos;;                    node.onload = function () {                        fileMap[path] = true;                        head.removeChild(node);                        checkAllFiles();                    };                    head.appendChild(node);                }            }            function checkAllFiles() {                var allLoaded = true;                for (var i = 0; i &lt; pathArr.length; i++) {                    if (!fileMap[pathArr[i]]) {                        allLoaded = false;                        break;                    }                }                if (allLoaded) {                    callback();                }            }        }    };    window.thin = thin;})();</code></pre><p>测试代码如下：</p><pre><code>thin.define(&quot;constant.PI&quot;, [], function() {    return 3.14159;});thin.define(&quot;shape.Circle&quot;, [&quot;constant.PI&quot;], function(pi) {    var Circle = function(r) {        this.r = r;    };    Circle.prototype = {        area : function() {            return pi * this.r * this.r;        }    }    return Circle;});thin.define(&quot;shape.Rectangle&quot;, [], function() {    var Rectangle = function(l, w) {        this.l = l;        this.w = w;    };    Rectangle.prototype = {        area: function() {            return this.l * this.w;        }    };    return Rectangle;});thin.define(&quot;ShapeTypes&quot;, [&quot;shape.Circle&quot;, &quot;shape.Rectangle&quot;], function(Circle, Rectangle) {    return {        CIRCLE: Circle,        RECTANGLE: Rectangle    };});thin.define(&quot;ShapeFactory&quot;, [&quot;ShapeTypes&quot;], function(ShapeTypes) {    return {        getShape: function(type) {            var shape;            switch (type) {                case &quot;CIRCLE&quot;: {                    shape = new ShapeTypes[type](arguments[1]);                    break;                }                case &quot;RECTANGLE&quot;:  {                    shape = new ShapeTypes[type](arguments[1], arguments[2]);                    break;                }            }            return shape;        }    };});var ShapeFactory = thin.use(&quot;ShapeFactory&quot;);alert(ShapeFactory.getShape(&quot;CIRCLE&quot;, 5).area());alert(ShapeFactory.getShape(&quot;RECTANGLE&quot;, 3, 4).area());</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始编写自己的JavaScript框架（一）&quot;&gt;&lt;a href=&quot;#从零开始编写自己的JavaScript框架（一）&quot; class=&quot;headerlink&quot; title=&quot;从零开始编写自己的JavaScript框架（一）&quot;&gt;&lt;/a&gt;从零开始编写自己的JavaScript框架（一）&lt;/h1&gt;&lt;p&gt;#1. 模块的定义和加载&lt;/p&gt;
&lt;p&gt;##1.1 模块的定义&lt;/p&gt;
&lt;p&gt;一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。&lt;/p&gt;
&lt;p&gt;先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？&lt;/p&gt;
&lt;p&gt;我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。&lt;/p&gt;
&lt;p&gt;考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2013-01-14-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2013-01-14-前端开发技术的发展/</id>
    <published>2019-04-14T09:10:49.493Z</published>
    <updated>2019-04-14T09:10:49.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端开发技术的发展"><a href="#前端开发技术的发展" class="headerlink" title="前端开发技术的发展"></a>前端开发技术的发展</h1><p>前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了：</p><ul><li>专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。</li><li>VML和SVG等基于XML的描述图形的语言。</li><li>从属于XML体系的XML，XPath，DTD等技术。</li><li>用于支撑后端的ASP，JSP，ASP.net，PHP，nodejs等语言或者技术。</li><li>被第三方程序打包的一种类似浏览器的宿主环境，比如Adobe AIR和使用HyBird方式的一些开发技术，如PhoneGap（它使用Android中的WebView等技术，让开发人员使用传统Web开发技术来开发本地应用）</li><li>Adobe Flash，Flex，Microsoft Silverlight，Java Applet，JavaFx等RIA开发技术。</li></ul><p>本文从狭义的前端定义出发，探讨一下这方面开发技术的发展过程。<br><a id="more"></a><br>从前端开发技术的发展来看，大致可以分为以下几个阶段：</p><p>#一. 刀耕火种</p><p>##1. 静态页面</p><p>最早期的Web界面基本都是在互联网上使用，人们浏览某些内容，填写几个表单，并且提交。当时的界面以浏览为主，基本都是HTML代码，有时候穿插一些JavaScript，作为客户端校验这样的基础功能。代码的组织比较简单，而且CSS的运用也是比较少的。</p><p>最简单的是这样一个文件：</p><pre><code>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;测试一&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;主标题&lt;/h1&gt;        &lt;p&gt;段落内容&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>##2. 带有简单逻辑的界面<br>这个界面带有一段JavaScript代码，用于拼接两个输入框中的字符串，并且弹出窗口显示。</p><pre><code>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;测试二&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input id=&quot;firstNameInput&quot; type=&quot;text&quot; /&gt;         &lt;input id=&quot;lastNameInput&quot; type=&quot;text&quot; /&gt;         &lt;input type=&quot;button&quot; onclick=&quot;greet()&quot; /&gt;        &lt;script language=&quot;JavaScript&quot;&gt;        function greet() {            var firstName = document.getElementById(&quot;firstNameInput&quot;).value;            var lastName = document.getElementById(&quot;lastNameInput&quot;).value;            alert(&quot;Hello, &quot; + firstName + &quot;.&quot; + lastName);        }        &lt;/script&gt;     &lt;/body&gt;&lt;/html&gt;</code></pre><p>##3. 结合了服务端技术的混合编程</p><p>由于静态界面不能实现保存数据等功能，出现了很多服务端技术，早期的有CGI（Common Gateway Interface，多数用C语言或者Perl实现的），ASP（使用VBScript或者JScript），JSP（使用Java），PHP等等，Python和Ruby等语言也常被用于这类用途。</p><p>有了这类技术，在HTML中就可以使用表单的post功能提交数据了，比如：</p><pre><code>&lt;form method=&quot;post&quot; action=&quot;username.asp&quot;&gt;    &lt;p&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot; /&gt;&lt;/p&gt;    &lt;p&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; /&gt;&lt;/p&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;</code></pre><p>在这个阶段，由于客户端和服务端的职责未作明确的划分，比如生成一个字符串，可以由前端的JavaScript做，也可以由服务端语言做，所以通常在一个界面里，会有两种语言混杂在一起，用&lt;%和%&gt;标记的部分会在服务端执行，输出结果，甚至经常有把数据库连接的代码跟页面代码混杂在一起的情况，给维护带来较大的不便。</p><pre><code>&lt;html&gt;    &lt;body&gt;        &lt;p&gt;Hello world!&lt;/p&gt;        &lt;p&gt;        &lt;%            response.write(&quot;Hello world from server!&quot;)        %&gt;        &lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>##4.组件化的萌芽</p><p>这个时代，也逐渐出现了组件化的萌芽。比较常见的有服务端的组件化，比如把某一类服务端功能单独做成片段，然后其他需要的地方来include进来，典型的有：ASP里面数据库连接的地方，把数据源连接的部分写成conn.asp，然后其他每个需要操作数据库的asp文件包含它。</p><p>上面所说的是在服务端做的，浏览器端通常有针对JavaScript的，把某一类的Javascript代码写到单独的js文件中，界面根据需要，引用不同的js文件。针对界面的组件方式，通常利用frameset和iframe这两个标签。某一大块有独立功能的界面写到一个html文件，然后在主界面里面把它当作一个frame来载入，一般的B/S系统集成菜单的方式都是这样的。</p><p>此外，还出现了一些基于特定浏览器的客户端组件技术，比如IE浏览器的HTC（HTML Component）。这种技术最初是为了对已有的常用元素附加行为的，后来有些场合也用它来实现控件。微软ASP.net的一些版本里，使用这种技术提供了树形列表，日历，选项卡等功能。HTC的优点是允许用户自行扩展HTML标签，可以在自己的命名空间里定义元素，然后，使用HTML，JavaScript和CSS来实现它的布局、行为和观感。这种技术因为是微软的私有技术，所以逐渐变得不那么流行。</p><p>Firefox浏览器里面推出过一种叫XUL的技术，也没有流行起来。</p><p>#二. 铁器时代</p><p>这个时代的典型特征是Ajax的出现。</p><p>##1. AJAX<br>AJAX其实是一系列已有技术的组合，早在这个名词出现之前，这些技术的使用就已经比较广泛了，GMail因为恰当地应用了这些技术，获得了很好的用户体验。</p><p>由于Ajax的出现，规模更大，效果更好的Web程序逐渐出现，在这些程序中，JavaScript代码的数量迅速增加。出于代码组织的需要，“JavaScript框架”这个概念逐步形成，当时的主流是prototype和mootools，这两者各有千秋，提供了各自方式的面向对象组织思路。</p><p>##2. JavaScript基础库</p><p>Prototype框架主要是为JavaScript代码提供了一种组织方式，对一些原生的JavaScript类型提供了一些扩展，比如数组、字符串，又额外提供了一些实用的数据结构，如：枚举，Hash等，除此之外，还对dom操作，事件，表单和Ajax做了一些封装。</p><p>Mootools框架的思路跟Prototype很接近，它对JavaScript类型扩展的方式别具一格，所以在这类框架中，经常被称作“最优雅的”对象扩展体系。</p><p>从这两个框架的所提供的功能来看，它们的定位是核心库，在使用的时候一般需要配合一些外围的库来完成。</p><p>jQuery与这两者有所不同，它着眼于简化DOM相关的代码。<br>例如：</p><ul><li>DOM的选择</li></ul><p>jQuery提供了一系列选择器用于选取界面元素，在其他一些框架中也有类似功能，但是一般没有它的简洁、强大。</p><pre><code>$(&quot;*&quot;)                //选取所有元素$(&quot;#lastname&quot;)        //选取id为lastname的元素$(&quot;.intro&quot;)            //选取所有class=&quot;intro&quot;的元素$(&quot;p&quot;)                //选取所有&amp;lt;p&amp;gt;元素$(&quot;.intro.demo&quot;)    //选取所有 class=&quot;intro&quot;且class=&quot;demo&quot;的元素</code></pre><ul><li>链式表达式：</li></ul><p>在jQuery中，可以使用链式表达式来连续操作dom，比如下面这个例子：</p><p>如果不使用链式表达式，可能我们需要这么写：</p><pre><code>var neat = $(&quot;p.neat&quot;);neat.addClass(&quot;ohmy&quot;);neat.show(&quot;slow&quot;);</code></pre><p>但是有了链式表达式，我们只需要这么一行代码就可以完成这些：</p><pre><code>$(&quot;p.neat&quot;).addClass(&quot;ohmy&quot;).show(&quot;slow&quot;);</code></pre><p>除此之外，jQuery还提供了一些动画方面的特效代码，也有大量的外围库，比如jQuery UI这样的控件库，jQuery mobile这样的移动开发库等等。</p><p>##3. 模块代码加载方式</p><p>以上这些框架提供了代码的组织能力，但是未能提供代码的动态加载能力。动态加载JavaScript为什么重要呢？因为随着Ajax的普及，jQuery等辅助库的出现，Web上可以做很复杂的功能，因此，单页面应用程序（SPA，Single Page Application）也逐渐多了起来。</p><p>单个的界面想要做很多功能，需要写的代码是会比较多的，但是，并非所有的功能都需要在界面加载的时候就全部引入，如果能够在需要的时候才加载那些代码，就把加载的压力分担了，在这个背景下，出现了一些用于动态加载JavaScript的框架，也出现了一些定义这类可被动态加载代码的规范。</p><p>在这些框架里，知名度比较高的是RequireJS，它遵循一种称为AMD（Asynchronous Module Definition）的规范。</p><p>比如下面这段，定义了一个动态的匿名模块，它依赖math模块</p><pre><code>define([&quot;math&quot;], function(math) {    return {        addTen : function(x) {            return math.add(x, 10);        }    };}); </code></pre><p>假设上面的代码存放于adder.js中，当需要使用这个模块的时候，通过如下代码来引入adder：</p><pre><code>&lt;script src=&quot;require.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    require([&quot;adder&quot;], function(adder) {        //使用这个adder    }); &lt;/script&gt;</code></pre><p>RequireJS除了提供异步加载方式，也可以使用同步方式加载模块代码。AMD规范除了使用在前端浏览器环境中，也可以运行于nodejs等服务端环境，nodejs的模块就是基于这套规范定义的。（修订，这里弄错了，nodejs是基于类似的CMD规范的）</p><p>#三. 工业革命</p><p>这个时期，随着Web端功能的日益复杂，人们开始考虑这样一些问题：</p><ul><li>如何更好地模块化开发</li><li>业务数据如何组织</li><li>界面和业务数据之间通过何种方式进行交互</li></ul><p>在这种背景下，出现了一些前端MVC、MVP、MVVM框架，我们把这些框架统称为MV*框架。这些框架的出现，都是为了解决上面这些问题，具体的实现思路各有不同，主流的有Backbone，AngularJS，Ember，Spine等等，本文主要选用Backbone和AngularJS来讲述以下场景。</p><p>##1. 数据模型</p><p>在这些框架里，定义数据模型的方式与以往有些差异，主要在于数据的get和set更加有意义了，比如说，可以把某个实体的get和set绑定到RESTful的服务上，这样，对某个实体的读写可以更新到数据库中。另外一个特点是，它们一般都提供一个事件，用于监控数据的变化，这个机制使得数据绑定成为可能。</p><p>在一些框架中，数据模型需要在原生的JavaScript类型上做一层封装，比如Backbone的方式是这样：</p><pre><code>var Todo = Backbone.Model.extend({    // Default attributes for the todo item.    defaults : function() {        return {            title : &quot;empty todo...&quot;,            order : Todos.nextOrder(),            done : false        };    },    // Ensure that each todo created has `title`.    initialize : function() {        if (!this.get(&quot;title&quot;)) {            this.set({                &quot;title&quot; : this.defaults().title            });        }    },    // Toggle the &apos;done&apos; state of this todo item.    toggle : function() {        this.save({            done : !this.get(&quot;done&quot;)        });    }});</code></pre><p>上述例子中，defaults方法用于提供模型的默认值，initialize方法用于做一些初始化工作，这两个都是约定的方法，toggle是自定义的，用于保存todo的选中状态。</p><p>除了对象，Backbone也支持集合类型，集合类型在定义的时候要通过model属性指定其中的元素类型。</p><pre><code>// The collection of todos is backed by *localStorage* instead of a remote server.var TodoList = Backbone.Collection.extend({    // Reference to this collection&apos;s model.    model : Todo,    // Save all of the todo items under the &apos;&quot;todos-backbone&quot;&apos; namespace.    localStorage : new Backbone.LocalStorage(&quot;todos-backbone&quot;),    // Filter down the list of all todo items that are finished.    done : function() {        return this.filter(function(todo) {            return todo.get(&apos;done&apos;);        });    },    // Filter down the list to only todo items that are still not finished.    remaining : function() {        return this.without.apply(this, this.done());    },    // We keep the Todos in sequential order, despite being saved by unordered     //GUID in the database. This generates the next order number for new items.    nextOrder : function() {        if (!this.length)            return 1;        return this.last().get(&apos;order&apos;) + 1;    },    // Todos are sorted by their original insertion order.    comparator : function(todo) {        return todo.get(&apos;order&apos;);    }});</code></pre><p>数据模型也可以包含一些方法，比如自身的校验，或者跟后端的通讯、数据的存取等等，在上面两个例子中，也都有体现。</p><p>AngularJS的模型定义方式与Backbone不同，可以不需要经过一层封装，直接使用原生的JavaScript简单数据、对象、数组，相对来说比较简便。</p><p>##2. 控制器</p><p>在Backbone中，是没有独立的控制器的，它的一些控制的职责都放在了视图里，所以其实这是一种MVP（Model View Presentation）模式，而AngularJS有很清晰的控制器层。</p><p>还是以这个todo为例，在AngularJS中，会有一些约定的注入，比如$scope，它是控制器、模型和视图之间的桥梁。在控制器定义的时候，将$scope作为参数，然后，就可以在控制器里面为它添加模型的支持。</p><pre><code>function TodoCtrl($scope) {    $scope.todos = [{        text : &apos;learn angular&apos;,        done : true    }, {        text : &apos;build an angular app&apos;,        done : false    }];    $scope.addTodo = function() {        $scope.todos.push({            text : $scope.todoText,            done : false        });        $scope.todoText = &apos;&apos;;    };    $scope.remaining = function() {        var count = 0;        angular.forEach($scope.todos, function(todo) {            count += todo.done ? 0 : 1;        });        return count;    };    $scope.archive = function() {        var oldTodos = $scope.todos;        $scope.todos = [];        angular.forEach(oldTodos, function(todo) {            if (!todo.done)                $scope.todos.push(todo);        });    };}</code></pre><p>本例中为$scope添加了todos这个数组，addTodo，remaining和archive三个方法，然后，可以在视图中对他们进行绑定。</p><p>##3. 视图<br>在这些主流的MV*框架中，一般都提供了定义视图的功能。在Backbone中，是这样定义视图的：</p><pre><code>// The DOM element for a todo item...var TodoView = Backbone.View.extend({    //... is a list tag.    tagName : &quot;li&quot;,    // Cache the template function for a single item.    template : _.template($(&apos;#item-template&apos;).html()),    // The DOM events specific to an item.    events : {        &quot;click .toggle&quot; : &quot;toggleDone&quot;,        &quot;dblclick .view&quot; : &quot;edit&quot;,        &quot;click a.destroy&quot; : &quot;clear&quot;,        &quot;keypress .edit&quot; : &quot;updateOnEnter&quot;,        &quot;blur .edit&quot; : &quot;close&quot;    },    // The TodoView listens for changes to its model, re-rendering. Since there&apos;s    // a one-to-one correspondence between a **Todo** and a **TodoView** in this    // app, we set a direct reference on the model for convenience.    initialize : function() {        this.listenTo(this.model, &apos;change&apos;, this.render);        this.listenTo(this.model, &apos;destroy&apos;, this.remove);    },    // Re-render the titles of the todo item.    render : function() {        this.$el.html(this.template(this.model.toJSON()));        this.$el.toggleClass(&apos;done&apos;, this.model.get(&apos;done&apos;));        this.input = this.$(&apos;.edit&apos;);        return this;    },    //......    // Remove the item, destroy the model.    clear : function() {        this.model.destroy();    }});</code></pre><p>上面这个例子是一个典型的“部件”视图，它对于界面上的已有元素没有依赖。也有那么一些视图，需要依赖于界面上的已有元素，比如下面这个，它通过el属性，指定了HTML中id为todoapp的元素，并且还在initialize方法中引用了另外一些元素，通常，需要直接放置到界面的顶层试图会采用这种方式，而“部件”视图一般由主视图来创建、布局。</p><pre><code>// Our overall **AppView** is the top-level piece of UI.var AppView = Backbone.View.extend({    // Instead of generating a new element, bind to the existing skeleton of    // the App already present in the HTML.    el : $(&quot;#todoapp&quot;),    // Our template for the line of statistics at the bottom of the app.    statsTemplate : _.template($(&apos;#stats-template&apos;).html()),    // Delegated events for creating new items, and clearing completed ones.    events : {        &quot;keypress #new-todo&quot; : &quot;createOnEnter&quot;,        &quot;click #clear-completed&quot; : &quot;clearCompleted&quot;,        &quot;click #toggle-all&quot; : &quot;toggleAllComplete&quot;    },    // At initialization we bind to the relevant events on the `Todos`    // collection, when items are added or changed. Kick things off by    // loading any preexisting todos that might be saved in *localStorage*.    initialize : function() {        this.input = this.$(&quot;#new-todo&quot;);        this.allCheckbox = this.$(&quot;#toggle-all&quot;)[0];        this.listenTo(Todos, &apos;add&apos;, this.addOne);        this.listenTo(Todos, &apos;reset&apos;, this.addAll);        this.listenTo(Todos, &apos;all&apos;, this.render);        this.footer = this.$(&apos;footer&apos;);        this.main = $(&apos;#main&apos;);        Todos.fetch();    },    // Re-rendering the App just means refreshing the statistics -- the rest    // of the app doesn&apos;t change.    render : function() {        var done = Todos.done().length;        var remaining = Todos.remaining().length;        if (Todos.length) {            this.main.show();            this.footer.show();            this.footer.html(this.statsTemplate({                done : done,                remaining : remaining            }));        } else {            this.main.hide();            this.footer.hide();        }        this.allCheckbox.checked = !remaining;    },    //......});</code></pre><p>对于AngularJS来说，基本不需要有额外的视图定义，它采用的是直接定义在HTML上的方式，比如：</p><pre><code>&lt;div ng-controller=&quot;TodoCtrl&quot;&gt;    &lt;span&gt;{{remaining()}} of {{todos.length}} remaining&lt;/span&gt;    &lt;a href=&quot;&quot; ng-click=&quot;archive()&quot;&gt;archive&lt;/a&gt;    &lt;ul class=&quot;unstyled&quot;&gt;        &lt;li ng-repeat=&quot;todo in todos&quot;&gt;            &lt;input type=&quot;checkbox&quot; ng-model=&quot;todo.done&quot;&gt;            &lt;span class=&quot;done-{{todo.done}}&quot;&gt;{{todo.text}}&lt;/span&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;form ng-submit=&quot;addTodo()&quot;&gt;        &lt;input type=&quot;text&quot; ng-model=&quot;todoText&quot;  size=&quot;30&quot;        placeholder=&quot;add new todo here&quot;&gt;        &lt;input class=&quot;btn-primary&quot; type=&quot;submit&quot; value=&quot;add&quot;&gt;    &lt;/form&gt;&lt;/div&gt;</code></pre><p>在这个例子中，使用ng-controller注入了一个TodoCtrl的实例，然后，在TodoCtrl的$scope中附加的那些变量和方法都可以直接访问了。注意到其中的ng-repeat部分，它遍历了todos数组，然后使用其中的单个todo对象创建了一些HTML元素，把相应的值填到里面。这种做法和ng-model一样，都创造了双向绑定，即：</p><ul><li>改变模型可以随时反映到界面上</li><li>在界面上做的操作（输入，选择等等）可以实时反映到模型里。</li></ul><p>而且，这种绑定都会自动忽略其中可能因为空数据而引起的异常情况。</p><p>##4. 模板</p><p>模板是这个时期一种很典型的解决方案。我们常常有这样的场景：在一个界面上重复展示类似的DOM片段，例如微博。以传统的开发方式，也可以轻松实现出来，比如：</p><pre><code>var feedsDiv = $(&quot;#feedsDiv&quot;);for (var i = 0; i &lt; 5; i++) {    var feedDiv = $(&quot;&lt;div class=&apos;post&apos;&gt;&lt;/div&gt;&quot;);    var authorDiv = $(&quot;&lt;div class=&apos;author&apos;&gt;&lt;/div&gt;&quot;);    var authorLink = $(&quot;&lt;a&gt;&lt;/a&gt;&quot;)        .attr(&quot;href&quot;, &quot;/user.html?user=&apos;&quot; + &quot;Test&quot; + &quot;&apos;&quot;)        .html(&quot;@&quot; + &quot;Test&quot;)        .appendTo(authorDiv);    authorDiv.appendTo(feedDiv);    var contentDiv = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;)        .html(&quot;Hello, world!&quot;)        .appendTo(feedDiv);    var dateDiv = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;)        .html(&quot;发布日期：&quot; + new Date().toString())        .appendTo(feedDiv);    feedDiv.appendTo(feedsDiv);}</code></pre><p>但是使用模板技术，这一切可以更加优雅，以常用的模板框架UnderScore为例，实现这段功能的代码为：</p><pre><code>var templateStr = &apos;&lt;div class=&quot;post&quot;&gt;&apos;    +&apos;&lt;div class=&quot;author&quot;&gt;&apos;    +    &apos;&lt;a href=&quot;/user.html?user={{creatorName}}&quot;&gt;@{{creatorName}}&lt;/a&gt;&apos;    +&apos;&lt;/div&gt;&apos;    +&apos;&lt;div&gt;{{content}}&lt;/div&gt;&apos;    +&apos;&lt;div&gt;{{postedDate}}&lt;/div&gt;&apos;    +&apos;&lt;/div&gt;&apos;;var template = _.template(templateStr);template({    createName : &quot;Xufei&quot;,    content: &quot;Hello, world&quot;,    postedDate: new Date().toString()});</code></pre><p>也可以这么定义：</p><pre><code>&lt;script type=&quot;text/template&quot; id=&quot;feedTemplate&quot;&gt;&lt;% _.each(feeds, function (item) { %&gt;    &lt;div class=&quot;post&quot;&gt;        &lt;div class=&quot;author&quot;&gt;            &lt;a href=&quot;/user.html?user=&lt;%= item.creatorName %&gt;&quot;&gt;@&lt;%= item.creatorName %&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div&gt;&lt;%= item.content %&gt;&lt;/div&gt;        &lt;div&gt;&lt;%= item.postedData %&gt;&lt;/div&gt;    &lt;/div&gt;&lt;% }); %&gt;&lt;/script&gt;&lt;script&gt;$(&apos;#feedsDiv&apos;).html( _.template($(&apos;#feedTemplate&apos;).html(), feeds));&lt;/script&gt;</code></pre><p>除此之外，UnderScore还提供了一些很方便的集合操作，使得模板的使用更加方便。如果你打算使用BackBone框架，并且需要用到模板功能，那么UnderScore是一个很好的选择，当然，也可以选用其它的模板库，比如Mustache等等。</p><p>如果使用AngularJS，可以不需要额外的模板库，它自身就提供了类似的功能，比如上面这个例子可以改写成这样：</p><pre><code>&lt;div class=&quot;post&quot; ng-repeat=&quot;post in feeds&quot;&gt;    &lt;div class=&quot;author&quot;&gt;        &lt;a ng-href=&quot;/user.html?user={{post.creatorName}}&quot;&gt;@{{post.creatorName}}&lt;/a&gt;    &lt;/div&gt;    &lt;div&gt;{{post.content}}&lt;/div&gt;    &lt;div&gt;        发布日期：{{post.postedTime | date:'medium'}}    &lt;/div&gt;&lt;/div&gt;</code></pre><p>主流的模板技术都提供了一些特定的语法，有些功能很强。值得注意的是，他们虽然与JSP之类的代码写法类似甚至相同，但原理差别很大，这些模板框架都是在浏览器端执行的，不依赖任何服务端技术，即使界面文件是.html也可以，而传统比如JSP模板是需要后端支持的，执行时间是在服务端。</p><p>##5. 路由</p><p>通常路由是定义在后端的，但是在这类MV*框架的帮助下，路由可以由前端来解析执行。比如下面这个Backbone的路由示例：</p><pre><code>var Workspace = Backbone.Router.extend({    routes: {        &quot;help&quot;:                 &quot;help&quot;,    // #help        &quot;search/:query&quot;:        &quot;search&quot;,  // #search/kiwis        &quot;search/:query/p:page&quot;: &quot;search&quot;   // #search/kiwis/p7    },    help: function() {        ...    },    search: function(query, page) {        ...    }    });</code></pre><p>在上述例子中，定义了一些路由的映射关系，那么，在实际访问的时候，如果在地址栏输入”#search/obama/p2”，就会匹配到”search/:query/p:page”这条路由，然后，把”obama”和”2”当作参数，传递给search方法。</p><p>AngularJS中定义路由的方式有些区别，它使用一个$routeProvider来提供路由的存取，每一个when表达式配置一条路由信息，otherwise配置默认路由，在配置路由的时候，可以指定一个额外的控制器，用于控制这条路由对应的html界面：</p><pre><code>app.config([&apos;$routeProvider&apos;,function($routeProvider) {    $routeProvider.when(&apos;/phones&apos;, {        templateUrl : &apos;partials/phone-list.html&apos;,        controller : PhoneListCtrl    }).when(&apos;/phones/:phoneId&apos;, {        templateUrl : &apos;partials/phone-detail.html&apos;,        controller : PhoneDetailCtrl    }).otherwise({        redirectTo : &apos;/phones&apos;    });}]); </code></pre><p>注意，在AngularJS中，路由的template并非一个完整的html文件，而是其中的一段，文件的头尾都可以不要，也可以不要那些包含的外部样式和JavaScript文件，这些在主界面中载入就可以了。</p><p>##6. 自定义标签</p><p>用过XAML或者MXML的人一定会对其中的可扩充标签印象深刻，对于前端开发人员而言，基于标签的组件定义方式一定是优于其他任何方式的，看下面这段HTML：</p><pre><code>&lt;div&gt;    &lt;input type=&quot;text&quot; value=&quot;hello, world&quot;/&gt;    &lt;button&gt;test&lt;/button&gt;&lt;/div&gt;</code></pre><p>即使是刚刚接触这种东西的新手，也能够理解它的意思，并且能够照着做出类似的东西，如果使用传统的面向对象语言去描述界面，效率远远没有这么高，这就是在界面开发领域，声明式编程比命令式编程适合的最重要原因。</p><p>但是，HTML的标签是有限的，如果我们需要的功能不在其中，怎么办？在开发过程中，我们可能需要一个选项卡的功能，但是，HTML里面不提供选项卡标签，所以，一般来说，会使用一些li元素和div的组合，加上一些css，来实现选项卡的效果，也有的框架使用JavaScript来完成这些功能。总的来说，这些代码都不够简洁直观。</p><p>如果能够有一种技术，能够提供类似这样的方式，该多么好呢？</p><pre><code>&lt;tabs&gt;    &lt;tab name=&quot;Tab 1&quot;&gt;content 1&lt;/tab&gt;    &lt;tab name=&quot;Tab 2&quot;&gt;content 2&lt;/tab&gt;&lt;/tabs&gt;</code></pre><p>回忆一下，我们在章节1.4 组件化的萌芽 里面，提到过一种叫做HTC的技术，这种技术提供了类似的功能，而且使用起来也比较简便，问题是，它属于一种正在消亡的技术，于是我们的目光投向了更为现代的前端世界，AngularJS拯救了我们。</p><p>在AngularJS的首页，可以看到这么一个区块“Create Components”，在它的演示代码里，能够看到类似的一段：</p><pre><code>&lt;tabs&gt;    &lt;pane title=&quot;Localization&quot;&gt;        ...    &lt;/pane&gt;    &lt;pane title=&quot;Pluralization&quot;&gt;        ...    &lt;/pane&gt;&lt;/tabs&gt;</code></pre><p>那么，它是怎么做到的呢？秘密在这里：</p><pre><code>angular.module(&apos;components&apos;, []).directive(&apos;tabs&apos;, function() {    return {        restrict : &apos;E&apos;,        transclude : true,        scope : {},        controller : function($scope, $element) {            var panes = $scope.panes = [];            $scope.select = function(pane) {                angular.forEach(panes, function(pane) {                    pane.selected = false;                });                pane.selected = true;            }            this.addPane = function(pane) {                if (panes.length == 0)                    $scope.select(pane);                panes.push(pane);            }        },        template : &apos;&lt;div class=&quot;tabbable&quot;&gt;&apos;            + &apos;&lt;ul class=&quot;nav nav-tabs&quot;&gt;&apos;             + &apos;&lt;li ng-repeat=&quot;pane in panes&quot; ng-class=&quot;{active:pane.selected}&quot;&gt;&apos;             + &apos;&lt;a href=&quot;&quot; ng-click=&quot;select(pane)&quot;&gt;{{pane.title}}&lt;/a&gt;&apos;             + &apos;&lt;/li&gt;&apos;             + &apos;&lt;/ul&gt;&apos;             + &apos;&lt;div class=&quot;tab-content&quot; ng-transclude&gt;&lt;/div&gt;&apos;             + &apos;&lt;/div&gt;&apos;,        replace : true    };}).directive(&apos;pane&apos;, function() {    return {        require : &apos;^tabs&apos;,        restrict : &apos;E&apos;,        transclude : true,        scope : {            title : &apos;@&apos;        },        link : function(scope, element, attrs, tabsCtrl) {            tabsCtrl.addPane(scope);        },        template : &apos;&lt;div class=&quot;tab-pane&quot; ng-class=&quot;{active: selected}&quot; ng-transclude&gt;&apos; + &apos;&lt;/div&gt;&apos;,        replace : true    };})</code></pre><p>这段代码里，定义了tabs和pane两个标签，并且限定了pane标签不能脱离tabs而单独存在，tabs的controller定义了它的行为，两者的template定义了实际生成的html，通过这种方式，开发者可以扩展出自己需要的新元素，对于使用者而言，这不会增加任何额外的负担。</p><p>#四. 一些想说的话</p><p>###关于ExtJS</p><p>注意到在本文中，并未提及这样一个比较流行的前端框架，主要是因为他自成一系，思路跟其他框架不同，所做的事情，层次介于文中的二和三之间，所以没有单独列出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端开发技术的发展&quot;&gt;&lt;a href=&quot;#前端开发技术的发展&quot; class=&quot;headerlink&quot; title=&quot;前端开发技术的发展&quot;&gt;&lt;/a&gt;前端开发技术的发展&lt;/h1&gt;&lt;p&gt;前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。&lt;/li&gt;
&lt;li&gt;VML和SVG等基于XML的描述图形的语言。&lt;/li&gt;
&lt;li&gt;从属于XML体系的XML，XPath，DTD等技术。&lt;/li&gt;
&lt;li&gt;用于支撑后端的ASP，JSP，ASP.net，PHP，nodejs等语言或者技术。&lt;/li&gt;
&lt;li&gt;被第三方程序打包的一种类似浏览器的宿主环境，比如Adobe AIR和使用HyBird方式的一些开发技术，如PhoneGap（它使用Android中的WebView等技术，让开发人员使用传统Web开发技术来开发本地应用）&lt;/li&gt;
&lt;li&gt;Adobe Flash，Flex，Microsoft Silverlight，Java Applet，JavaFx等RIA开发技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文从狭义的前端定义出发，探讨一下这方面开发技术的发展过程。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2013-07-10-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2013-07-10-从零开始编写自己的JavaScript框架（二）/</id>
    <published>2019-04-14T09:10:49.489Z</published>
    <updated>2019-04-14T09:10:49.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始编写自己的JavaScript框架（二）"><a href="#从零开始编写自己的JavaScript框架（二）" class="headerlink" title="从零开始编写自己的JavaScript框架（二）"></a>从零开始编写自己的JavaScript框架（二）</h1><p>#2. 数据绑定</p><p>##2.1 数据绑定的原理</p><p>数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。</p><p>在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。</p><p>先看数据到界面上的的绑定，比如：</p><pre><code>&lt;input vm-value=&quot;name&quot;/&gt;var person = {    name: &quot;Tom&quot;};</code></pre><p>如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？<br><a id="more"></a><br>从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如：</p><pre><code>var person = {    name: &quot;Tom&quot;,    setName: function(newName) {        this.name = newName;        //do something    }};</code></pre><p>这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做：</p><pre><code>var person = {    name: &quot;Tom&quot;,    gender: 5    set: function(key, value) {        this[key] = value;        //do something    }};</code></pre><p>或者合并两个方法，只判断是否传了参数：</p><pre><code>Person.prototype.name = function(value) {    if (arguments.length == 0) {        return this._name;    }    else {        this._name = value;    }}</code></pre><p>这种情况下，赋值的时候就是person.name(“Tom”)，取值的时候就是var name = person.name()了。</p><p>有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。</p><p>在C#等一些语言里，有一种东西叫做存取器，比如说：</p><pre><code>class Person{    private string name;    public string Name    {        get        {            return name;        }        set        {            name = value;        }    }}</code></pre><p>用的时候，person.Name = “Jerry”，就会调用到set里，相当于是个方法。</p><p>这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说：</p><pre><code>var person = {};// Add an accessor property to the object.Object.defineProperty(person, &quot;name&quot;, {    set: function (value) {        this._name = value;        //do something    },    get: function () {        return this._name;    },    enumerable: true,    configurable: true});</code></pre><p>赋值的时候，person.name = “Tom”，取值的时候，var name = person.name，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。</p><p>现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。</p><p>再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。</p><p>##2.2 数据绑定的实现</p><p>我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。</p><pre><code>function parseElement(element) {    for (var i=0; i&lt;element.attributes.length; i++) {        parseAttribute(element.attributes[i]);    }    for (var i=0; i&lt;element.children.length; i++) {        parseElement(element.children[i]);    }}</code></pre><p>但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？</p><p>我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。</p><p>因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。</p><pre><code>thin.define(&quot;Person&quot;, [], function() {    function Person() {        this.name = &quot;Tom&quot;;        this.age = 5;    }    Person.prototype = {        growUp: function() {            this.age++;        }    };    return Person;});</code></pre><p>模型方面都准备好了，现在来看界面：</p><pre><code>&lt;div vm-model=&quot;Person&quot;&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;&lt;/div&gt;</code></pre><p>为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。</p><p>好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？</p><p>当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样：</p><pre><code>function parseElement(element, vm) {    var model = vm;    if (element.getAttribute(&quot;vm-model&quot;)) {        model = bindModel(element.getAttribute(&quot;vm-model&quot;));    }    for (var i=0; i&lt;element.attributes.length; i++) {        parseAttribute(element, element.attributes[i], model);    }    for (var i=0; i&lt;element.children.length; i++) {        parseElement(element.children[i], model);    }}</code></pre><p>看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。</p><pre><code>function bindModel(modelName) {    thin.log(&quot;model&quot; + modelName);    var model = thin.use(modelName, true);    var instance = new model();    return instance;}</code></pre><p>现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的：</p><ul><li>init，用于绑定初始化方法</li><li>click，用于绑定点击</li><li>value，绑定变量</li><li>enable和disable，绑定可用状态</li><li>visible和invisible，绑定可见状态</li></ul><p>然后就可以实现我们parseAttribute函数了：</p><pre><code>function parseAttribute(element, attr, model) {    if (attr.name.indexOf(&quot;vm-&quot;) == 0) {        var type = attr.name.slice(3);        switch (type) {            case &quot;init&quot;:                bindInit(element, attr.value, model);                break;            case &quot;value&quot;:                bindValue(element, attr.value, model);                break;            case &quot;click&quot;:                bindClick(element, attr.value, model);                break;            case &quot;enable&quot;:                bindEnable(element, attr.value, model, true);                break;            case &quot;disable&quot;:                bindEnable(element, attr.value, model, false);                break;            case &quot;visible&quot;:                bindVisible(element, attr.value, model, true);                break;            case &quot;invisible&quot;:                bindVisible(element, attr.value, model, false);                break;            case &quot;element&quot;:                model[attr.value] = element;                break;        }    }}</code></pre><p>注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。</p><p>这么多绑定，不打算都讲，用bindValue函数来说明一下吧：</p><pre><code>function bindValue(element, key, vm) {    thin.log(&quot;binding value: &quot; + key);    vm.$watch(key, function (value, oldValue) {        element.value = value || &quot;&quot;;    });    element.onkeyup = function () {        vm[key] = element.value;    };    element.onpaste = function () {        vm[key] = element.value;    };}</code></pre><p>我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。</p><p>在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。</p><p>接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。</p><p>然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。</p><pre><code>var Binder = {    $watch: function (key, watcher) {        if (!this.$watchers[key]) {            this.$watchers[key] = {                value: this[key],                list: []            };            Object.defineProperty(this, key, {                set: function (val) {                    var oldValue = this.$watchers[key].value;                    this.$watchers[key].value = val;                    for (var i = 0; i &lt; this.$watchers[key].list.length; i++) {                        this.$watchers[key].list[i](val, oldValue);                    }                },                get: function () {                    return this.$watchers[key].value;                }            });        }        this.$watchers[key].list.push(watcher);    }};</code></pre><p>但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。</p><pre><code>function bindModel(name) {    thin.log(&quot;binding model: &quot; + name);    var model = thin.use(name, true);    var instance = new model().extend(Binder);    instance.$watchers = {};    return instance;}</code></pre><p>看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？</p><p>先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。</p><p>同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。</p><p>嗯，我们是不是可以试一下了？来写个代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Simple binding demo&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;binding&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;xu.fei@outlook.com&quot;&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/thin.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div vm-model=&quot;test.Person&quot;&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;&lt;/div&gt;&lt;div vm-model=&quot;test.Person&quot; vm-init=&quot;init&quot;&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    thin.define(&quot;test.Person&quot;, [], function () {        function Person() {            this.name = &quot;Tom&quot;;            this.age = 5;        }        Person.prototype = {            init: function () {                this.name = &quot;Jerry&quot;;                this.age = 3;            },            growUp: function () {                this.age++;            }        };        return Person;    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>或者访问这里：<a href="http://xufei.github.io/thin/demo/simple-binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/simple-binding.html</a></p><p>以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。</p><p>我们还有一个更实际一点的例子，结合了另外一个系列里面写的简单DataGrid控件，做了一个很基础的人员管理界面：<a href="http://xufei.github.io/thin/demo/binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/binding.html</a></p><p>##2.3 小结</p><p>到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始编写自己的JavaScript框架（二）&quot;&gt;&lt;a href=&quot;#从零开始编写自己的JavaScript框架（二）&quot; class=&quot;headerlink&quot; title=&quot;从零开始编写自己的JavaScript框架（二）&quot;&gt;&lt;/a&gt;从零开始编写自己的JavaScript框架（二）&lt;/h1&gt;&lt;p&gt;#2. 数据绑定&lt;/p&gt;
&lt;p&gt;##2.1 数据绑定的原理&lt;/p&gt;
&lt;p&gt;数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。&lt;/p&gt;
&lt;p&gt;在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。&lt;/p&gt;
&lt;p&gt;先看数据到界面上的的绑定，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input vm-value=&amp;quot;name&amp;quot;/&amp;gt;
var person = {
    name: &amp;quot;Tom&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/14/%E6%9D%82%E8%B0%88/2013-10-01-%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%B0%E5%A2%83/"/>
    <id>https://qccs.github.io/2019/04/14/杂谈/2013-10-01-企业软件领域前端开发的困境/</id>
    <published>2019-04-14T09:10:49.480Z</published>
    <updated>2019-04-14T09:10:49.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="企业软件领域前端开发的困境"><a href="#企业软件领域前端开发的困境" class="headerlink" title="企业软件领域前端开发的困境"></a>企业软件领域前端开发的困境</h1><p>这个问题问得很有意思，在每个行业里，前端开发的侧重点是不一样的，重要性也有所不同，简单来说可以分为3个大类：互联网、企业应用、游戏，分别侧重于：交互、架构、算法。</p><p>在这三个大类里，互联网方向的前端开发最为正统，算是根正苗红，所以在这个领域的人，对标准研究得最为透彻，对交互理解得最为深刻，目前前端方向的高手大多集中在这个领域。这个领域的人最关注的问题是兼容性，对一些细节的优化把握得炉火纯青。因为这个领域的业务特点，前端做的事情过于扁平，整个可发挥的余地不够，虽然高手众多，但就像很多龙挤在浅水里，常常有无用武之地的感叹。刚才玉伯这篇文章，讲述的就是这个领域中前端的困惑。</p><p>企业应用方向的前端开发其实很多时候并不在意他们用的是Web还是其他类似技术，比如Flex，Silverlight等，对他们来说，即使是C/S的系统，也能够发挥出很大价值。这个领域的人最关注的问题是组件化和快速业务开发。<br><a id="more"></a><br>从企业软件的方向来说，它的业务是很丰富的，对各种前端技术的应用也都很广泛，一个大型的企业应用，几乎什么特性都能用上。相对于互联网系统，它的客户相对比较专业，可以排除一些低端过时的浏览器，所以少了很多兼容的负担，在框架选型上，也可以接受很复杂的框架，比如ExtJS、AngularJS等，因为他们的业务特性，往往需要很复杂框架的支持。</p><p>用我所在的电信行业软件举例，业务复杂度非常高，一套全业务系统会有两千左右的数据库表，两千个左右的业务菜单，其中有些业务界面的复杂度非常惊人，而且经常会根据需求有较大变动，性能也有较高要求。</p><p>理论上来说，前端在这个领域可以领悟到很多事情，但这个领域有个最大的问题，盈利太低，不足以支撑很深入的研究，另一个无奈的问题是，由于历史原因，前端开发人员在这个领域并不容易受到重视，比如说资深技术人员多数是做后端开发的，认为前端很小儿科，在应届生入职筛选的时候，也会把能力较高的弄去做后端开发，剩下的留给前端。这些原因，造成了企业应用的前端领域就像一个又大又深的湖，里面小鱼小虾众多，却很少有大鱼。</p><p>我在企业软件前端开发做了很多年，经常思考其中的一些问题，在这个领域做，总是有一种寂寞的感觉。我们这种行业，为了保证交付的及时，倾向于划分业务开发和技术平台开发，业务开发人员并不在难解决的问题上花时间，遇到问题的时候向技术平台团队寻求支持，把问题转移给更专业的人，避免耽误自己的交付时间，在他们开工之前，也由技术平台团队预先搭建框架，他们直接在这个上面以固定的模式进行开发。两个团队，前者的特点是多而泛，后者的特点是少而精。</p><p>这么做，效率比较高，但带来一个问题，业务开发团队的技术水平很难提升，因为他总是忙碌赶工，很少有时间去思考很多问题的前因后果，即使你帮他解决了问题，告诉他，他也不一定有心情去关注一遍，因为他确实很忙。可能有些有激情的人会自己花点时间研究一下，但多数人很难有这样的心境。</p><p>这就造成了业务开发团队和平台开发团队的技术实力严重脱节。从另外一个角度看，技术平台团队长期专门给别人解决问题，自己却很少全职参与某个业务项目的开发，他也很难有成就感。这还不是最大的问题，最大问题是，不管从哪个团队，都很难成长出能够设计最适合这些业务的前端架构的人，这恰恰是这个领域前端开发最重要的部分。</p><p>当出现各种新技术的时候，平台团队比较容易去快速跟进，但投入通常不会很大，当取得一些进展的时候，会逐步向业务开发团队推广，但这个推广的难度是很大的，因为人数的比例会比较大，当技术从一个人向三个人推进的时候，是相对还算容易的，如果从一个向十个或者二十个人去推进，难度就大多了。而由于传统企业盈利规模的限制，没办法在每个技术方向都有较大投入，所以往往就是一两个人去折腾，他们在探索的过程中遇到问题，是很难找到能够交流的人的，如果自己解决不了问题，就会持续苦闷，非常寂寞。前端这个领域更是如此，现在客户端技术这么多，各种终端，各种浏览器，各种前端框架，每个上面投入一个人，就已经是个很大团队了，这种模式很明显就碰到瓶颈了，因为它很直接地跟人员编制产生了冲突。扩编直接对利润产生冲击，但是不扩编的话，技术平台团队的压力就会进一步加大，除了要探索新技术，还要对越来越庞大的业务开发团队作技术支持，每个人都痛不欲生。</p><p>这种困境怎么解决呢，我想了很久，无计可施，也许，是时候要效仿互联网企业的开发模式了？但是积重难返，而且传统企业招聘的门槛远比互联网企业低，人员的能力有差距，也很难有互联网企业那么蓬勃而广泛的技术研究气氛，可能就更难做下去了。 </p><p>可能这个领域的出路是寻找更为简单快速的开发方式，并且把相关的外围工具也做大做强，在业务领域中，把组件也积累沉淀出来，这时候能够用更少的业务开发人员来实现同等规模的系统，把更多人力节约出来做技术探索和改进吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;企业软件领域前端开发的困境&quot;&gt;&lt;a href=&quot;#企业软件领域前端开发的困境&quot; class=&quot;headerlink&quot; title=&quot;企业软件领域前端开发的困境&quot;&gt;&lt;/a&gt;企业软件领域前端开发的困境&lt;/h1&gt;&lt;p&gt;这个问题问得很有意思，在每个行业里，前端开发的侧重点是不一样的，重要性也有所不同，简单来说可以分为3个大类：互联网、企业应用、游戏，分别侧重于：交互、架构、算法。&lt;/p&gt;
&lt;p&gt;在这三个大类里，互联网方向的前端开发最为正统，算是根正苗红，所以在这个领域的人，对标准研究得最为透彻，对交互理解得最为深刻，目前前端方向的高手大多集中在这个领域。这个领域的人最关注的问题是兼容性，对一些细节的优化把握得炉火纯青。因为这个领域的业务特点，前端做的事情过于扁平，整个可发挥的余地不够，虽然高手众多，但就像很多龙挤在浅水里，常常有无用武之地的感叹。刚才玉伯这篇文章，讲述的就是这个领域中前端的困惑。&lt;/p&gt;
&lt;p&gt;企业应用方向的前端开发其实很多时候并不在意他们用的是Web还是其他类似技术，比如Flex，Silverlight等，对他们来说，即使是C/S的系统，也能够发挥出很大价值。这个领域的人最关注的问题是组件化和快速业务开发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
