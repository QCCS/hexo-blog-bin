<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qianchaochushui</title>
  
  <subtitle>subtitle</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qccs.github.io/"/>
  <updated>2019-04-13T07:32:25.000Z</updated>
  <id>https://qccs.github.io/</id>
  
  <author>
    <name>zhouli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 如何 clone 非 master 分支的代码</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-07-07-git-clone-not-master-branch/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-07-07-git-clone-not-master-branch/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们每次使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@gitlab.xxx.com:xxxxx.git</span><br></pre></td></tr></table></figure><p>默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，该如何拿到呢？如下图所示，最新的代码可能在<code>daily/1.4.1</code>分支上，我们希望拿到这个分支上的代码。</p><p><img src="https://ooo.0o0.ooo/2016/07/07/577e349ab42ed.png" alt="7f07c8f6deef169ef6be5103bbd3e932f8676bb1.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>刚刚开周会的时候，自己洋洋得意的分享我的解决方案，但是……经过与团队成员的的讨论，自己的方法弱爆了，现在把更优雅的方法写一下。原来写的方法并不太适合用在这个场景里。</strong> 我之前写的方法在文章后面。</p><p>直接使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r #查看远程分支</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a #查看所有分支</span><br></pre></td></tr></table></figure><p>会显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">origin/HEAD -&gt; origin/master</span><br><span class="line">origin/daily/1.2.2</span><br><span class="line">origin/daily/1.3.0</span><br><span class="line">origin/daily/1.4.1</span><br><span class="line">origin/develop</span><br><span class="line">origin/feature/daily-1.0.0</span><br><span class="line">origin/master</span><br></pre></td></tr></table></figure><p>然后直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/daily/1.4.1</span><br></pre></td></tr></table></figure><p>就好了。。。</p><h2 id="原来的解决方案"><a href="#原来的解决方案" class="headerlink" title="原来的解决方案"></a>原来的解决方案</h2><p><strong>其实我原来写的这个方法更多的是：设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支。</strong></p><p>我们在本地先建立一个分支，建议名称和远程的想要同步的分支名称一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch daily/1.4.1</span><br></pre></td></tr></table></figure><p>在切换到这个本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout daily/1.4.1</span><br><span class="line"># Switched to branch &apos;daily/1.4.1&apos;</span><br></pre></td></tr></table></figure><p>接下来就可以去建立上游分支的关联了，但是这个命令比较长，不好记，我们可以直接先<code>pull</code>一下，git 会提示我们相应的操作和命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; daily/1.4.1</span><br></pre></td></tr></table></figure><p>我们看到最后一行，执行这个命令，即可完成与上游分支的关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/daily/1.4.1 daily/1.4.1</span><br><span class="line"># Branch daily/1.4.1 set up to track remote branch daily/1.4.1 from origin.</span><br></pre></td></tr></table></figure><p>然后再<code>pull</code>一下就好了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;我们每次使用命令&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
      <category term="GitHub" scheme="https://qccs.github.io/categories/GitHub/"/>
    
    
      <category term="Git GitHub 分支" scheme="https://qccs.github.io/tags/Git-GitHub-%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>提升用户体验的前端动画</title>
    <link href="https://qccs.github.io/2019/04/13/z/2018-06-01-animation/"/>
    <id>https://qccs.github.io/2019/04/13/z/2018-06-01-animation/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>与其他开发人员不同的是，前端开发都是在端上游走舞者，直接与用户交流沟通，这就需要前端开发具有更敏锐的交互体验思考，或者能更精准地理解设计师们意图，将最佳的用户体验带给用户。优质的交互体验对于用户来说学习成本应该是极低的，都是非常自然的操作，却可以让用户感到畅快愉悦，甚至惊喜。本文将通过一个看似简单的 poplayer 来分析我在这其中通过思考做的体验优化，获得类似 native 的体验感。</p><p><img src="https://ws1.sinaimg.cn/large/7011d6cfgy1frx9jv0kpfj208w0fracu.jpg" alt></p><blockquote><p>关于 poplayer 是什么，详见 <a href="https://github.com/amfe/article/issues/18" target="_blank" rel="noopener">POPLAYER起来HIGH~~</a></p></blockquote><p>简单的说下需求，这个弹层希望可以像 native 在商品详情页的弹层一样，从下向上滑出，点击遮罩或按钮时关闭。为了给用户带来更好的体验，我在这个基础上又增加了一些手势和过渡的动画效果，如下图。下面简单的拆分一下动画细节：</p><ul><li>页面载入，卡片向上滑入</li><li>增加 pan 的手势，卡片跟随手指滑动</li><li>随着手指滑动，增加遮罩透明度与卡片阴影变化</li><li>增加向上和向下的边界条件的处理</li></ul><h2 id="动画与手势的运用"><a href="#动画与手势的运用" class="headerlink" title="动画与手势的运用"></a>动画与手势的运用</h2><p>这些动画利用 CSS 3 的一些属性再加上手势操作即可完成，这里手势操作我选择了老牌的 <a href="https://hammerjs.github.io/" target="_blank" rel="noopener">HammerJS</a>。</p><p>点击超级会员专享，折上95折 banner，卡片向上滑入</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072164318.mp4" autoplay controls preload loop muted width="300px"></video><p>这里直接使用 <code>transition</code> 控制过渡。发生样式变化的有 3 个地方：</p><ul><li>卡片位置，使用 <code>transform: translateY</code> 控制纵向位置</li><li>遮罩透明度，随着卡片上滑，背景遮罩由透明变为半透明</li><li>卡片的阴影，注意仔细观察，随着卡片的上滑，为了凸显出弹层是悬浮在底层的视觉效果，其阴影的 <code>blur</code>,<code>spread</code>,<code>color</code> 也跟随变重</li></ul><p>下面再加入 pan 手势，即拖拽或平移，这里我们使用这个手势实现弹层的拖拽和相关动画。手指不离开屏幕进行滑动操作，如下图：</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072178262.mp4" controls preload loop muted width="300px"></video><p>我们把最外层容器节点作为参数，实例化 hammer 对象，默认 pan 手势只有横向操作，这里设置为所有方向。在监听 pandown panup 时，根据手指移动的差值控制卡片位置、背景遮罩透明度、卡片阴影的样式。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hammer = <span class="keyword">new</span> Hammer(containerEl)</span><br><span class="line">hammer.get(<span class="string">'pan'</span>).set(&#123; <span class="attr">direction</span>: Hammer.DIRECTION_ALL &#125;)</span><br><span class="line">hammer.on(<span class="string">'pandown panup'</span>, panDownUp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> panDownUp = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> opacity = <span class="number">0.7</span> - ev.deltaY / <span class="number">1024</span></span><br><span class="line">  coverEle.style.opacity = opacity</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boxShadowBlur = <span class="number">12</span> - ev.deltaY / <span class="number">46</span></span><br><span class="line">  <span class="keyword">const</span> boxShadowSpread = <span class="number">3</span> - ev.deltaY / <span class="number">180</span></span><br><span class="line">  <span class="keyword">const</span> boxShadowColorAlpha = <span class="string">''</span></span><br><span class="line">  popWrapEle.style.boxShadow = <span class="string">`0 0 <span class="subst">$&#123;boxShadowBlur&#125;</span>px <span class="subst">$&#123;boxShadowSpread&#125;</span>px rgba(0,0,0,<span class="subst">$&#123;opacity&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scrollY = ev.deltaY * <span class="number">1.2</span></span><br><span class="line">  popWrapEle.style.transform = <span class="string">`translateY(<span class="subst">$&#123;scrollY&#125;</span>px)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于各个样式属性的值，通过乘系数等方式得到需要的值。</p><p>这里要注意，pan 的操作中是不需要原有的 transition 过渡的，因为滑动操作时，希望让动画非常跟手，而 transition 是一个消耗时间的过渡，而且多次触发 transition 也会导致性能问题，我们要在 panstart 将其移除，panend 再加回来，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hammer.on(<span class="string">'panstart'</span>, () =&gt; &#123;</span><br><span class="line">  popWrapEle.classList.remove(<span class="string">'pop-wrap-transition'</span>)</span><br><span class="line">  coverEle.classList.remove(<span class="string">'cover-transition'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hammer.on(<span class="string">'panend'</span>, (ev) =&gt; &#123;</span><br><span class="line">  popWrapEle.classList.add(<span class="string">'pop-wrap-transition'</span>)</span><br><span class="line">  coverEle.classList.add(<span class="string">'cover-transition'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="向下滑出的处理"><a href="#向下滑出的处理" class="headerlink" title="向下滑出的处理"></a>向下滑出的处理</h2><p>用户在向下滑动松手时的距离，如果大于某个值，让卡片滑出，关闭 poplayer，小于某个值，则回弹到原位。</p><p>这比较符合用户体验、防止误关闭，同时滑出的关闭方式也给了用户一种流畅感。经过本人多次测试，最终选择的下滑临界值为 180。效果如下图：</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072156428.mp4" controls preload loop muted width="300px"></video><p>在 panend 事件中加入这个逻辑判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hammer.on(<span class="string">'panend'</span>, (ev) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev.deltaY &gt; <span class="number">180</span>) &#123;</span><br><span class="line">    closePoplayer()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    popWrapEle.style.transform = <span class="string">'translateY(0)'</span></span><br><span class="line">    popWrapEle.style.boxShadow = <span class="string">'0 0 12px 3px rgba(0,0,0,.74)'</span></span><br><span class="line">    coverEle.style.opacity = <span class="string">'0.7'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="向上滑动的溢出感"><a href="#向上滑动的溢出感" class="headerlink" title="向上滑动的溢出感"></a>向上滑动的溢出感</h2><p>这个卡片本身是无法再向上滑动的，但是如果用户想继续滑呢？为了让这个弹层增添一些活力，我在这个操作中让卡片微微膨胀，增添亲和力，仿佛用户想滑动它，但是它又存在着一股粘滞力无法大距离的移动，甚至满足了用户心中的小小控制欲。</p><p>效果如下：</p><video src="http://cloud.video.taobao.com//play/u/263674894/p/1/e/6/t/1/50072160378.mp4" controls preload loop muted width="300px"></video><p>在向上滑动事件中加入如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> panDownUp = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev.deltaY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ev.deltaY)</span><br><span class="line">    <span class="keyword">const</span> scrollUpY = ev.deltaY / <span class="number">80</span></span><br><span class="line">    <span class="keyword">const</span> scaleX = -ev.deltaY / <span class="number">20000</span> + <span class="number">1</span></span><br><span class="line">    popWrapEle.style.transform = <span class="string">`scale(<span class="subst">$&#123;scaleX&#125;</span>) translateY(<span class="subst">$&#123;scrollUpY&#125;</span>px)`</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他小坑"><a href="#其他小坑" class="headerlink" title="其他小坑"></a>其他小坑</h2><p>webkit 前缀。ios 8 下部分 CSS 3 属性需要添加 <code>-webkit-</code> 前缀。参考<a href="http://www.ayqy.net/blog/flexbox%E5%B8%83%E5%B1%80%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/" target="_blank" rel="noopener">flexbox布局的兼容性</a>。</p><p>覆盖 status bar。iOS 11 起，需要在 meta 标签中添加 <code>viewport-fit=cover</code>，才能使得 webView 覆盖到顶部的 status bar，meta 标签最终可以写为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"viewport-fit=cover,width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>交互体验体现在各个细节之中，没有大而全的规则，但整体方向就是让用户在使用软件的时候感到更加的自然畅快。而动画只是交互体验中的一小部分。</p><p>我认为前端的本质，就是将最优质的用户体验带给用户，我也在为之不断努力，欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与其他开发人员不同的是，前端开发都是在端上游走舞者，直接与用户交流沟通，这就需要前端开发具有更敏锐的交互体验思考，或者能更精准地理解设计师们意图，将最佳的用户体验带给用户。优质的交互体验对于用户来
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="动画 手势" scheme="https://qccs.github.io/tags/%E5%8A%A8%E7%94%BB-%E6%89%8B%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记1-语法、对象、函数</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-06-07-JavaScript-good-parts-note1/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-06-07-JavaScript-good-parts-note1/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。</p><p><img src="https://img3.doubanio.com/lpic/s3651235.jpg" alt></p><p>原书中第一章为精华，做了一些周边介绍，略去。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>这里说一下JavaScript的注释，一种是 <code>/* */</code> 包围的块注释，另一种是 <code>//</code> 开头的行注释。</p><p>因为块注释的字符可能是JavaScript中正则表达式字面量，因此不是很安全，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    var rm_a = /a*/</span>.match(s)</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符由一个字母开头，后面可选择性的加上一个或多个字母、数字或下划线。要避免保留字。</p><p>标识符被用于语句、变量、参数、属性名、运算符和标记。</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>可以存在指数部分，100和1e2完全相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> === <span class="number">1e2</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用<code>isNaN</code>来检测<code>NaN</code>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当年 JavaScript 被创建的时候，Unicode 是16位字符集，因此 JavaScript 字符串是16位的。</p><p>用双引号或单引号包裹。</p><p>重点说一下转义字符<code>\</code></p><p>反斜杠后面可以跟<code>&quot;</code>, <code>&#39;</code>, <code>\</code>, <code>/</code>, <code>b</code> (backspace), <code>f</code> (formfeed), <code>n</code>, <code>r</code> (carriage return), <code>t</code>, <code>u1234</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'A'</span> === <span class="string">'\u0041'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>每个<code>&lt;script&gt;</code>标签的内容被一起抛到一个公共的全局名字空间中。</p><p><code>{...}</code>代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。</p><p>下列值当做假：</p><ul><li><code>false</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>&#39;&#39;</code></li><li><code>0</code></li><li><code>NaN</code></li></ul><p>其他所有值都当做真</p><p><code>for in</code>语句枚举对象的所有属性名（键名），使用<code>object.hasOwnProperty(variable)</code>来确定这个属性名是该对象成员，还是来自原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (myvar <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(myvar)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>运算符优先级</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code> <code>[]</code> <code>()</code></td><td>提取属性与调用函数</td></tr><tr><td><code>delete</code> <code>new</code> <code>typeof</code> <code>+</code> <code>-</code> <code>!</code></td><td>一元运算符</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code></td><td></td></tr><tr><td><code>+</code> <code>-</code></td><td></td></tr><tr><td><code>&gt;=</code> <code>&lt;=</code> <code>&gt;</code> <code>&lt;</code></td><td></td></tr><tr><td><code>===</code> <code>!==</code></td><td></td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td>`</td><td></td><td>`</td><td>逻辑或</td></tr><tr><td><code>?:</code></td><td>三目</td></tr></tbody></table><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>对象字面量是一种可以方便地按指定规格创建新对象的表示法。</p><p>数组字面量是一种可以方便地按指定规格创建新数组的表示法。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数字面量定义了函数值。后续章节详谈。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是属性的容器，每一个属性都拥有名字和值。属性的名字可以是包含空字符串在内的任意字符串。属性的值可以是除<code>undefined</code>值之外的任何值。</p><p>JavaScript 包含一种原型链的特性，允许对象继承另一个对象的属性。正确地使用它能减少对象初始化时消耗的时间和内存。</p><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty_object = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stooge = &#123;</span><br><span class="line">    firstName: <span class="string">'Haoyang'</span>,</span><br><span class="line">    lastName: <span class="string">'Gao'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stooge.firstName); <span class="comment">// Haoyang</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge[<span class="string">'firstName'</span>]); <span class="comment">// Haoyang</span></span><br></pre></td></tr></table></figure><p>不存在的属性返回<code>undefined</code>。</p><p>使用<code>||</code>来填充默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stooge.firstName || <span class="string">'Joe'</span>); <span class="comment">// Haoyang</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge.age || <span class="number">25</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>直接使用赋值语句更新，若不存在这个属性，则作为扩充操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stooge.firstName = <span class="string">'aaa'</span></span><br><span class="line">stooge.nickName = <span class="string">'peip'</span></span><br><span class="line"><span class="built_in">console</span>.log(stooge) <span class="comment">//Object &#123;firstName: "aaa", lastName: "Gao", nickName: "peip"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对象通过引用来传递他们永远不会被复制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = stooge</span><br><span class="line">x.hair = <span class="string">'black'</span></span><br><span class="line">stooge.hair <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每一个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过字面量创建的对象都连接到<code>Object.prototype</code>，它是JavaScript中的标配对象。</p><p>可以使用<code>Object.create()</code>方法创建一个使用原对象作为其原型的新对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherStooge = <span class="built_in">Object</span>.create(stooge)</span><br><span class="line">anotherStooge.firstName <span class="comment">//"aaa"</span></span><br><span class="line">anotherStooge.firstName = <span class="string">'bbb'</span></span><br><span class="line">anotherStooge.firstName <span class="comment">//"bbb"</span></span><br><span class="line">anotherStooge.hair <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure><p>新对象先查找自己的属性，若不存在则会向原型方向查找。</p><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4ieu7focqj207h05caaf.jpg" alt></p><p>当我们对某个对象作出改变时，不会触及该对象的原型。</p><p>原型关系是一种动态关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p><p>检查对象并确定对象有什么属性是很容易的事情，只要试着去检索该属性并验证取得的值。</p><p><code>typeof</code>用来确定对象属性的类型。</p><p><code>hasOwnProperty</code>，若对象拥有独有的属性，它将返回<code>true</code>。不会检查原型链。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用<code>for in</code>可以遍历一个对象中的所有属性名，包括原型链上的属性名。可以使用<code>hasOwnProperty</code>过滤原型链上的属性，使用<code>typeof</code>来排除函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> anotherStooge) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anotherStooge.hasOwnProperty(name) &amp;&amp; <span class="keyword">typeof</span> anotherStooge[name] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">'---&gt;'</span> + anotherStooge[name])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// firstName---&gt;bbb</span></span><br></pre></td></tr></table></figure><p>属性名是无序的，若想保持顺序应使用数组和<code>for</code>循环。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delete</code>可以用来删除对象的属性。若对象包含该属性，则会被移除。它不会触及原型链中的任何对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anotherStooge.firstName <span class="comment">//"bbb"</span></span><br><span class="line"><span class="keyword">delete</span> anotherStooge.firstName</span><br><span class="line">anotherStooge.firstName <span class="comment">//"aaa"</span></span><br></pre></td></tr></table></figure><h3 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h3><p>JavaScript 可以随意的定义全局变量来容纳应用的所有资源。但这会削弱程序的灵活性，应避免使用全局变量。</p><p>最小化使用全局变量的方法之一是为应用只创建一个唯一的全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.stooge = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.flight = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一章将使用闭包来进行信息隐藏，是另一种有效减少全局污染的方法。</p><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>JavaScript 中的函数就是对象。函数对象连接到<code>Function.prototype</code>（该原型对象本身连接到<code>Object.prototype</code>）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。</p><p>函数对象在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值即为该函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4lrei2b3pj208f06et95.jpg" alt></p><p>因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。</p><p>函数的与众不同之处在于可以被调用。</p><h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>函数对象通过函数字面量来创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：<code>this</code>和<code>arguments</code>。参数<code>this</code>在面向对象编程中非常重要，它的值取决于调用的模式。JavaScript中一共有4中调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。</p><p>实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为<code>undefined</code>。</p><p>下面的内容也可以参考我以前的博文 <a href="http://gaohaoyang.github.io/2015/06/12/JavaScript-this/" target="_blank" rel="noopener">JavaScript 中的 this</a></p><h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，<code>this</code>被绑定到该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params">inc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value += <span class="keyword">typeof</span> inc === <span class="string">'number'</span> ? inc : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.increment()</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">myObject.increment(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p>当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。</p><p>此时<code>this</code>被绑定到全局对象。即时是内部函数也会将<code>this</code>绑定到全局对象。</p><p>可以在函数内创建一个属性并赋值为<code>this</code>来解决这个问题。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.double = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.value = add(that.value, that.value)</span><br><span class="line">    &#125;</span><br><span class="line">    helper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.double()</span><br><span class="line"><span class="built_in">console</span>.log(myObject.value) <span class="comment">//8</span></span><br></pre></td></tr></table></figure><h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。</p><p>如果在一个函数前面带上<code>new</code>来调用，那么背地里将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时<code>this</code>会被绑定到那个新对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造器函数</span></span><br><span class="line"><span class="keyword">var</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Que的所有实例提供一个公共方法</span></span><br><span class="line">Quo.prototype.getStatus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">'confused'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myQuo.getStatus()) <span class="comment">//confused</span></span><br></pre></td></tr></table></figure><p>书中不推荐这种形式的构造器函数，下一章有更好的解决方案。</p><h4 id="Apply-调用模式"><a href="#Apply-调用模式" class="headerlink" title="Apply 调用模式"></a>Apply 调用模式</h4><p><code>apply</code>方法让我们构建一个参数数组传递给调用函数。他也允许我们选择<code>this</code>的值。<code>apply</code>方法接受两个参数，第一个是要绑定给<code>this</code>的值，第二个是参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> sum = add.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> statusObject = &#123;</span><br><span class="line">    status: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status = Quo.prototype.getStatus.apply(statusObject)</span><br><span class="line"><span class="built_in">console</span>.log(status) <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>当函数被调用时，会得到一个<code>arguments</code>数组。通过此参数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)) <span class="comment">//45</span></span><br></pre></td></tr></table></figure><p>因语言的设计错误，<code>arguments</code>并不是一个真正的数组。是一个“类似数组”的对象。有<code>length</code>属性，但没有任何数组的方法。</p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>函数执行时遇到关闭函数体的<code>}</code>时结束。然后把控制权交还给调用该函数的程序。</p><p><code>return</code>可以使函数提前返回，不在执行余下的语句。</p><p>函数总是会返回一个值，若没有指定，则返回<code>undefined</code>。</p><p>若函数调用时在前面加上了<code>new</code>前缀，且返回值不是一个对象的时候，则返回<code>this</code>（该新对象）。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是干扰程序的正常流畅的不寻常的事故。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'number'</span> || <span class="keyword">typeof</span> b !== <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> &#123;</span><br><span class="line">            name: <span class="string">'TypeError'</span>,</span><br><span class="line">            message: <span class="string">'add needs numbers'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="string">'a'</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7011d6cfjw1f4mprafcvhj20ml00xjrj.jpg" alt></p><p><code>throw</code>语句中断函数的执行。抛出一个<code>exception</code>对象，该对象包含一个用来识别异常类型的<code>name</code>属性和一个描述性的<code>message</code>属性。也可以自定义其他属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> try_it = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        add2(<span class="string">'a'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.name + <span class="string">': '</span> + e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">try_it() <span class="comment">//TypeError: add needs numbers</span></span><br></pre></td></tr></table></figure><p>如果在<code>try</code>代码块内抛出一个异常，控制权就会跳转到它的<code>catch</code>语句中。</p><h3 id="扩充类型的功能"><a href="#扩充类型的功能" class="headerlink" title="扩充类型的功能"></a>扩充类型的功能</h3><p>JavaScript 允许给语言的基本类型扩充功能。通过<code>Object.prototype</code>添加方法，可以让该方法对所有对象都适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先添加方法使得该方法对所有函数可用</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype[name] = func</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个取整方法</span></span><br><span class="line"><span class="built_in">Number</span>.method(<span class="string">'integer'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>[<span class="keyword">this</span> &lt; <span class="number">0</span> ? <span class="string">'ceil'</span> : <span class="string">'floor'</span>](<span class="keyword">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">-10</span> / <span class="number">3</span>).integer()) <span class="comment">//-3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 trim()</span></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'trim'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'  hello alibaba  '</span>.trim()) <span class="comment">//hello alibaba</span></span><br></pre></td></tr></table></figure><p>JavaScript 原型继承是动态的，因此新的方法立刻被赋予到所有的对象实例上，即使对象实例是在方法被增加之前就创建好了。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数就是会直接或者间接地调用自身的一种函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> walkTheDom = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node, func</span>) </span>&#123;</span><br><span class="line">    func(node)</span><br><span class="line">    node = node.firstChild</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        walk(node, func)</span><br><span class="line">        node = node.nextSibling</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getElementsByAttribute = <span class="function"><span class="keyword">function</span>(<span class="params">att, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = []</span><br><span class="line">    walkTheDom(<span class="built_in">document</span>.body, <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> actual = node.nodeType === <span class="number">1</span> &amp;&amp; node.getAttribute(att)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> actual === <span class="string">'string'</span> &amp;&amp; (actual === value || <span class="keyword">typeof</span> value !== <span class="string">'string'</span>)) &#123;</span><br><span class="line">            results.push(node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在知乎主页上操作</span></span><br><span class="line"><span class="built_in">console</span>.log(getElementsByAttribute(<span class="string">'data-za-module'</span>, <span class="string">'AnswerItem'</span>))</span><br><span class="line"><span class="comment">//得到下列数据</span></span><br><span class="line"><span class="comment">//[div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content, div.feed-content]</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域控制着变量与参数的可见性及生命周期。它减少了名称冲突，并提供了自动内存管理。</p><p>无块级作用域。</p><p>有函数作用域。</p><p>建议在函数体的顶部声明函数中可能用到的所有变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quo = <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get_status: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> status</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myQuo = quo(<span class="string">'amazed'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myQuo.get_status()) <span class="comment">//amazed</span></span><br></pre></td></tr></table></figure><p>狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。</p><p>避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前<code>i</code>值的函数，这样就不会导致混淆了。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>将一个函数作为参数，一旦接收到响应，再调用这个函数。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>可以用函数和闭包构造模块。</p><p>模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberCal = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> half = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> double = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tribble = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        half: half,</span><br><span class="line">        double: double,</span><br><span class="line">        tribble: tribble</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.half(<span class="number">5</span>)) <span class="comment">//2.5</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.half(<span class="number">6</span>)) <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.double(<span class="number">7</span>)) <span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(numberCal.tribble(<span class="number">7</span>)) <span class="comment">//21</span></span><br></pre></td></tr></table></figure><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>如果让方法返回<code>this</code>而不是默认的<code>undefined</code>，就可以启用级联，即连续调用。</p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。</p><p>详情见以前的博文 <a href="http://gaohaoyang.github.io/2015/06/11/JavaScript-function/#bind--currying" target="_blank" rel="noopener">JavaScript 函数 -bind 与 currying</a>。</p><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为第一部分包含书中前三章内容：语法、对象和函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/lpic/s3651235.jp
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="对象 函数 this 闭包 面向对象 作用域" scheme="https://qccs.github.io/tags/%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0-this-%E9%97%AD%E5%8C%85-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记3-方法、毒瘤等</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-06-10-JavaScript-good-parts-note3/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-06-10-JavaScript-good-parts-note3/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这一章主要介绍了一些方法集。这里写几个我不太熟悉的方法和要点吧。</p><ul><li><p><code>array.join()</code></p><blockquote><p>对于IE6/7，使用<code>array.join()</code>连接大量字符串的效率确实优于使用<code>+</code>元素运算符。但是目前主流的浏览器，包括IE8以后的版本，都对<code>+</code>元素运算符连接字符串做了特别优化，性能已经显著高于<code>array.join()</code>。</p></blockquote></li><li><p><code>number.toExponential(fractionDigits)</code></p><p>  把这个<code>number</code>转换成一个指数形式的字符串。</p></li><li><p><code>number.toFixed(fractionDigits)</code></p><p>  将这个<code>number</code>转换成一个十进制形式的字符串。</p></li></ul><h2 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h2><ul><li><p>注意全局变量的引入。</p></li><li><p>JavaScript 中 Unicode 是16位的。包含65536个字符（基本多文种平面 Basic Multilingual Plane）。剩下的百万字符中的每一个都可以用一对字符来表示。Unicode 把一对字符视为一个单一的字符，而 JavaScript 认为一对字符是两个不同的字符。</p></li><li><p>检测<code>null</code>的方式。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line">myValue === <span class="literal">null</span> <span class="comment">//检测 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myValue &amp;&amp; <span class="keyword">typeof</span> myValue === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// myValue 是一个对象或数组！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>parseInt</code> 把字符串转化为整数的函数。它遇到非数字时会停止解析，所以<code>parseInt(&#39;16&#39;)</code>和<code>parseInt(&#39;16ton&#39;)</code>产生相同的结果。</p><p>  如果该字符串第一个字符是0，那么该字符串会基于八进制而不是十进制来求职。在八进制中，8和9不是数字，所以<code>parseInt(&#39;08&#39;)</code>和<code>parseInt(&#39;09&#39;)</code>都产生0作为结果。但<code>parseInt()</code>可以接受基数，因此<code>parseInt(&#39;08&#39;,10)</code>结果为8，建议总是加上这个基数参数。</p></li><li><p>JavaScript 的对象永远不会是真的空对象，因为它们可以送原型链中取得成员属性。</p></li></ul><h2 id="糟粕"><a href="#糟粕" class="headerlink" title="糟粕"></a>糟粕</h2><ul><li><p>避免使用<code>with</code>语句。</p></li><li><p>避免使用<code>eval</code>语句。</p></li><li><p><code>continue</code>可能会降低运算性能。</p></li><li><p>位运算符在 JavaScript 会非常慢。</p><p>  Java 里，位运算符处理的是整数。JavaScript 没有整数类型，它只有双精度的浮点数，因此，位运算符把它们的数字运算数先转换为整数，执行运算，在转换回去。JavaScript 的执行环境一般接触不到硬件，所以非常慢。</p></li><li><p>避免使用包装对象。<code>new Object</code>和<code>new Array</code>等。</p></li><li><p>避免使用<code>void</code>。</p></li></ul><p>本系列结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为书中最后一部分：方法、代码风格、优美的特性、毒瘤、糟粕等。&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="函数 JavaScript" scheme="https://qccs.github.io/tags/%E5%87%BD%E6%95%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 babel</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-06-14-how-to-use-babel/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-06-14-how-to-use-babel/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。</p><p><img src="https://babeljs.io/images/logo.svg" alt></p><p>学习 Babel 可以通过其手册 Babel handbook。</p><ul><li><a href="https://github.com/thejameskyle/babel-handbook" target="_blank" rel="noopener">babel-handbook</a></li></ul><p>其中包含多语言版本，分为<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">用户手册</a>和<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">插件手册</a>。这是一个很好的学习 Babel 的资料。</p><h2 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h2><p>在 node 和 npm 环境安装好的前提下，安装 babel，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global babel-cli</span><br></pre></td></tr></table></figure><p>安装完成后就可以编译文件了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel main.js</span><br></pre></td></tr></table></figure><p>编译后的文件显示在终端上，可以添加其他命令让它输出到指定文件下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel example.js --out-file compiled.js</span><br><span class="line">或</span><br><span class="line">babel example.js -o compiled.js</span><br></pre></td></tr></table></figure><p>或将整个目录编译成一个新的目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel src --out-dir lib</span><br><span class="line">或</span><br><span class="line">babel src -d lib</span><br></pre></td></tr></table></figure><p>但这很麻烦，并且并不是一个很好的解决方案，请看下一节项目内运行 babel-cli。</p><h2 id="在项目内运行-babel-cli"><a href="#在项目内运行-babel-cli" class="headerlink" title="在项目内运行 babel-cli"></a>在项目内运行 babel-cli</h2><p>初始化项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>再安装 babel-cli</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure><p>项目中的<code>package.json</code>应该包含如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"learn-es6"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-cli"</span>: <span class="string">"^6.10.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 npm scripts 命令。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name": "learn-es6",</span><br><span class="line">  "version": "1.0.0",</span><br><span class="line"><span class="addition">+   "scripts": &#123;</span></span><br><span class="line"><span class="addition">+     "build": "babel src -d lib"</span></span><br><span class="line"><span class="addition">+   &#125;,</span></span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "babel-cli": "^6.10.1"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在终端里运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>还不能成功编译，因为没有配置<code>.babelrc</code>文件。</p><h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置<code>.babelrc</code></h2><p>通过配置<code>.babelrc</code>来告诉 babel 来做什么。</p><p>在项目的根路径下创建<code>.babelrc</code>文件。然后输入以下内容作为开始：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [],</span><br><span class="line">    <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让 babel 将 ES2015 转化为 ES5，我们要安装如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br></pre></td></tr></table></figure><p>安装完成后在<code>.babelrc</code>中添加参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "presets": [</span><br><span class="line"><span class="addition">+       "es2015"</span></span><br><span class="line">    ],</span><br><span class="line">    "plugins": []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在项目<code>src/main.js</code>中写一些 ES2015 的代码试试吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在终端中输入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>执行后终端中显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; learn-es6@1.0.0 build c:\gitWorkSpace\learn-es6</span><br><span class="line">&gt; babel src -d lib</span><br></pre></td></tr></table></figure><p>然后可以看到目录中出现了<code>lib/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>即编译成功。</p><h2 id="配置-jshintrc"><a href="#配置-jshintrc" class="headerlink" title="配置.jshintrc"></a>配置<code>.jshintrc</code></h2><p>若编辑器中安装了 jshint 语法检查的插件。默认对于 ES2015 的代码可能会报错或者警告，看着可能会不爽。我们可以在配置文件中将它设置为允许 ES2015 的模式。</p><p>在项目根目录下创建文件<code>.jshintrc</code>。内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"asi"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esversion"</span>: <span class="number">2015</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述文件我分别设置了，使用无分号模式，es 版本使用 2015。</p><p>关于<code>.jshintrc</code>的更详细配置可以参见官方示例：<a href="https://github.com/jshint/jshint/blob/master/examples/.jshintrc" target="_blank" rel="noopener">https://github.com/jshint/jshint/blob/master/examples/.jshintrc</a></p><p>好，babel 就说到这里，下面开始进入真正的 ES2015 的学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Babel&lt;/a&gt; 用于将 ES6 的代码转化为 ES5，使得 ES6 可以
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="ES2015 ES6 ES5 babel" scheme="https://qccs.github.io/tags/ES2015-ES6-ES5-babel/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言精粹笔记2-继承、数组、正则表达式</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-06-08-JavaScript-good-parts-note2/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-06-08-JavaScript-good-parts-note2/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的两大好处：代码重用，引入一套类型系统的规范。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>JavaScript 通过构造器函数产生对象。</p><p>构造器调用模式，即用<code>new</code>前缀去调用一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mammal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mammal.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mammal.prototype.says = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.saying || <span class="string">''</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMammal = <span class="keyword">new</span> Mammal(<span class="string">'Herb'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myMammal.getName()) <span class="comment">//Herb</span></span><br></pre></td></tr></table></figure><p>书中不推荐这样的写法。有很多风险。若忘记添加<code>new</code>前缀，<code>this</code>无法绑定到新的对象上。而是绑定到了全局对象上，破坏了全局变量环境。</p><h3 id="对象说明符"><a href="#对象说明符" class="headerlink" title="对象说明符"></a>对象说明符</h3><p>上一节中的构造器可能要接受一大串参数。我们可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = Maker(&#123;</span><br><span class="line">    first: f,</span><br><span class="line">    middle: m,</span><br><span class="line">    last: l,</span><br><span class="line">    state: s,</span><br><span class="line">    city: c</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将JSON对象传递给构造器，而它返回一个构造完全的对象。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在一个纯粹的原型模式中，我们将摒弃类，转而专注于对象。一个新对象可以继承一个就对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMammal = &#123;</span><br><span class="line">    name: <span class="string">'MM'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;,</span><br><span class="line">    says: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.saying || <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCat = <span class="built_in">Object</span>.create(myMammal)</span><br><span class="line">myCat.name = <span class="string">'Kitty'</span></span><br><span class="line">myCat.saying = <span class="string">'meow'</span></span><br><span class="line">myCat.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Kitty is running'</span></span><br><span class="line">&#125;</span><br><span class="line">myCat.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.says + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.says</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种差异化继承。</p><h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><p>前文看到的继承模式没法保护隐私。对象的所有属性都是可见的。无法得到私有变量和私有函数。为了解决这一问题，我们有模块模式。</p><p>构造一个生成对象的函数需要4步骤：</p><ol><li>创建一个新对象。</li><li>有选择的定义私有变量和方法。</li><li>给这个新对象扩充方法。</li><li>返回那个新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mammal = <span class="function"><span class="keyword">function</span>(<span class="params">spec</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    that.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spec.name</span><br><span class="line">    &#125;</span><br><span class="line">    that.says = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spec.saying || <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMammal = mammal(&#123;</span><br><span class="line">    name: <span class="string">'Herb'</span>,</span><br><span class="line">    saying: <span class="string">'Cheers!'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.getName()) <span class="comment">//Herb</span></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.says()) <span class="comment">//Cheers!</span></span><br></pre></td></tr></table></figure><p>也可以参考上一篇文章，<a href="http://gaohaoyang.github.io/2016/06/07/JavaScript-good-parts-note1/#section-34" target="_blank" rel="noopener">JavaScript 语言精粹笔记1-语法、对象、函数 之模块部分</a>。</p><h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>这一部分看的不是特别懂，我想等我学完ES2015中的类和模块部分后再看看吧。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>一个数组字面量是在一对方括号中包围零个或多个用逗号分隔的值的表达式。</p><p>再大多数语言中，一个数组的多有元素都要求是相同的类型。JavaScript 允许数组包含任意混合类型的值。</p><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>JavaScript 数组的<code>length</code>属性是没有上界的。如果用大于或等于当前<code>length</code>的数字作为下标来存储一个元素，那么<code>length</code>值会被增大以容纳新元素，不会发生数组越界错误。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>数组也是对象，可以用<code>delete</code>来删除元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="number">3</span>, <span class="string">'four'</span>, <span class="string">'wu'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> numbers[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.length) <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>可以使用<code>splice</code>方法，进行删除和修改操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">0</span>]) <span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.length) <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用常规<code>for</code>循环即可，可以保证数组的顺序。</p><h3 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h3><p>当属性名是小而连续的整数时，应该使用数组，否则使用对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>返回数组的类型是<code>object</code>，没有任何意义。</p><p>判断数组类型的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(numbers)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5.1 (ECMA-262) 和 ECMAScript 2015 (6th Edition, ECMA-262) 标准中的方法。</p><p>或者下面这个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> is_array = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply(value) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(is_array(numbers)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>数组的方法被存储在<code>Array.prototype</code>中的函数。</p><p>数组是对象，因此<code>Array.prototype</code>也是可扩充的。</p><h3 id="指定初始值"><a href="#指定初始值" class="headerlink" title="指定初始值"></a>指定初始值</h3><p>JavaScript 的数组不会预制值。</p><p>JavaScript 没有多维数组，单项大多数类 C 语言一样，支持元素为数组的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = [</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.log(matrix[<span class="number">1</span>][<span class="number">2</span>]) <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>关于正则表达式，以前的博文写的比较多了，详情见：</p><p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-10" target="_blank" rel="noopener">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分1</a></p><p><a href="http://gaohaoyang.github.io/2015/04/22/baidu-ife-2-javascript/#section-12" target="_blank" rel="noopener">百度Web前端技术学院(2)-JavaScript 基础 之正则表达式部分2</a></p><p><a href="http://gaohaoyang.github.io/2016/05/06/regular-expression-group/" target="_blank" rel="noopener">浅谈正则表达式中的分组和引用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录一下阅读蝴蝶书的笔记，本篇为书中以下章节的笔记：继承、数组和正则表达式。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="继承 对象 原型 Array 正则" scheme="https://qccs.github.io/tags/%E7%BB%A7%E6%89%BF-%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B-Array-%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Fisher–Yates shuffle 洗牌算法</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-10-16-shuffle-algorithm/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-10-16-shuffle-algorithm/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p><p>本文主要介绍这个算法的来源、演变、原理。并举出一个例子为大家清晰的描述每次迭代过程。最后使用 JavaScript 代码将算法实现。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Riffle_shuffle.jpg/320px-Riffle_shuffle.jpg" alt></p><h2 id="Fisher-and-Yates-的原始版"><a href="#Fisher-and-Yates-的原始版" class="headerlink" title="Fisher and Yates 的原始版"></a>Fisher and Yates 的原始版</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Biologist_and_statistician_Ronald_Fisher.jpg/189px-Biologist_and_statistician_Ronald_Fisher.jpg" alt></p><p>Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher（上图） 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：</p><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。</p><h2 id="现代方法"><a href="#现代方法" class="headerlink" title="现代方法"></a>现代方法</h2><p>Fisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。</p><p>现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。<strong>这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后</strong>。这样就将时间复杂度从 O(n^2) 减小到了 <strong>O(n)</strong>。算法的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- To shuffle an array a of n elements (indices 0..n-1):</span><br><span class="line">for i from n−1 downto 1 do</span><br><span class="line">     j ← random integer such that 0 ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="迭代步骤演示"><a href="#迭代步骤演示" class="headerlink" title="迭代步骤演示"></a>迭代步骤演示</h3><p>根据每次迭代次数可以用下面的表格，描述这个算法的执行过程</p><table><thead><tr><th style="text-align:left">随机数取值范围</th><th style="text-align:left">随机数</th><th style="text-align:right">原始数据</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:right">1 2 3 4 5 6 7 8</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1-8</td><td style="text-align:left">6</td><td style="text-align:right">1 2 3 4 5 7 8</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">1-7</td><td style="text-align:left">2</td><td style="text-align:right">1 7 3 4 5 8</td><td style="text-align:left">2 6</td></tr><tr><td style="text-align:left">1–6</td><td style="text-align:left">6</td><td style="text-align:right">1 7 3 4 5</td><td style="text-align:left">8 2 6</td></tr><tr><td style="text-align:left">1–5</td><td style="text-align:left">1</td><td style="text-align:right">5 7 3 4</td><td style="text-align:left">1 8 2 6</td></tr><tr><td style="text-align:left">1–4</td><td style="text-align:left">3</td><td style="text-align:right">5 7 4</td><td style="text-align:left">3 1 8 2 6</td></tr><tr><td style="text-align:left">1–3</td><td style="text-align:left">3</td><td style="text-align:right">5 7</td><td style="text-align:left">4 3 1 8 2 6</td></tr><tr><td style="text-align:left">1–2</td><td style="text-align:left">1</td><td style="text-align:right">7</td><td style="text-align:left">5 4 3 1 8 2 6</td></tr></tbody></table><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p>下面这个动画就是整个数组 0-19 的随机排序过程</p><iframe height="317" scrolling="no" src="//codepen.io/haoyang/embed/jrvrQq/?height=317&theme-id=dark&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/haoyang/pen/jrvrQq/" target="_blank" rel="noopener">Fisher–Yates shuffle</a> by Chuan shi (<a href="http://codepen.io/haoyang" target="_blank" rel="noopener">@haoyang</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h2 id="JavaScript-代码实现"><a href="#JavaScript-代码实现" class="headerlink" title="JavaScript 代码实现"></a>JavaScript 代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fisher–Yates shuffle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = input.length<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">var</span> itemAtIndex = input[randomIndex];</span><br><span class="line"></span><br><span class="line">        input[randomIndex] = input[i];</span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式也很简单，直接用数组调用这个方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>].shuffle()</span><br><span class="line"></span><br><span class="line"><span class="comment">//[4, 6, 3, 2, 5, 1, 7, 8] // 每次结果都是随机的</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，Fisher–Yates shuffle 算法是一个非常高效又公平的随机排序算法，如果有随机排序数组的需求，用这个就对了！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="noopener">Fisher–Yates shuffle From Wikipedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。&lt;/p&gt;
&lt;p&gt;本文主
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="算法 shuffle 乱序 洗牌" scheme="https://qccs.github.io/tags/%E7%AE%97%E6%B3%95-shuffle-%E4%B9%B1%E5%BA%8F-%E6%B4%97%E7%89%8C/"/>
    
  </entry>
  
  <entry>
    <title>使用 JavaScript 创建并下载文件</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-11-22-js-create-file-and-download/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-11-22-js-create-file-and-download/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。</p><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并下载文件</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125; fileName 文件名</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125; content  文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAndDownloadFile</span>(<span class="params">fileName, content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aTag = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line">    aTag.download = fileName;</span><br><span class="line">    aTag.href = URL.createObjectURL(blob);</span><br><span class="line">    aTag.click();</span><br><span class="line">    URL.revokeObjectURL(blob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单对吧，直接调用这个方法，传入文件名和文件内容，程序新建 a 标签，新建 Blob 对象，将文件名赋给 a 标签，同时将 Blob 对象作为 Url 也赋给 a 标签，模拟点击事件，自动下载成功，最后再回收内存。下面我们来看看具体是怎么操作的。</p><p><img src="https://img.alicdn.com/tfs/TB16.GnOpXXXXXdapXXXXXXXXXX-307-134.png" alt></p><h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 对象是一个字节序列。拥有 <code>size</code> 和 <code>type</code> 等属性。</p><p>拥有 2 个只读状态 <code>OPEND</code> 和 <code>CLOSED。</code></p><p>Blob 对象属于 JavaScript Web APIs 中的 File API 规定的部分，可以参考 W3C 文档中的 <a href="https://www.w3.org/TR/2015/WD-FileAPI-20150421/#blob" target="_blank" rel="noopener"> The Blob Interface and Binary Data</a></p><p>再回来看看我们的代码里是这么写的，使用了 Blob 的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([content]);</span><br></pre></td></tr></table></figure><p>使用方括号的原因是，其构造函数的参数为以下4中：</p><ul><li>ArrayBuffer [TypedArrays] elements.</li><li>ArrayBufferView [TypedArrays] elements.</li><li>Blob elements.</li><li>DOMString [WebIDL] elements.</li></ul><p>所谓 <code>ArrayBuffer</code> 是一种用于呈现通用、固定长度的二进制数据的类型。详情可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer -MDN</a> 以及 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arraybuffer-objects" target="_blank" rel="noopener">ECMAScript2015 标准中的 ArrayBuffer</a>。</p><h2 id="Blob-URLs"><a href="#Blob-URLs" class="headerlink" title="Blob URLs"></a>Blob URLs</h2><p>Blob URLs 被创建或注销是使用 <code>URL</code> 对象上的方法。这个 <code>URL</code> 对象被挂在 <code>Window</code> (HTML) 对象下，或者 <code>WorkerGlobalScope</code> (Web Workers)对象下。</p><p>拥有以下静态方法 <code>createObjectURL</code> 和 <code>revokeObjectURL</code>，用于创建一个 blob 对象的 url 和注销这个 blob url。</p><p>详情可查看 <a href="https://www.w3.org/TR/2015/WD-FileAPI-20150421/#creating-revoking" target="_blank" rel="noopener">关于创建和注销 Blob URL 的 W3C 标准文档</a></p><h2 id="模拟-click"><a href="#模拟-click" class="headerlink" title="模拟 click"></a>模拟 click</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.click();</span><br></pre></td></tr></table></figure><p>在 W3C 中很早就有这个<a href="https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-2651361" target="_blank" rel="noopener">规范</a>，不需要写繁琐的模拟事件触发的代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前我将这个技术使用在 天猫双十一技术和UED庆功会 的摇火箭大屏游戏中。最后的游戏结果排名，在请求了接口后，在前端直接生成并下载到了本地，作为记录保存。主要也是因为服务端暂时没有提供这个一张表去记录游戏结果，于是采用了前端记录的解决方案。</p><p>大家当时都玩的好开心啊，😁。你们的甘其食和全家卡的名单就是这样生成的！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.alloyteam.com/2014/01/use-js-file-download/" target="_blank" rel="noopener">在浏览器端用JS创建和下载文件 -alloyteam</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将介绍如何使用 JavaScript 创建文件，并自动/手动将文件下载。这在导出原始数据时会比较方便。&lt;/p&gt;
&lt;h2 id=&quot;先上代码&quot;&gt;&lt;a href=&quot;#先上代码&quot; class=&quot;head
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="文件 下载 JavaScript" scheme="https://qccs.github.io/tags/%E6%96%87%E4%BB%B6-%E4%B8%8B%E8%BD%BD-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vscode 插件 markdown-schedule-snippet</title>
    <link href="https://qccs.github.io/2019/04/13/z/2018-10-10-vscode-plugin-schedule/"/>
    <id>https://qccs.github.io/2019/04/13/z/2018-10-10-vscode-plugin-schedule/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不知道大家是怎样安排自己的日常计划的，我习惯是建立一个仓库，按照年/周记录在 markdown 里，平时这个仓库也写点简单的 demo，目录类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">week</span><br><span class="line">├── 2016</span><br><span class="line">├── 2017</span><br><span class="line">├── 2018</span><br><span class="line">│   ├── 20180102.md</span><br><span class="line">│   ├── 20180108.md</span><br><span class="line">│   ├── 20180115.md</span><br><span class="line">│   ├── 20180122.md</span><br><span class="line">│   ├── 20180126.md</span><br><span class="line">│   ├── ...</span><br><span class="line">│   ├── ...</span><br><span class="line">│   ├── ...</span><br><span class="line">│   ├── 20181007.md</span><br><span class="line">│   ├── pixi.md</span><br><span class="line">│   ├── schedule.md</span><br><span class="line">│   ├── temp.css</span><br><span class="line">│   ├── temp.html</span><br><span class="line">│   ├── temp.js</span><br><span class="line">│   ├── temp.json</span><br><span class="line">│   └── temp.md</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>当然每个人有自己习惯的方式记录着日常工作与生活。我平时是使用这种方式，当然这个记录里涉及了很多工作上的信息，目前仅在内部的 gitlab 上托管着。</p><p>对于每一个 md 文件内部，我习惯按照星期几来记录，类似如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665ccd109702abc?w=903&amp;h=893&amp;f=png&amp;s=151884" alt></p><h2 id="markdown-schedule-snippet"><a href="#markdown-schedule-snippet" class="headerlink" title="markdown-schedule-snippet"></a>markdown-schedule-snippet</h2><p>可以看到每次写这些星期几的缩略都很麻烦，于是开发了一个简单的 vscode 插件 markdown-schedule-snippet，正是本文的标题，输入 <code>we</code> 自动生成如下代码</p><p>插件地址 <a href="https://marketplace.visualstudio.com/items?itemName=HyG.schedule" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=HyG.schedule</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## Mon.</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Tue.</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Wed.</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Thur.</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Fri.</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Sat.</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Sun.</span></span><br></pre></td></tr></table></figure><p>还有我自己设计的 logo，哈哈哈</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d564192bc6bb?w=256&amp;h=256&amp;f=png&amp;s=51734" alt></p><p>这个插件仓库地址 <a href="https://github.com/Gaohaoyang/markdown-schedule-snippet" target="_blank" rel="noopener">https://github.com/Gaohaoyang/markdown-schedule-snippet</a></p><p>欢迎大家使用，同时也欢迎小伙伴们为这个仓库贡献一些其他有趣的 markdown snippet，欢迎你的 pr。</p><p>Enjoy it!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;不知道大家是怎样安排自己的日常计划的，我习惯是建立一个仓库，按照
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="效率 vscode markdown" scheme="https://qccs.github.io/tags/%E6%95%88%E7%8E%87-vscode-markdown/"/>
    
  </entry>
  
  <entry>
    <title>前端如何写一个精确的倒计时</title>
    <link href="https://qccs.github.io/2019/04/13/z/2016-11-25-how-to-write-a-count-down/"/>
    <id>https://qccs.github.io/2019/04/13/z/2016-11-25-how-to-write-a-count-down/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改了他的设备时间，这样的倒计时就没有意义了。今天就说说写一个精确的倒计时的方法。</p><p><img src="https://img.alicdn.com/tfs/TB18QnlOpXXXXcVXpXXXXXXXXXX-388-256.png" alt></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>众所周知 setTimeout 或者 setInterval 调用的时候会有微小的误差。有人做了一个 <a href="https://bl.ocks.org/kenpenn/raw/92ebaa71696b4c4c3acd672b1bb3f49a/" target="_blank" rel="noopener">demo</a> 来观察这个现象并对其做了修正。短时间的误差倒也可以接受，但是作为一个长时间的倒计时，误差累计就会导致倒计时不准确。</p><p>因此我们可以在获取剩余时间的时候，每次 new 一个设备时间，因为设备时间的流逝相对是准确的，并且如果设备打开了网络时间同步，也会解决这个问题。</p><p>但是，如果用户修改了设备时间，那么整个倒计时就没有意义了，用户只要将设备时间修改为倒计时的 endTime 就可以轻易看到倒计时结束是页面的变化。因此一开始获取服务端时间就是很重要的。</p><p>简单的说，一个简单的精确倒计时原理如下：</p><ul><li>初始化时请求一次服务器时间 serverTime，再 new 一个设备时间 deviceTime</li><li>deviceTime 与 serverTime 的差作为时间偏移修正</li><li>每次递归时 new 一个系统时间，解决 setTimeout 不准确的问题</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>获取剩余时间的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取剩余时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; endTime    截止时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; deviceTime 设备时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;Number&#125; serverTime 服务端时间</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125;            剩余时间对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> getRemainTime = <span class="function">(<span class="params">endTime, deviceTime, serverTime</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = endTime - <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) - serverTime + deviceTime</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="built_in">Math</span>.floor((t / <span class="number">1000</span>) % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor((t / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor((t / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)) % <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">let</span> days = <span class="built_in">Math</span>.floor(t / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>))</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'total'</span>: t,</span><br><span class="line">        <span class="string">'days'</span>: days,</span><br><span class="line">        <span class="string">'hours'</span>: hours,</span><br><span class="line">        <span class="string">'minutes'</span>: minutes,</span><br><span class="line">        <span class="string">'seconds'</span>: seconds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>获取服务器时间可以使用 mtop 接口 <code>mtop.common.getTimestamp</code> </del></p><p>然后可以通过下面的方式来使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务端时间（获取服务端时间代码略）</span></span><br><span class="line">getServerTime(<span class="function">(<span class="params">serverTime</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    <span class="keyword">let</span> intervalTimer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        <span class="keyword">let</span> remainTime = getRemainTime(endTime, deviceTime, serverTime)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒计时到两个小时内</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime.total &lt;= <span class="number">7200000</span> &amp;&amp; remainTime.total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒计时结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainTime.total &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            clearInterval(intervalTimer);</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的的写法也可以做到准确倒计时，同时也比较简洁。不需要隔段时间再去同步一次服务端时间。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在写倒计时的时候遇到了一个坑这里记录一下。</p><p><strong>千万别在倒计时结束的时候请求接口</strong>。会让服务端瞬间 QPS 峰值达到非常高。</p><p><img src="https://img.alicdn.com/tfs/TB1LBzjOpXXXXcnXpXXXXXXXXXX-154-71.png" alt></p><p>如果在倒计时结束的时候要使用新的数据渲染页面，正确的做法是：</p><p>在倒计时结束前的一段时间里，先请求好数据，倒计时结束后，再渲染页面。</p><p>关于倒计时，如果你有什么更好的解决方案，欢迎评论交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于写倒计时大家可能都都比较熟悉，使用 setTimeout 或 setInterval 就可以搞定。几秒钟或者几分钟的倒计时这样写没有问题，但是如果是长时间的倒计时，这样写就会不准确。如果用户修改
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="countdown JavaScript" scheme="https://qccs.github.io/tags/countdown-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从设计师和开发的角度使用 lottie</title>
    <link href="https://qccs.github.io/2019/04/13/z/2018-09-10-lottie/"/>
    <id>https://qccs.github.io/2019/04/13/z/2018-09-10-lottie/</id>
    <published>2019-04-13T07:32:25.000Z</published>
    <updated>2019-04-13T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p><img src="https://gw.alicdn.com/tfs/TB1yLBduDqWBKNjSZFAXXanSpXa-800-600.gif" alt></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">lottie</a> 是一个可以轻易的给各种 native app 添加高质量动画的类库。可以在 iOS、Android 和 React Native 实时渲染 After Effects 动画，就像使用静态图片一样容易。上图即为 lottie 的 logo。</p><p>简单的说，lottie 动画制作的流程是，通过 Bodymovin 扩展将 AE 动画导出为 json 数据，然后再将这个 json 渲染在客户端或者 web 端。如下图：</p><p><img src="https://gw.alicdn.com/tfs/TB1G3F7u67nBKNjSZLeXXbxCFXa-617-255.png" alt></p><p>官网宣传了3个特性：</p><ul><li>灵活使用AE的特性</li><li>随心所欲控制你的动画</li><li>很小的文件体积</li></ul><p>个人认为 lottie 最大的优势就是可以将设计师设计的动图原原本本的在页面上展现出来，完美还原了动画的精细度，并且对动画拥有足够的控制能力。目前所有使用 gif 或 apng 的场景应该都可以使用 lottie，当然 lottie 不局限与此场景。</p><p>本文主要从设计师视角和开发者视角讲述 lottie-web 的原理和使用以及 lottie 在 weex/rax 中的使用。</p><p><a href="https://gaohaoyang.github.io/lottie-test/" target="_blank" rel="noopener">Demo</a></p><video src="http://cloud.video.taobao.com//play/u/4121310810/p/1/e/6/t/1/50255502072.mp4" autoplay controls preload loop muted width="300px"></video><p><img src="https://gw.alicdn.com/tfs/TB1xhmyutcnBKNjSZR0XXcFqFXa-300-300.png" alt></p><iframe width="375px" height="500px" src="https://gaohaoyang.github.io/lottie-test/" frameborder="0"></iframe><h2 id="设计师视角"><a href="#设计师视角" class="headerlink" title="设计师视角"></a>设计师视角</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在 AE 中为 lottie 创作动画，你需要以下准备</p><ul><li><a href="https://www.adobe.com/products/aftereffects.html" target="_blank" rel="noopener">Adobe After Effects</a></li><li><a href="http://airbnb.io/lottie/after-effects/bodymovin-installation.html" target="_blank" rel="noopener">Bodymovin AE 插件</a></li><li>Lottiefiles preview app (集成了 lottie sdk 的 app)</li></ul><p>安装 Bodymovin 插件的流程如下：</p><ol><li>关闭 AE</li><li>安装 ZXP installer。 ZXP Installer 就是专门用来安装 Adobe 公司的软件产品的插件的工具。</li><li>下载最新的 bodymovin 扩展。<br><a href="https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp" target="_blank" rel="noopener">https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp</a><br><img src="https://gw.alicdn.com/tfs/TB1Q6dipMZC2uNjSZFnXXaxZpXa-2012-620.png" alt></li><li>打开 ZXP installer 并把 bodymovin 扩展拖拽进来</li><li>打开 AE，在菜单 <code>Window &gt; Extensions</code> 中，你会看到安装好的扩展</li></ol><p>安装插件详见 <a href="http://airbnb.io/lottie/after-effects/bodymovin-installation.html" target="_blank" rel="noopener">http://airbnb.io/lottie/after-effects/bodymovin-installation.html</a></p><h3 id="从-Sketch-SVG-Illustrator-到-Lottie-的工作流"><a href="#从-Sketch-SVG-Illustrator-到-Lottie-的工作流" class="headerlink" title="从 Sketch/SVG/Illustrator 到 Lottie 的工作流"></a>从 Sketch/SVG/Illustrator 到 Lottie 的工作流</h3><p>下面讲讲如何从 Sketch 开始，制作一个 lottie 动画文件。如果你使用 svg 图片，跳到步骤3。如果你使用 AI，跳到步骤4。需要准备好 Sketch，AI，AE，并安装好 Bodymovin 插件。下面开始：</p><ol><li>在 sketch 中确保要导出的内容已经群组为一个 group</li><li>将这个 group 导出为 svg</li><li>在 AI 中打开 svg，并转存为 <code>.ai</code> 文件</li><li>将 <code>.ai</code> 文件导入到 AE 中</li><li>在 AE 中创建组件，设置动画持续时间和帧率</li><li>将 ai 文件转为 shape layers。<br>在组件中选中你的图层，菜单 Layer 中选择 Create shapes from vector layer</li><li><strong>添加你想要的任何动画，这一部分是你主要工作的步骤</strong></li><li>使用 Bodymovin 导出为 json<br>菜单中选择 Window &gt; Extensions &gt; Bodymovin</li><li>测试动画。<br>确保动画中没有<a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">不支持的特性</a>，然后可以拖拽到 <a href="https://www.lottiefiles.com/" target="_blank" rel="noopener">lottieFiles</a> 中查看效果。<br>当然也可以上传到 lottieFiles 里，然后使用 lottie preview app 扫码查看。<br>这时你就可以将动画交付给开发同学啦！</li></ol><p>更多细节可查看官方文档 <a href="http://airbnb.io/lottie/after-effects/artwork-to-lottie-walkthrough.html" target="_blank" rel="noopener">Sketch/SVG/Illustrator to Lottie workflow</a></p><h3 id="注意事项-amp-优化建议"><a href="#注意事项-amp-优化建议" class="headerlink" title="注意事项&amp;优化建议"></a>注意事项&amp;优化建议</h3><p>*AE 特性大部分已经支持，具体可以查看 <a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">Supported Features（支持列表）</a>，设计师应该避免使用不支持 AE 的特性。</p><p>目前开看，支持较好的属性有：</p><ul><li>Shapes</li><li>Fills</li><li>Strokes</li><li>Transforms</li><li>Interpolation</li></ul><p>不完全支持的属性分类有：</p><ul><li>Masks</li><li>Mattes</li><li>Merge Paths</li><li>Layer Effects</li><li>Text</li></ul><p><a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener"><img src="https://gw.alicdn.com/tfs/TB1ndK3uBsmBKNjSZFFXXcT9VXa-795-535.png" alt></a></p><p>*设计过程中的优化建议和注意事项 <a href="http://airbnb.io/lottie/after-effects/general-tips.html" target="_blank" rel="noopener">General tips &amp; guidelines</a></p><ul><li>尽量保持简单小巧<br>在相同的图层上复制相同的关键帧会增加额外的代码，只有在必要时才使用路径关键帧动画。</li><li>导出 1x 图</li><li>No expressions or effects<br>Lottie 还不支持 expressions 或 effects 菜单中的任何 effects</li><li>Matte and mask 尺寸问题<br>使用半透明遮罩会影响性能。如果必须使用遮罩，请覆盖最小的区域。</li><li>不支持 Blending modes 或 Luma mattes</li><li>不支持图层样式<br>图层效果不支持drop shadow, color overlay 或 stroke</li><li>全屏动画，导出比最大屏幕宽度更宽一点的图像，在 Android 和 iOS 上可以分别裁切<br><img src="http://airbnb.io/lottie/images/LottieFullScreen.gif" alt></li></ul><h2 id="开发者视角"><a href="#开发者视角" class="headerlink" title="开发者视角"></a>开发者视角</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先当然是看<a href="http://airbnb.io/lottie/" target="_blank" rel="noopener">开发文档</a>。这里我简单说说其中 lottie-web 的使用。</p><p>可以通过 script 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.com/libraries/bodymovin"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或 npm 包 <a href="https://www.npmjs.com/package/lottie-web" target="_blank" rel="noopener">lottie-web</a> 引用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S lottie-web</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lottie <span class="keyword">from</span> <span class="string">'lottie-web'</span></span><br></pre></td></tr></table></figure><p>调用 loadAnimation()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myLottie = lottie.loadAnimation(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.querySelector(<span class="string">'.img-area'</span>),</span><br><span class="line">  renderer: <span class="string">'svg'</span>,</span><br><span class="line">  name: <span class="string">'myLottieAnim'</span>,</span><br><span class="line">  loop: <span class="literal">true</span>,</span><br><span class="line">  autoplay: <span class="literal">true</span>,</span><br><span class="line">  path: <span class="string">'./assets/cycle_animation.json'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="参数-api-事件"><a href="#参数-api-事件" class="headerlink" title="参数/api/事件"></a>参数/api/事件</h3><p>loadAnimation 的参数</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>container</td><td>用于渲染的容器，一般使用一个 div 即可</td></tr><tr><td>renderer</td><td>渲染器，可以选择 ‘svg’ / ‘canvas’ / ‘html’，个人测试发现 svg 效果和兼容性最好</td></tr><tr><td>name</td><td>动画名称，用于 reference</td></tr><tr><td>loop</td><td>循环</td></tr><tr><td>autoplay</td><td>自动播放</td></tr><tr><td>path</td><td>json 路径，页面会通过一个 http 请求获取 json</td></tr><tr><td>animationData</td><td>json 动画数据，与 path 互斥，建议使用 path，因为 animationData 会将数据打包进来，会使得 js bundle 过大</td></tr></tbody></table><p>获取到 lottie 实例后，可以调用 api 控制动画，例如上述代码中可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myLottie.pause()</span><br></pre></td></tr></table></figure><p>相关 api</p><table><thead><tr><th>名称</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>stop</td><td>无</td><td>停止动画</td></tr><tr><td>play</td><td>无</td><td>播放动画</td></tr><tr><td>pause</td><td>无</td><td>暂停</td></tr><tr><td>setSpeed</td><td>Number</td><td>设置播放速度，1 表示1倍速度，0.5 表示 0.5倍速度</td></tr><tr><td>setDirection</td><td>Number</td><td>正反向播放，1 表示 正向，-1 表示反向</td></tr><tr><td>goToAndStop</td><td>Number, [Boolean]</td><td>跳到某一帧或某一秒停止，第二个参数 iFrame 为是否基于帧模式还是时间，默认为 false</td></tr><tr><td>goToAndPlay</td><td>Number, [Boolean]</td><td>跳到某一帧或某一秒开始，第二个参数 iFrame 为是否基于帧模式还是时间，默认为 false</td></tr><tr><td>playSegments</td><td>Array, [Boolean]</td><td>播放片段，参数1为数组，两个元素为开始帧和结束帧；参数2为，是否立即播放片段，还是等之前的动画播放完成</td></tr><tr><td>destroy</td><td>无</td><td>销毁</td></tr></tbody></table><p>事件</p><ul><li>onComplete</li><li>onLoopComplete</li><li>onEnterFrame</li><li>onSegmentStart</li></ul><p>也可以使用 addEventListener 监听以下事件</p><ul><li>complete</li><li>loopComplete</li><li>enterFrame</li><li>segmentStart</li><li>config_ready (when initial config is done)</li><li>data_ready (when all parts of the animation have been loaded)</li><li>data_failed (when part of the animation can not be loaded)</li><li>loaded_images (when all image loads have either succeeded or errored)</li><li>DOMLoaded (when elements have been added to the DOM)</li><li>destroy</li></ul><p>具体也可以查看<a href="https://github.com/airbnb/lottie-web/" target="_blank" rel="noopener">组件文档</a></p><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><ul><li>使用压缩混淆过的 js，毕竟目前 lottie-web 还是有点大，gzip 后大概 57k</li><li>尽量使用简单小巧的 json，其实也是需要在 AE 中做一些优化，这需要前端和设计一起配合完成，例如<ul><li>避免使用很大的形状，但是用很小的 mask 切出来</li><li>太多的节点也会影响性能</li></ul></li></ul><h2 id="weex-rax-中使用-lottie"><a href="#weex-rax-中使用-lottie" class="headerlink" title="weex/rax 中使用 lottie"></a>weex/rax 中使用 lottie</h2><p>weex/rax 已经提供了 lottie 组件，由于是内部文档，暂不放链接。</p><p>api 支持没有 airbnb 官方完整，投入生产环境时还需要严格测试一下</p><p><a href="http://dotwe.org/vue/946e8283f5cf31cfab2f923ec8cea07c" target="_blank" rel="noopener">vue-weex demo</a></p><p><img src="https://gw.alicdn.com/tfs/TB1h65XuCMmBKNjSZTEXXasKpXa-256-256.png" alt></p><p>使用<a href="http://web.npm.alibaba-inc.com/package/@ali/rax-lottie" target="_blank" rel="noopener">@ali/rax-lottie</a> 的 <a href="https://market.m.taobao.com/app/tmall-wireless/rax-life-progress/pages/my-lottie?wh_weex=true" target="_blank" rel="noopener">rax demo</a> 如下</p><p><a href="https://market.m.taobao.com/app/tmall-wireless/rax-life-progress/pages/my-lottie?wh_weex=true" target="_blank" rel="noopener"><img src="https://gw.alicdn.com/tfs/TB16qbPuBjTBKNjSZFwXXcG4XXa-200-200.png" alt></a></p><video src="http://cloud.video.taobao.com//play/u/4121310810/p/1/e/6/t/1/50255438306.mp4" autoplay controls preload loop muted width="300px"></video><iframe width="375px" height="200px" src="https://market.m.taobao.com/app/tmall-wireless/rax-life-progress/pages/my-lottie?wh_weex=true" frameborder="0"></iframe><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在我看来，追求更精细完美的动画体验一直是设计师和前端开发的使命。lottie 的出现可以替代传统的 gif，并且提供的 api 可以更好的控制动画。lottie 可能不适合用于过于复杂的大场景动画，但是局部的小动画，再适合不过了。</p><p>lottie 应该是一个发展趋势，甚至未来浏览器说不定就原生直接支持了这种 json 动画，设计和开发之间的壁垒也会越来越小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://gw.alicdn.com/tfs/TB1yLBduDqWBKNjSZFAXXanSpXa-800-600.gif&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qccs.github.io/categories/JavaScript/"/>
    
    
      <category term="动画 CSS airbnb lottie JavaScript" scheme="https://qccs.github.io/tags/%E5%8A%A8%E7%94%BB-CSS-airbnb-lottie-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2013-12-02-%E4%B8%80%E4%BA%9BJS%E9%A2%98%E7%9B%AE%E7%9A%84%E8%A7%A3%E7%AD%94/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2013-12-02-一些JS题目的解答/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些JS题目的解答"><a href="#一些JS题目的解答" class="headerlink" title="一些JS题目的解答"></a>一些JS题目的解答</h1><p>在<a href="http://davidshariff.com/quiz/" target="_blank" rel="noopener">这里</a>看到一些测试题，我HTML和CSS比较一般，尝试把里面的JS题目都解答一下：</p><p>#1.<br>    “1” + 2 + “3” + 4</p><ul><li>10</li><li>1234</li><li>37</li></ul><p>答案：1234，加法优先级等同，从左往右，数字与字符串相加，数字转换成字符串进行运算，结果等同于：”12”+”3”+4 = “123”+4 = “1234”。<br><a id="more"></a></p><p>#2.</p><pre><code>4 + 3 + 2 + &quot;1&quot;</code></pre><ul><li>10</li><li>4321</li><li>91</li></ul><p>答案：91，优先级同上，从左往右，等同于：7+2+”1” = 9+”1” = “91”。</p><p>#3.<br>    var foo = 1;<br>    function bar() {<br>        foo = 10;<br>        return;<br>        function foo() {}<br>    }<br>    bar();<br>    alert(foo);</p><ul><li>1</li><li>10</li><li>Function</li><li>undefined</li><li>Error</li></ul><p>答案：1，function的定义会提前到当前作用域之前，所以等同于：</p><pre><code>var foo = 1;function bar() {    function foo() {}    foo = 10;    return;}bar();alert(foo);</code></pre><p>所以，在foo=10的时候，foo是有定义的，属于局部变量，影响不到外层的foo。</p><p>参见：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope</a></p><blockquote><p>Unlike functions defined by function expressions or by the Function constructor, a function defined by a function declaration can be used before the function declaration itself.</p></blockquote><p>#4.</p><pre><code>function bar() {    return foo;    foo = 10;    function foo() {}    var foo = 11;}alert(typeof bar());</code></pre><ul><li>number</li><li>function</li><li>undefined</li><li>Error</li></ul><p>答案：function，与上题类似，等同于：</p><pre><code>function bar() {    function foo() {}    return foo;    foo = 10;    var foo = 11;}alert(typeof bar());</code></pre><p>在return之后声明和赋值的foo都无效，所以返回了function。</p><p>参见：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return</a></p><blockquote><p>A function immediately stops at the point where return is called.</p></blockquote><p>补充，这个解答有问题：</p><blockquote><p>@尤里卡Eureka：JS中function声明和var声明都会被提前，最终得到结果为function，是因为<em>名称解析顺序-Name Resolution Order</em>(<a href="http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果" target="_blank" rel="noopener">http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果</a>~</p></blockquote><p>#5.</p><pre><code>var x = 3;var foo = {    x: 2,    baz: {        x: 1,        bar: function() {            return this.x;        }    }}var go = foo.baz.bar;alert(go());alert(foo.baz.bar());</code></pre><ul><li>1,2</li><li>1,3</li><li>2,1</li><li>2,3</li><li>3,1</li><li>3,2</li></ul><p>答案：3,1<br>this指向执行时刻的作用域，go的作用域是全局，所以相当于window，取到的就是window.x，也就是var x=3;这里定义的x。而foo.baz.bar()里面，this指向foo.baz，所以取到的是这个上面的x，也就是1。</p><p>参见：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FOperators%2Fthis" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FOperators%2Fthis</a></p><p>#6.</p><pre><code>var x = 4,    obj = {        x: 3,        bar: function() {            var x = 2;            setTimeout(function() {                var x = 1;                alert(this.x);            }, 1000);        }    };obj.bar();</code></pre><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>undefined</li></ul><p>答案：4，不管有这个setTimeout还是把这个函数立即执行，它里面这个function都是孤立的，this只能是全局的window，即使不延时，改成立即执行结果同样是4。</p><p>#7.</p><pre><code>x = 1;function bar() {    this.x = 2;    return x;}var foo = new bar();alert(foo.x);</code></pre><ul><li>1</li><li>2</li><li>undefined</li></ul><p>答案：2，这里主要问题是最外面x的定义，试试把x=1改成x={}，结果会不同的。这是为什么呢？在把函数当作构造器使用的时候，如果手动返回了一个值，要看这个值是否简单类型，如果是，等同于不写返回，如果不是简单类型，得到的就是手动返回的值。如果，不手动写返回值，就会默认从原型创建一个对象用于返回。</p><p>参见：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new</a></p><p>#8.</p><pre><code>function foo(a) {    alert(arguments.length);}foo(1, 2, 3);</code></pre><ul><li>1</li><li>2</li><li>3</li><li>undefined</li></ul><p>答案3，arguments取的是实参的个数，而foo.length取的是形参个数。</p><p>参见：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments/length?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments%2Flength" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments/length?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments%2Flength</a></p><blockquote><p>arguments.length provides the number of arguments actually passed to a function. This can be more or less than the defined parameter count (See Function.length).</p></blockquote><p>#9.</p><pre><code>var foo = function bar() {};alert(typeof bar);</code></pre><ul><li>function</li><li>object</li><li>undefined</li></ul><p>答案：undefined，这种情况下bar的名字从外部不可见，那是不是这个名字别人就没法知道了呢？不是，toString就可以看到它，比如说alert(foo)，可以看看能打出什么。</p><p>参见：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope</a></p><blockquote><p>The function name can be used only within the function’s body. Attempting to use it outside the function’s body results in an error (or undefined if the function name was previously declared via a var statement).</p></blockquote><p>#10.</p><pre><code>var arr = [];arr[0]  = &apos;a&apos;;arr[1]  = &apos;b&apos;;arr.foo = &apos;c&apos;;alert(arr.length);</code></pre><ul><li>1</li><li>2</li><li>3</li><li>undefined</li></ul><p>答案：2，数组的原型是Object，所以可以像其他类型一样附加属性，不影响其固有性质。</p><p>#11.</p><pre><code>function foo(a) {    arguments[0] = 2;    alert(a);}foo(1);</code></pre><ul><li>1</li><li>2</li><li>undefined</li></ul><p>答案：2，实参可以直接从arguments数组中修改。</p><p>参见：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments</a></p><blockquote><p>The arguments can also be set</p></blockquote><p>#12.</p><pre><code>function foo(){}delete foo.length;alert(typeof foo.length);</code></pre><ul><li>number</li><li>undefined</li><li>object</li><li>Error</li></ul><p>答案：number，foo.length是无法删除的，它在Function原型上，重点它的configurable是false。</p><p>参见：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete</a></p><blockquote><p>delete can’t remove certain properties of predefined objects (like Object, Array, Math etc). These are described in ECMAScript 5 and later as non-configurable</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一些JS题目的解答&quot;&gt;&lt;a href=&quot;#一些JS题目的解答&quot; class=&quot;headerlink&quot; title=&quot;一些JS题目的解答&quot;&gt;&lt;/a&gt;一些JS题目的解答&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;http://davidshariff.com/quiz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;看到一些测试题，我HTML和CSS比较一般，尝试把里面的JS题目都解答一下：&lt;/p&gt;
&lt;p&gt;#1.&lt;br&gt;    “1” + 2 + “3” + 4&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10&lt;/li&gt;
&lt;li&gt;1234&lt;/li&gt;
&lt;li&gt;37&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;答案：1234，加法优先级等同，从左往右，数字与字符串相加，数字转换成字符串进行运算，结果等同于：”12”+”3”+4 = “123”+4 = “1234”。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2014-10-01-From%20HTC%20to%20Web%20Components/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2014-10-01-From HTC to Web Components/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从HTML-Components的衰落看Web-Components的危机"><a href="#从HTML-Components的衰落看Web-Components的危机" class="headerlink" title="从HTML Components的衰落看Web Components的危机"></a>从HTML Components的衰落看Web Components的危机</h1><p>搞前端时间比较长的同学都会知道一个东西，那就是HTC（HTML Components），这个东西名字很现在流行的Web Components很像，但却是不同的两个东西，它们的思路有很多相似点，但是前者已是昨日黄花，后者方兴未艾，是什么造成了它们的这种差距呢？</p><h2 id="HTML-Components的一些特性"><a href="#HTML-Components的一些特性" class="headerlink" title="HTML Components的一些特性"></a>HTML Components的一些特性</h2><p>因为主流浏览器里面只有IE支持过HTC，所以很多人潜意识都认为它不标准，但其实它也是有标准文档的，而且到现在还有链接，注意它的时间！</p><p><a href="http://www.w3.org/TR/NOTE-HTMLComponents" title="HTML Components" target="_blank" rel="noopener">http://www.w3.org/TR/NOTE-HTMLComponents</a></p><p>我们来看看它主要能做什么呢？</p><p>它可以以两种方式被引入到HTML页面中，一种是作为“行为”被附加到元素，使用CSS引入，一种是作为“组件”，扩展HTML的标签体系。</p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>行为（Behavior）是在IE5中引入的一个概念，主要是为了做文档结构和行为的分离，把行为通过类似样式的方式隔离出去，详细介绍在这里可以看：</p><p><a href="http://msdn.microsoft.com/en-us/library/ms531079(v=vs.85" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/ms531079(v=vs.85).aspx</a>.aspx)</p><p>行为里可以引入HTC文件，刚才的HTC规范里就有，我们把它摘录出来，能看得清楚一些：</p><p><em>engine.htc</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span> <span class="attr">xmlns:PUBLIC</span>=<span class="string">"urn:HTMLComponent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PUBLIC:EVENT</span> <span class="attr">NAME</span>=<span class="string">"onResultChange"</span> <span class="attr">ID</span>=<span class="string">"eventOnResultChange"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">LANGUAGE</span>=<span class="string">"JScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doCalc</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="undefined">   :</span></span><br><span class="line"><span class="undefined">   oEvent = createEventObject();</span></span><br><span class="line"><span class="undefined">   oEvent.result = sResult;</span></span><br><span class="line"><span class="undefined">   eventOnResultChange.fire (oEvent);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span> <span class="attr">xmlns:LK</span>=<span class="string">"urn:com.microsoft.htc.samples.calc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">   <span class="selector-tag">LK</span>\<span class="selector-pseudo">:CALC</span>    &#123; <span class="attribute">behavior</span>:<span class="built_in">url</span>(engine.htc); &#125; </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LK:CALC</span> <span class="attr">ID</span>=<span class="string">"myCalc"</span> <span class="attr">onResultChange</span>=<span class="string">"resultWindow.innerText=window.event.result"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TABLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">ID</span>=<span class="string">"resultWindow"</span> <span class="attr">STYLE</span>=<span class="string">"border: '.025cm solid gray'"</span> <span class="attr">ALIGN</span>=<span class="string">RIGHT</span>&gt;</span>0.<span class="tag">&lt;/<span class="name">DIV</span>&gt;</span><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 7 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 8 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 9 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" / "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" C "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 4 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 5 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 6 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" * "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" % "</span> <span class="attr">DISABLED</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 1 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 2 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 3 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" - "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">"1/x"</span> <span class="attr">DISABLED</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span><span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" 0 "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">"+/-"</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" . "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" + "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">BUTTON</span> <span class="attr">VALUE</span>=<span class="string">" = "</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">TABLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LK:CALC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个计算器的例子，我们先大致看一下代码结构，是不是很清晰？再看看现在用jQuery，我们是怎么实现这种东西的：是用选择器选择这些按钮，然后添加事件处理函数。注意你多了一步选择的过程，而且，整个过程混杂了声明式和命令式两种代码风格。如果按照它这样，你所有的JS基本都丢在了隔离的不相关的文件中，整个是一个配置的过程，分离得很干净。</p><p>除了这种计算器，还有规范文档中举例的改变界面展示，或者添加动画之类，注意它们的切入点，都是相当于附加在特定选中元素上的行为，即使DOM不给JS暴露任何选择器，也毫无影响，因为它们直接就通过CSS的选择器挂到元素上了。</p><p>这种在现在看来，意义不算明显，现在广为使用的先选择元素再添加事件，也是不错的展现和行为分离方式。</p><p>但另外一种使用方式就不同了。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>狭义的HTML5给我们带来了什么？是很多新增的元素标签，比如section，nav，acticle，那这些东西跟原先直接用div实现的，好处在哪里呢？在于语义化。</p><p>所谓语义化，就是一个元素能清晰表达自己是干什么的，不会让人有歧义，像div那种，可以类比成是一个Object，它不具体表示什么东西，但可以当成各种东西来用。而nav一写，就知道，它是导航，它就像有class定义的一个实体类，能表达具体含义。</p><p>那么，原有的HTML元素显然是不够的，因为实际开发过程中要表达的东西显然远远超出这些元素，比如日历，这种东西就没有一个元素用来描述它，更不用说在一些企业应用中可能会出现的树之类复杂控件了。</p><p>不提供原生元素，对开发造成的困扰是代码写起来麻烦，具体可以看之前我在知乎的一个回复，第三点：</p><p><a href="http://www.zhihu.com/question/22426434/answer/21433867" target="_blank" rel="noopener">http://www.zhihu.com/question/22426434/answer/21433867</a></p><p>所以，大家都想办法去提供自己的扩充元素的方式，现在我们是知道典型的有angularjs，polymer，但很早的时候也不是没有啊：</p><p><a href="http://msdn.microsoft.com/en-us/library/ms531076(v=vs.85" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/ms531076(v=vs.85).aspx</a>.aspx)</p><p>看，这就是HTC的添加自定义元素的方式，每个元素可以定义自己对外提供的属性、方法，还有事件，自己内部可以像写一个新页面一样，专注于实现功能。而且你发现没有，它考虑得很长远，提供了命名空间，防止你在一个页面引入两个不同组织提供的同名自定义元素。</p><p>这个东西就可以称为组件了，它跟外界是完全隔离的，外界只要把它拿来就可以用，就像用原生元素一样，用选择器选择，设置属性，调用方法，添加事件处理等等，而且，注意到没有，它的属性是带get和set的，这是多么梦寐以求的东西！</p><p>正是因为它这么好用，所以在那个时代，我们用它干了很多东西，封装了各种基础控件，比如树，数据表格，日期选择，等等，甚至当时也有人嫌弃浏览器原生select和radio不好看，用这么个东西，里面封装了图片来模拟功能，替换原生的来用。</p><p>当时也有人，比如我在04年就想过，能不能把这些扩大化，扩展到除了基础控件之外的地方，把业务的组件也这么搞一下，一切皆组件，多好？</p><p>但有些事情我直到后来很久以后才想明白，基于业务的端到端组件虽然写起来很方便，却是有致命缺陷的。</p><p>到这里为止，对HTML Components的回顾告一段落，也不讨论它为什么就没了之类，这里面争议太大，我只想谈谈从这里面，能看到Web Components这么个大家寄予厚望的新标准需要面对一些什么问题。</p><h2 id="Web-Components的挑战"><a href="#Web-Components的挑战" class="headerlink" title="Web Components的挑战"></a>Web Components的挑战</h2><p>以下逐条列出，挨个说明，有的已经有了，有的差一些，有的没有，不管这么多，总之谈谈我心目中的这个东西应当是怎样的。</p><h3 id="自定义元素标签支持命名空间"><a href="#自定义元素标签支持命名空间" class="headerlink" title="自定义元素标签支持命名空间"></a>自定义元素标签支持命名空间</h3><p>原因我前面已经说了，可能会有不同组织实现同类功能的组件，存在于同一个页面内，引起命名歧义，所以我想了很久，还是觉得有前缀比较好：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yours:ComponentA</span>&gt;</span><span class="tag">&lt;/<span class="name">yours:ComponentA</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">his:ComponentA</span>&gt;</span><span class="tag">&lt;/<span class="name">his:ComponentA</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至，这里的前缀还可以是个简称别名，比如yours=com.aaa.productA，这可能只有复杂到一定程度才会出现，大家不要以为这太夸张，但总有一天Web体系能构建超大型软件，到那时候你就知道是不是可能了。</p><h3 id="样式的局部作用域"><a href="#样式的局部作用域" class="headerlink" title="样式的局部作用域"></a>样式的局部作用域</h3><p>这个前一段时间有的浏览器实现过，在组件内部，style上加一个scoped属性，这是正确的方向。为什么要这么干呢，所谓组件，引入成本越小越好，在无约定的情况下都能引入，不造成问题，那是最佳的结果。</p><p>如果你一个组件的样式不是局部的，很可能就跟主界面的冲突了，就算你不跟主界面的冲突，怎么保证不跟主界面中包含的其他组件的样式冲突？靠命名约定是不现实的，看长远一些，等你的系统够大，这就是大问题了。</p><h3 id="跟主文档的通讯"><a href="#跟主文档的通讯" class="headerlink" title="跟主文档的通讯"></a>跟主文档的通讯</h3><p>一个自定义组件，应当能够跟主文档进行通讯，这个过程包括两个方向，分别可以有多种不同的方式。</p><h4 id="从内向外"><a href="#从内向外" class="headerlink" title="从内向外"></a>从内向外</h4><p>除了事件，真没有什么好办法可以做这个方向的通讯，但事件也可以有两种定义方式，一种是类似onclick那种，主文档应当能够在它上面直接添加对应的事件监听函数，就像对原生元素那样，每个事件都能单独使用。另一种是像postMessage那样，只提供一个通道，具体怎么处理，自己去定义消息格式和处理方式。</p><p>这两种实现方式都可行，后者比较偷懒，但也够用了，前者也没有明显优势。</p><h4 id="从外向内"><a href="#从外向内" class="headerlink" title="从外向内"></a>从外向内</h4><p>这个也可以有两种方式，一种是组件对外暴露属性或者方法，让主文档调用，一种是外部也通过postMessage往里传。前者用起来会比较方便，后者也能凑合用用。</p><p>所以，如果特别偷懒，这个组件就变得像一个iframe那样，跟外部基本都通过postMessage交互。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>写到这里我是很纠结的，因为终于来到争议最大的地方了。按照很多人的思路，我这里应该也写隔离成局部作用域的JavaScript才对，但真不行，我们可以先假设组件内部的所有JavaScript都跑在局部作用域，它不能访问主文档中的对象。</p><p>我这里解释一下之前那个坑，为什么端到端组件是有缺陷的。</p><p>先解释什么叫端到端组件。比如说，我有这么一个组件，它封装了对后端某接口的调用，还有自身的一些展示处理，跟外界通过事件通信。它整个是不需要依赖别人的，初始加载数据都是自己内部做，别人要用它也很简单，直接拿来放在页面里就可以了。</p><p>照理说，这东西应当非常好才对，使用起来这么方便，到底哪里不对？我来举个场景。</p><p>在页面上同时存在这个组件的多个实例，每个组件都去加载了初始数据，假设它们是不带参数的，每个组件加载的数据都一样，这里是不是就有浪费的请求了？有人可能觉得一点点浪费不算问题，那么继续。</p><p>假设这个组件就是一个很普通的下拉列表，用于选取人员的职业，初始可能有医生，教师，警察等等，我把这个组件直接放在界面上，它一出现，就自己去加载了所需的列表信息并且展示了。有另外一个配置界面，用于配置这些职业信息，这时候我在里面添加了一个护士，并且提交了。假设为了数据一致性，我们把这个变更推回到页面，麻烦就出现了。</p><p>界面只有一个职业下拉列表的时候可能还好办，有多个的时候，这个更新的策略就有问题了。</p><p>如果在组件的内部做这个推送的对接，就会出现要推送多份一致的数据给组件的不同实例的问题。如果把这个放在外面，那我们也有两种方式：</p><ul><li>订阅发布模式，组件订阅某个数据源，数据源跟服务端对接，当数据变更的时候，发给每个订阅者</li><li>观察者模式，组件观察某个数据源，当数据变更的时候，去取回来</li></ul><p>这两种很类似，不管哪种，都面临一个问题：</p><p>数据源放在哪？</p><p>很明显不能放在组件内部了，只能放在某个“全局”的地方，但刚才我们假设的是，组件内部的JavaScript代码不能访问外界的对象，所以……</p><p>但要是让它能访问，组件的隔离机制等于白搭。最好的方式，也许是两种都支持，默认是局部作用域，另外专门有一个作用域放给JS框架之类的东西用，但浏览器实现的难度可能就大了不少。</p><p>可能有人会说，你怎么把问题搞这么复杂，用这么BT的场景来给我们美好的未来出难题。我觉得问题总是要面对的，能在做出来之前就面对问题，结果应该会好一些。</p><p>我注意观察了很多朋友对Web Components的态度，大部分都是完全叫好，但其中有一部分，主要是搞前端MV*的同学对它的态度很保守，主要原因应该是我说的这几点。因为这个群体主要都在做单页型的应用，这个里面会遇到的问题是跟传统前端不同的。</p><p>那么，比如Angular，或者React，它们跟Web Components的协作点在哪里呢？我个人觉得是把引擎保留下来，上层部分逐步跟Web Components融合，所以它们不是谁吃掉谁的问题，而是怎样去融合。最终就是在前端有两层，一层是数据和业务逻辑层，一层是偏UI的，在那个层里面，可以存在像Web Components那样的垂直切分，这样会很适宜。</p><p>最后说说自己对Polymer的意见，我的看法没有@司徒正美 那么粗暴，但我是认同他的观点的，因为Polymer的根本理念就是在做端到端组件，它会面临很多的挑战。虽然它是一个组件化框架，组件化最适宜于解决大规模协作问题，但是如果是以走向大型单页应用这条路来看，它比Angular和React离目标的距离还远很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从HTML-Components的衰落看Web-Components的危机&quot;&gt;&lt;a href=&quot;#从HTML-Components的衰落看Web-Components的危机&quot; class=&quot;headerlink&quot; title=&quot;从HTML Components的衰
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2014-10-04-to-be-a-fe/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2014-10-04-to-be-a-fe/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给一位打算从事前端，但是又有疑惑的在校大学生的回信"><a href="#给一位打算从事前端，但是又有疑惑的在校大学生的回信" class="headerlink" title="给一位打算从事前端，但是又有疑惑的在校大学生的回信"></a>给一位打算从事前端，但是又有疑惑的在校大学生的回信</h1><p>抱歉这么晚才回复这个邮件，主要是觉得你的问题有典型性，想要详细一点给出答复。</p><p>所谓的前端，在不同的公司，定义是不同的，工作内容也会有差异，有的还很大。比如有很多公司，没有专门的前端分类，所有的都属于开发人员，一些比较传统的公司，还有一些人数较少的小公司会是这样。又比如有些公司，前端人员的职责仅限于静态页面和交互效果，然后把这些东西交给业务开发人员去编写业务的JS代码。还有一些公司，前端除了PC和移动端的Web，还包括各种移动终端的开发。</p><p>这些种种不同，都是各公司自身的业务特点决定的，大体上比较适合各自的业务场景，越大的公司，内部的分工可能越明确，所以也就有了你看到的，有比较偏向JS的，有比较偏向CSS的。</p><p>个人选择什么方向，我觉得需要问自己两个问题：</p><ol><li>你是一个怎样的人</li></ol><p>这个的意思是，你觉得自己学js和css的时候，哪种觉得更轻松愉快，容易领悟。一个人选择自己最容易领悟的方面去学习，会事半功倍。</p><ol start="2"><li>你希望成为一个怎样的人</li></ol><p>人的一生，实际上很大程度是职业细分的过程，每个人在他工作的前10年，都可能会逐步深入到某些领域，他的知识广度可能会逐步增加，但能够深入的，往往在一两个分支上。</p><p>从大的方面看，最初的软件体系基本都是以服务端为主，客户端通过字符界面去进行操作，后来桌面程序迅速发展，再后来Web兴起，最近各种终端的流行，更加促使广义的“前端”这个领域有更多的发挥空间。整体来说，后端的发展趋势是服务化，前端的发展趋势是多样化。因为消费者的促进，前端的需求和发展会是非常乐观的，无论在其中选择哪个细分方向，只要努力下去，成为这个领域的专家，肯定都会有所成就。</p><p>目前，在很多公司，搞CSS一般还没有独立职位，或者即使有，暂时比搞JS的还是稍微弱势一些，正如前端部门一般比后端部门弱势，但这种状况会好转的，每个领域都会得到适合自己的发挥。</p><p>关于原生JS和某些库的学习，我的观点是这样，除了一些很特别很怪异的点，对于语言本身的常规用法是需要都掌握的，其实也不多，常用到的就那么些。一般说的原生JS，是包括JS语言本身，还有它对DOM和BOM的操作，比如元素的创建移除，事件的添加等等，这些应该都需要懂。至于说对于某个库的学习，更重要的是学习它的思维方式，每看一个例子，就先想一想如果自己写，会把代码写成怎样，再与真实的例子进行对照，举一反三，这样的学习会是很快的过程。</p><p>现在这个时代，各种浏览器还在混战，但低版本IE的淘汰已经成为了必然，如果是现在开始学习，一定要着眼于将来，多看看CSS3各子集的规范，了解ES新版本的特性，因为世界迟早是它们的。对于低版本浏览器的兼容，一般都会有成熟的解决方案，当遇到具体问题的时候再去看也可以。</p><p>很多人看待前端，是把它当作一个很浅的层面来看的，其实前端的人多了解一些别的领域也是有好处的，从中能得到很多领悟，比如软件工程，设计模式，它们对不管什么方面的开发人员而言，都是很好的指导。</p><p>一个成熟的前端开发人员，他应当有比较宽的知识面，同时至少在某一两个细分领域有专注的研究和见解。平时在日常生活中，也可以多注意观察一些产品，对自己正在做的整个产品有深刻认识，对生活常识有充分了解，有时候也会有助于减少开发过程中走的弯路。</p><p>能够对自己的未来有所预期，并且主动寻找学习的途径，这说明你有很好的开始，在前端这条道路上认真走下去，相信会有美好的未来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;给一位打算从事前端，但是又有疑惑的在校大学生的回信&quot;&gt;&lt;a href=&quot;#给一位打算从事前端，但是又有疑惑的在校大学生的回信&quot; class=&quot;headerlink&quot; title=&quot;给一位打算从事前端，但是又有疑惑的在校大学生的回信&quot;&gt;&lt;/a&gt;给一位打算从事前端，但
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2014-10-21-build-single-page-application/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2014-10-21-build-single-page-application/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建单页Web应用"><a href="#构建单页Web应用" class="headerlink" title="构建单页Web应用"></a>构建单页Web应用</h1><h2 id="单页应用是什么？"><a href="#单页应用是什么？" class="headerlink" title="单页应用是什么？"></a>单页应用是什么？</h2><p>让我们先来看几个网站：</p><p><a href="https://coding.net/" target="_blank" rel="noopener">coding</a></p><p><a href="https://www.teambition.com/" target="_blank" rel="noopener">teambition</a></p><p><a href="https://c9.io/" target="_blank" rel="noopener">cloud9</a></p><p>注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。</p><p>所谓单页应用，指的是在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。它是AJAX技术的进一步升华，把AJAX的无刷新机制发挥到极致，因此能造就与桌面程序媲美的流畅用户体验。</p><p>其实单页应用我们并不陌生，很多人写过ExtJS的项目，用它实现的系统，很天然的就已经是单页的了，也有人用jQuery或者其他框架实现过类似的东西。用各种JS框架，甚至不用框架，都是可以实现单页应用的，它只是一种理念。有些框架适用于开发这种系统，如果使用它们，可以得到很多便利。</p><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成整个前端部分，甚至包括布局。随着功能逐渐增加，ExtJS的体积也逐渐增大，即使用于内部系统的开发，有时候也显得笨重了，更不用说开发以上这类运行在互联网上的系统。</p><p>jQuery由于偏重DOM操作，它的插件体系又比较松散，所以比ExtJS这个体系更适合开发在公网运行的单页系统，整个解决方案会相对比较轻量、灵活。</p><p>但由于jQuery主要面向上层操作，它对代码的组织是缺乏约束的。如何在代码急剧膨胀的情况下控制每个模块的内聚性，并且适当在模块之间产生数据传递与共享，就成为了一种有挑战的事情。</p><p>为了解决单页应用规模增大时候的代码逻辑问题，出现了不少MV*框架，他们的基本思路都是在JS层创建模块分层和通信机制。有的是MVC，有的是MVP，有的是MVVM，而且，它们几乎都在这些模式上产生了变异，以适应前端开发的特点。</p><p>这类框架包括Backbone，Knockout，AngularJS，Avalon等。</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>这些在前端做分层的框架推动了代码的组件化，所谓组件化，在传统的Web产品中，更多的指UI组件，但其实组件是一个广泛概念，传统Web产品中UI组件占比高的原因是它的厚度不足，随着客户端代码比例的增加，相当一部分的业务逻辑也前端化，由此催生了很多非界面型组件的出现。</p><p>分层带来的一个优势是，每层的职责更专一了，由此，可以对其作单元测试的覆盖，以保证其质量。传统UI层测试最头疼的问题是UI层和逻辑混杂在一起，比如往往会在远程请求的回调中更改DOM，当引入分层之后，这些东西都可以分别被测试，然后再通过场景测试来保证整体流程。</p><h2 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h2><p>与开发传统页面型网站相比，实现单页应用的过程中，有一些比较值得特别关注的点。</p><p>从单页应用的特点来看，它比页面型网站更加依赖于JavaScript，而由于页面的单页化，各种子功能的JavaScript代码聚集到了同一个作用域，所以代码的隔离、模块化变得很重要。</p><p>在单页应用中，页面模板的使用是很普遍的。很多框架内置了特定的模板，也有的框架需要引入第三方的模板。这种模板是界面片段，我们可以把它们类比成JavaScript模块，它们是另一种类型的组件。</p><p>模板也一样有隔离的需要。不隔离模板，会造成什么问题呢？模板间的冲突主要存在于id属性上，如果一个模板中包含固定的id，当它被批量渲染的时候，会造成同一个页面的作用域中出现多个相同id的元素，产生不可预测的后果。因此，我们需要在模板中避免使用id，如果有对DOM的访问需求，应当通过其他选择器来完成。如果一个单页应用的组件化程度非常高，很可能整个应用中都没有元素id的使用。</p><h2 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h2><p>人们对于单页系统的加载时间容忍度与Web页面不同，如果说他们愿意为购物页面的加载等待3秒，有可能会愿意为单页应用的首次加载等待5-10秒，但在此之后，各种功能的使用应当都比较流畅，所有子功能页面尽量要在1-2秒时间内切换成功，否则他们就会感觉这个系统很慢。</p><p>从这些特点来看，我们可以把更多的公共功能放到首次加载，以减小每次加载的载入量，有一些站点甚至把所有的界面和逻辑全部放到首页加载，每次业务界面切换的时候，只产生数据请求，因此它的响应是非常迅速的，比如青云的控制台就是这么做的。</p><p>通常在单页应用中，无需像网站型产品一样，为了防止文件加载阻塞渲染，把js放到html后面加载，因为它的界面基本都是动态生成的。</p><p>当切换功能的时候，除了产生数据请求，还需要渲染界面，这个新渲染的界面部件一般是界面模板，它从哪里来呢？来源无非是两种，一种是即时请求，像请求数据那样通过AJAX获取过来，另一种是内置于主界面的某些位置，比如script标签或者不可见的textarea中，后者在切换功能的时候速度有优势，但是加重了主页面的负担。</p><p>在传统的页面型网站中，页面之间是互相隔离的，因此，如果在页面间存在可复用的代码，一般是提取成单独的文件，并且可能会需要按照每个页面的需求去进行合并。单页应用中，如果总的代码量不大，可以整体打包一次在首页载入，如果大到一定规模，再作运行时加载，加载的粒度可以搞得比较大，不同的块之间没有重复部分。</p><h2 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h2><p>我们最开始看到的几个在线应用，有的是对路由作了管理的，有的没有。</p><p>管理路由的目的是什么呢？是为了能减少用户的导航成本。比如说我们有一个功能，经历过多次导航菜单的点击，才呈现出来。如果用户想要把这个功能地址分享给别人，他怎么才能做到呢？</p><p>传统的页面型产品是不存在这个问题的，因为它就是以页面为单位的，也有的时候，服务端路由处理了这一切。但是在单页应用中，这成为了问题，因为我们只有一个页面，界面上的各种功能区块是动态生成的。所以我们要通过对路由的管理，来实现这样的功能。</p><p>具体的做法就是把产品功能划分为若干状态，每个状态映射到相应的路由，然后通过pushState这样的机制，动态解析路由，使之与功能界面匹配。</p><p>有了路由之后，我们的单页面产品就可以前进后退，就像是在不同页面之间一样。</p><p>其实在Web产品之外，早就有了管理路由的技术方案，Adobe Flex中，就会把比如TabNavigator，甚至下拉框的选中状态对应到url上，因为它也是单“页面”的产品模式，需要面对同样的问题。</p><p>当产品状态复杂到一定程度的时候，路由又变得很难应用了，因为状态的管理极其麻烦，比如开始的时候我们演示的c9.io在线IDE，它就没法把状态对应到url上。</p><h2 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h2><p>在单页应用的运作机制中，缓存是一个很重要的环节。</p><p>由于这类系统的前端部分几乎全是静态文件，所以它能够有机会利用浏览器的缓存机制，而比如动态加载的界面模板，也完全可以做一些自定义的缓存机制，在非首次的请求中直接取缓存的版本，以加快加载速度。</p><p>甚至，也出现了一些方案，在动态加载JavaScript代码的同时，把它们也缓存起来。比如Addy Osmani的这个<a href="https://github.com/addyosmani/basket.js" target="_blank" rel="noopener">basket.js</a>，就利用了HTML5 localStorage作了js和css文件的缓存。</p><p>在单页产品中，业务代码也常常会需要跟本地存储打交道，存储一些临时数据，可以使用<a href="https://github.com/mortzdk/localStorage" target="_blank" rel="noopener">localStorage</a>或者<a href="https://github.com/knadh/localStorageDB" target="_blank" rel="noopener">localStorageDB</a>来简化自己的业务代码。</p><h2 id="服务端通信"><a href="#服务端通信" class="headerlink" title="服务端通信"></a>服务端通信</h2><p>传统的Web产品通常使用JSONP或者AJAX这样的方式与服务端通信，但在单页Web应用中，有很大一部分采用WebSocket这样的实时通讯方式。</p><p>WebSocket与传统基于HTTP的通信机制相比，有很大的优势。它可以让服务端很便利地使用反向推送，前端只响应确实产生业务数据的事件，减少一遍又一遍无意义的AJAX轮询。</p><p>由于WebSocket只在比较先进的浏览器上被支持，有一些库提供了在不同浏览器中的兼容方案，比如socket.io，它在不支持WebSocket的浏览器上会降级成使用AJAX或JSONP等方式，对业务代码完全透明、兼容。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>传统的Web页面一般是不需要考虑内存的管理的，因为用户的停留时间相对少，即使出现内存泄漏，可能很快就被刷新页面之类的操作冲掉了，但单页应用是不同的，它的用户很可能会把它开一整天，因此，我们需要对其中的DOM操作、网络连接等部分格外小心。</p><h2 id="样式的规划"><a href="#样式的规划" class="headerlink" title="样式的规划"></a>样式的规划</h2><p>在单页应用中，因为页面的集成度高，所有页面聚集到同一作用域，样式的规划也变得重要了。</p><p>样式规划主要是几个方面：</p><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>这里面主要包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式支持。</p><h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>这里面是两个层面的规划，首先是各种界面组件及其子元素的样式，其次是一些修饰样式。组件样式应当尽量减少互相依赖，各组件的样式允许冗余。</p><h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>传统Web页面的特点是元素多，但是层次少，单页应用会有些不同。</p><p>在单页应用中，需要提前为各种UI组件规划堆叠次序，也就是z-index，比如说，我们可能会有各种弹出对话框，浮动层，它们可能组合成各种堆叠状态。新的对话框的z-index需要比旧的高，才能确保盖在它上面。诸如此类，都需要我们对这些可能的遮盖作规划，那么，怎样去规划呢？</p><p>了解通信知识的人，应当会知道，不同的频率段被划分给不同的通信方式使用，在一些国家，领空的使用也是有划分的，我们也可以用同样的方式来预先分段，不同类型的组件的z-index落到各自的区间，以避免它们的冲突。</p><h2 id="单页应用的产品形态"><a href="#单页应用的产品形态" class="headerlink" title="单页应用的产品形态"></a>单页应用的产品形态</h2><p>我们在开始的时候提到，存在着很多新型Web产品，使用单页应用的方式构建，但实际上，这类产品不仅仅存在于Web上。点开Chrome商店，我们会发现很多离线应用，这些产品都可以算是单页应用的体现。</p><p>除了各种浏览器插件，借助node-webkit这样的外壳平台，我们可以使用Web技术来构建本地应用，产品的主要部分仍然是我们熟悉的单页应用。</p><p>单页应用的流行程度正在逐渐增加，大家如果关注了一些初创型互联网企业，会发现其中很大一部分的产品模式是单页化的。这种模式能带给用户流畅的体验，在开发阶段，对JavaScript技能水平要求较高。</p><p>单页应用开发过程中，前后端是天然分离的，双方以API为分界。前端作为服务的消费者，后端作为服务的提供者。在此模式下，前端将会推动后端的服务化。当后端不再承担模板渲染、输出页面这样工作的情况下，它可以更专注于所提供的API的实现，而在这样的情况下，Web前端与各种移动终端的地位对等，也逐渐使得后端API不必再为每个端作差异化设计了。</p><h2 id="部署模式的改变"><a href="#部署模式的改变" class="headerlink" title="部署模式的改变"></a>部署模式的改变</h2><p>在现在这个时代，我们已经可以看到一种产品的出现了，那就是“无后端”的Web应用。这是一种什么东西呢？基于这种理念，你的产品很可能只需要自己编写静态Web页面，在某种BaaS（Backend as a Service）云平台上定制服务端API和云存储，集成这个平台提供的SDK，通过AJAX等方式与之打交道，实现注册认证、社交、消息推送、实时通信、云存储等功能。</p><p>我们观察一下这种模式，会发现前后端的部署已经完全分离了，前端代码完全静态化，这意味着可以把它们放置到CDN上，访问将大大地加速，而服务端托管在BaaS云上，开发者也不必去关注一些部署方面的繁琐细节。</p><p>假设你是一名创业者，正在做的是一种实时协同的单页产品，可以在云平台上，快速定制后端服务，把绝大部分宝贵的时间花在开发产品本身上。</p><h2 id="单页应用的缺陷"><a href="#单页应用的缺陷" class="headerlink" title="单页应用的缺陷"></a>单页应用的缺陷</h2><p>单页应用最根本的缺陷就是不利于SEO，因为界面的绝大部分都是动态生成的，所以搜索引擎很不容易索引它。</p><h2 id="产品单页化带来的挑战"><a href="#产品单页化带来的挑战" class="headerlink" title="产品单页化带来的挑战"></a>产品单页化带来的挑战</h2><p>一个产品想要单页化，首先是它必须适合单页的形态。其次，在这个过程中，对开发模式会产生一些变更，对开发技能也会有一些要求。</p><p>开发者的JavaScript技能必须过关，同时需要对组件化、设计模式有所认识，他所面对的不再是一个简单的页面，而是一个运行在浏览器环境中的桌面软件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构建单页Web应用&quot;&gt;&lt;a href=&quot;#构建单页Web应用&quot; class=&quot;headerlink&quot; title=&quot;构建单页Web应用&quot;&gt;&lt;/a&gt;构建单页Web应用&lt;/h1&gt;&lt;h2 id=&quot;单页应用是什么？&quot;&gt;&lt;a href=&quot;#单页应用是什么？&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2013-10-22-%E5%89%8D%E7%AB%AFMV%E2%98%86%E6%A1%86%E6%9E%B6%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2013-10-22-前端MV☆框架的意义/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端MV-框架的意义"><a href="#前端MV-框架的意义" class="headerlink" title="前端MV*框架的意义"></a>前端MV*框架的意义</h1><p>经常有人质疑，在前端搞MV<em>有什么意义？也有人提出这样的疑问：以AngularJS，Knockout，BackBone为代表的MV</em>框架，它跟jQuery这样的框架有什么区别？我jQuery用得好好的，有什么必要再引入这种框架？</p><p>回答这些问题之前，先要理清一些历史，前端从什么时候开始有框架的？</p><p>早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，这个时期每个界面上只有很少的JavaScript逻辑，基本不太需要框架。随着AJAX的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了，以jQuery为代表，针对界面上常见的DOM操作，远程请求，数据处理等作了封装，也有专注于处理数据的Underscore，严格来说，这些都不能算框架，而是算库。</p><p>库和框架是有一些区别的：库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构。框架则是面向一个领域，提供一套解决方案，如果你用我，就得按照我的方式办事。按照这个定义，jQuery和Underscore都只能算是库，ExtJS和dojo算框架。</p><p>MV*框架又是为什么兴起的呢？它的出现，伴随着一些Web产品逐渐往应用方向发展，遇到了在C/S领域相同的问题：由于前端功能的增强、代码的膨胀，导致不得不做“前端的架构”这个事情了。<br><a id="more"></a><br>很多做后端开发的人对前端架构很不屑，认为前端只是很薄的一层东西，做架构干什么？什么，不但要搞架构，还要搞MVC？Java Struts的MVC中，整个前端都只能算是View而已，你还要在这个View里面划分模型和控制器等其他东西？他们中的多数对这个很不屑，但Web前端随着复杂度的增加，很多地方跟客户端已经没有本质区别了。</p><p>jQuery的思维方式是：以DOM操作为中心<br>MV*框架的思维方式是：以模型为中心，DOM操作只是附加</p><p>所以回到那个问题上，jQuery满足了你的业务需要，你还有什么必要引入MV*框架？</p><p>这个是要看产品类型的，如果是页面型产品，多数确实不太需要它，因为页面中的JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。</p><p>长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。在以往的经验里，他们是有做MVC的，也尝试做了一些界面组件，但做法比较过时，比如说使用JSF或者GWT这样的方式。</p><p>JSF的问题是什么？它的问题并不在于界面跟逻辑混合，所谓的纵向切分组件，Polymer这种纯前端框架也是这么切分的，它问题在于组件的生成和渲染不在同一个地方。所以，逻辑代码的位置很尴尬，如果这个界面简单还好说，复杂起来就很麻烦了，就是很多明明是前端逻辑代码，却需要通过后端去生成。</p><p>GWT这种方式相对要好一些，它的问题是留给UI调节的余地太小了，比较缺乏灵活性。</p><p>这类基于某种服务端技术的组件化方式有一些局限性，比如它较大程度限制了前端的发挥，在早一些的时候，这种方式可能还不错，但是现在随着时代发展，用户对前端用户体验要求越来越高，需要我们把很大一部分精力继续放回前端来。JSF等方案的另外一个问题是绑定了某种服务端环境，很难切换到另外一种后端上，如果碰上要用Hybird方式开发，想复用一些前端逻辑，几乎毫无可能。</p><p>那么，我们看看纯前端的框架，看看都是怎么解决这些问题的。以Google为例，它推出了两个框架，Polymer和Angular，而且处于并行发展的阶段，这两者理念还有不小的差别，给不少人带来了困惑。</p><p>Polymer切分组件的方式有点类似JSF，它跟HTML5标准中的Shadow DOM和Element有很大联系，这种切分组件的方式非常直观，每个组件都是端到端的，包含UI和逻辑，直接放置到某个界面上就能用，这种方式很容易被业务开发人员接受，但里面的时序比较难处理。</p><p>比如说，有两个组件，里面各包含一个下拉框，有数据的联动关系，因为它们处在两个不同的组件里，联动的处理代码就很难写，考虑到组件的特点，要尽量隐藏自己的内部实现，所以从外部获取组件内部的某个元素要绕一层，而组件不能依赖其他外部的东西，所以到最后只有通过事件去实现，这个联动代码写好了应当放在哪里，也是个大问题。我们的例子仅仅是这么简单，就要绕这么个大圈子才能保证时序，如果场景比较复杂，非常难以控制。</p><p>如果同样的组件在某个界面被复用多次，数据的一致性也很难保证，设想一下某个界面存在两个一样的下拉框，分别处于不同组件中，两者的数据都需要分别去加载，这个过程是有浪费的，更严重的是，如果这个下拉框对应的数据有更新，很难把每个实例都更新一遍，这个处理过程是非常麻烦的。</p><p>Angular框架处理问题的方式跟它有所不同，它是水平分层，所有这些数据访问逻辑都跟UI彻底分离，所以可以很轻松地把这个逻辑代码写出来，这么一来，前面所述端到端的组件就彻底退化，变成只有界面展现了。</p><p>看看刚才碰到的两个问题，第一个，模型代码按照业务领域进行划分，获取的数据放在两个不同的数组，然后通过双向绑定跟UI产生关联，如果UI上一个下拉框选中项发生变更，只需要监控这个取值项，然后更新另一个下拉框的取值列表即可，完全不需要绕弯子。即使这两个处于不同模型中，也可以用类似后端的方式，采用事件总线等机制去完成通信。</p><p>第二个更简单了，复用的组件其实只有UI，也就是说，只有UI是多实例的，模型其实只有一份，比如说一个地区的树形结构，即使一个界面上同时有维护和使用两种功能，都可以共享同一份模型，当维护这边对数据进行了更新，就实时反馈到模型中，然后由双向绑定再把这个模型同步到界面上的使用方去，整个过程清晰可控。</p><p>从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的MV<em>框架，这个状况会大有改观。MV</em>框架的理念是把前端按照职责分层，每一层都相对比较独立，有自己的价值，也有各自发挥的余地。</p><p>为什么多数做互联网前端开发的同学们感受不到MV*框架的重要性呢，因为在这个协作体系里，Model的这一块不够复杂，在传统软件领域，Model的部分是代码最多的，View的相对少一些，而互联网领域里，基本是相反的，所以Model这块沦为附加，如果主要在操作View和Controller，那当然jQuery这类框架比较好用了。</p><p>所以，经常看到有互联网产品的同学们讲前端MVC，但举例的时候，都比较牵强，很多时候，他们举出来的那个Model，其实都不能算真正的Model，而是在操作View的过程中一些辅助的模型，真正的Model是贯穿前后端的。</p><p>归根结底，前端MV*框架带来的是一整套工作流程的变更，后端工程师也可以编写前端的模型代码，把它跟后端彻底打通，交互工程师处理UI跟模型的互动关系，UI工作人员可以专注、无障碍地处理HTML源码，把它们以界面模版的形式提供给交互工程师。这一整套协作机制能够大大提高B/S架构系统的开发效率，如果再有外围的管控平台，生产效率将真正踏进工业化的阶段。</p><p>到这个阶段，前端开发人员的出路是什么呢？我认为有两种。拿服装行业来对比，如果你要的是普通的，就使用工业手段批量生产，使用MV*框架，做好架构和组件重用，做得快，细节不是很讲究。如果你想要更好的，有特色的，就需要名家设计，手工打造，非常精巧，高端大气上档次。所以，这也就代表着前端开发的两种发展方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端MV-框架的意义&quot;&gt;&lt;a href=&quot;#前端MV-框架的意义&quot; class=&quot;headerlink&quot; title=&quot;前端MV*框架的意义&quot;&gt;&lt;/a&gt;前端MV*框架的意义&lt;/h1&gt;&lt;p&gt;经常有人质疑，在前端搞MV&lt;em&gt;有什么意义？也有人提出这样的疑问：以AngularJS，Knockout，BackBone为代表的MV&lt;/em&gt;框架，它跟jQuery这样的框架有什么区别？我jQuery用得好好的，有什么必要再引入这种框架？&lt;/p&gt;
&lt;p&gt;回答这些问题之前，先要理清一些历史，前端从什么时候开始有框架的？&lt;/p&gt;
&lt;p&gt;早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，这个时期每个界面上只有很少的JavaScript逻辑，基本不太需要框架。随着AJAX的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了，以jQuery为代表，针对界面上常见的DOM操作，远程请求，数据处理等作了封装，也有专注于处理数据的Underscore，严格来说，这些都不能算框架，而是算库。&lt;/p&gt;
&lt;p&gt;库和框架是有一些区别的：库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构。框架则是面向一个领域，提供一套解决方案，如果你用我，就得按照我的方式办事。按照这个定义，jQuery和Underscore都只能算是库，ExtJS和dojo算框架。&lt;/p&gt;
&lt;p&gt;MV*框架又是为什么兴起的呢？它的出现，伴随着一些Web产品逐渐往应用方向发展，遇到了在C/S领域相同的问题：由于前端功能的增强、代码的膨胀，导致不得不做“前端的架构”这个事情了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2013-10-01-%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%9B%B0%E5%A2%83/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2013-10-01-企业软件领域前端开发的困境/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="企业软件领域前端开发的困境"><a href="#企业软件领域前端开发的困境" class="headerlink" title="企业软件领域前端开发的困境"></a>企业软件领域前端开发的困境</h1><p>前一段时间，看到阿里几位前端大师的讨论：<a href="https://github.com/lifesinger/lifesinger.github.com/issues/141" target="_blank" rel="noopener">阿里前端的困局与突围</a>，对这个职业的发展方向有一些思考，我上次跟winter和dh一起吃饭，也简单聊到这个话题。</p><p>winter问了一个问题，如果在互联网企业跟游戏开发的企业同时进行一次针对前端开发的大裁员，对这个企业的核心价值而言，哪种影响更大？</p><p>这个问题问得很有意思，在每个行业里，前端开发的侧重点是不一样的，重要性也有所不同，简单来说可以分为3个大类：互联网、企业应用、游戏，分别侧重于：交互、架构、算法。</p><p>在这三个大类里，互联网方向的前端开发最为正统，算是根正苗红，所以在这个领域的人，对标准研究得最为透彻，对交互理解得最为深刻，目前前端方向的高手大多集中在这个领域。这个领域的人最关注的问题是兼容性，对一些细节的优化把握得炉火纯青。因为这个领域的业务特点，前端做的事情过于扁平，整个可发挥的余地不够，虽然高手众多，但就像很多龙挤在浅水里，常常有无用武之地的感叹。刚才玉伯这篇文章，讲述的就是这个领域中前端的困惑。</p><p>企业应用方向的前端开发其实很多时候并不在意他们用的是Web还是其他类似技术，比如Flex，Silverlight等，对他们来说，即使是C/S的系统，也能够发挥出很大价值。这个领域的人最关注的问题是组件化和快速业务开发。<br><a id="more"></a><br>从企业软件的方向来说，它的业务是很丰富的，对各种前端技术的应用也都很广泛，一个大型的企业应用，几乎什么特性都能用上。相对于互联网系统，它的客户相对比较专业，可以排除一些低端过时的浏览器，所以少了很多兼容的负担，在框架选型上，也可以接受很复杂的框架，比如ExtJS、AngularJS等，因为他们的业务特性，往往需要很复杂框架的支持。</p><p>用我所在的电信行业软件举例，业务复杂度非常高，一套全业务系统会有两千左右的数据库表，两千个左右的业务菜单，其中有些业务界面的复杂度非常惊人，而且经常会根据需求有较大变动，性能也有较高要求。</p><p>理论上来说，前端在这个领域可以领悟到很多事情，但这个领域有个最大的问题，盈利太低，不足以支撑很深入的研究，另一个无奈的问题是，由于历史原因，前端开发人员在这个领域并不容易受到重视，比如说资深技术人员多数是做后端开发的，认为前端很小儿科，在应届生入职筛选的时候，也会把能力较高的弄去做后端开发，剩下的留给前端。这些原因，造成了企业应用的前端领域就像一个又大又深的湖，里面小鱼小虾众多，却很少有大鱼。</p><p>我在企业软件前端开发做了很多年，经常思考其中的一些问题，在这个领域做，总是有一种寂寞的感觉。我们这种行业，为了保证交付的及时，倾向于划分业务开发和技术平台开发，业务开发人员并不在难解决的问题上花时间，遇到问题的时候向技术平台团队寻求支持，把问题转移给更专业的人，避免耽误自己的交付时间，在他们开工之前，也由技术平台团队预先搭建框架，他们直接在这个上面以固定的模式进行开发。两个团队，前者的特点是多而泛，后者的特点是少而精。</p><p>这么做，效率比较高，但带来一个问题，业务开发团队的技术水平很难提升，因为他总是忙碌赶工，很少有时间去思考很多问题的前因后果，即使你帮他解决了问题，告诉他，他也不一定有心情去关注一遍，因为他确实很忙。可能有些有激情的人会自己花点时间研究一下，但多数人很难有这样的心境。</p><p>这就造成了业务开发团队和平台开发团队的技术实力严重脱节。从另外一个角度看，技术平台团队长期专门给别人解决问题，自己却很少全职参与某个业务项目的开发，他也很难有成就感。这还不是最大的问题，最大问题是，不管从哪个团队，都很难成长出能够设计最适合这些业务的前端架构的人，这恰恰是这个领域前端开发最重要的部分。</p><p>当出现各种新技术的时候，平台团队比较容易去快速跟进，但投入通常不会很大，当取得一些进展的时候，会逐步向业务开发团队推广，但这个推广的难度是很大的，因为人数的比例会比较大，当技术从一个人向三个人推进的时候，是相对还算容易的，如果从一个向十个或者二十个人去推进，难度就大多了。而由于传统企业盈利规模的限制，没办法在每个技术方向都有较大投入，所以往往就是一两个人去折腾，他们在探索的过程中遇到问题，是很难找到能够交流的人的，如果自己解决不了问题，就会持续苦闷，非常寂寞。前端这个领域更是如此，现在客户端技术这么多，各种终端，各种浏览器，各种前端框架，每个上面投入一个人，就已经是个很大团队了，这种模式很明显就碰到瓶颈了，因为它很直接地跟人员编制产生了冲突。扩编直接对利润产生冲击，但是不扩编的话，技术平台团队的压力就会进一步加大，除了要探索新技术，还要对越来越庞大的业务开发团队作技术支持，每个人都痛不欲生。</p><p>这种困境怎么解决呢，我想了很久，无计可施，也许，是时候要效仿互联网企业的开发模式了？但是积重难返，而且传统企业招聘的门槛远比互联网企业低，人员的能力有差距，也很难有互联网企业那么蓬勃而广泛的技术研究气氛，可能就更难做下去了。 </p><p>可能这个领域的出路是寻找更为简单快速的开发方式，并且把相关的外围工具也做大做强，在业务领域中，把组件也积累沉淀出来，这时候能够用更少的业务开发人员来实现同等规模的系统，把更多人力节约出来做技术探索和改进吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;企业软件领域前端开发的困境&quot;&gt;&lt;a href=&quot;#企业软件领域前端开发的困境&quot; class=&quot;headerlink&quot; title=&quot;企业软件领域前端开发的困境&quot;&gt;&lt;/a&gt;企业软件领域前端开发的困境&lt;/h1&gt;&lt;p&gt;前一段时间，看到阿里几位前端大师的讨论：&lt;a href=&quot;https://github.com/lifesinger/lifesinger.github.com/issues/141&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里前端的困局与突围&lt;/a&gt;，对这个职业的发展方向有一些思考，我上次跟winter和dh一起吃饭，也简单聊到这个话题。&lt;/p&gt;
&lt;p&gt;winter问了一个问题，如果在互联网企业跟游戏开发的企业同时进行一次针对前端开发的大裁员，对这个企业的核心价值而言，哪种影响更大？&lt;/p&gt;
&lt;p&gt;这个问题问得很有意思，在每个行业里，前端开发的侧重点是不一样的，重要性也有所不同，简单来说可以分为3个大类：互联网、企业应用、游戏，分别侧重于：交互、架构、算法。&lt;/p&gt;
&lt;p&gt;在这三个大类里，互联网方向的前端开发最为正统，算是根正苗红，所以在这个领域的人，对标准研究得最为透彻，对交互理解得最为深刻，目前前端方向的高手大多集中在这个领域。这个领域的人最关注的问题是兼容性，对一些细节的优化把握得炉火纯青。因为这个领域的业务特点，前端做的事情过于扁平，整个可发挥的余地不够，虽然高手众多，但就像很多龙挤在浅水里，常常有无用武之地的感叹。刚才玉伯这篇文章，讲述的就是这个领域中前端的困惑。&lt;/p&gt;
&lt;p&gt;企业应用方向的前端开发其实很多时候并不在意他们用的是Web还是其他类似技术，比如Flex，Silverlight等，对他们来说，即使是C/S的系统，也能够发挥出很大价值。这个领域的人最关注的问题是组件化和快速业务开发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2013-11-20-Web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2013-11-20-Web应用的组件化开发（一）/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web应用的组件化开发（一）"><a href="#Web应用的组件化开发（一）" class="headerlink" title="Web应用的组件化开发（一）"></a>Web应用的组件化开发（一）</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>#1. 为什么要做组件化？</p><p>无论前端也好，后端也好，都是整个软件体系的一部分。软件产品也是产品，它的研发过程也必然是有其目的。绝大多数软件产品是追逐利润的，在产品目标确定的情况下，成本有两个途径来优化：减少部署成本，提高开发效率。</p><p>减少部署成本的方面，业界研究得非常多，比如近几年很流行的“去IOE”，就是很典型的，从一些费用较高的高性能产品迁移到开源的易替换的产品集群，又比如使用Linux + Mono来部署.net应用，避开Windows Server的费用。</p><p>提高开发效率这方面，业界研究得更多，主要途径有两点：加快开发速度，减少变更代价。怎样才能加快开发速度呢？如果我们的开发不是重新造轮子，而是每一次做新产品都可以利用已有的东西，那就会好很多。怎样才能减少变更代价呢？如果我们能够理清模块之间的关系，合理分层，每次变更只需要修改其中某个部分，甚至不需要修改代码，仅仅是改变配置就可以，那就更好了。<br><a id="more"></a><br>我们先不看软件行业，来看一下制造行业，比如汽车制造业，他们是怎么造汽车的呢？造汽车之前，先设计，把整个汽车分解为不同部件，比如轮子，引擎，车门，座椅等等，分别生产，最后再组装，所以它的制造过程可以较快。如果一辆汽车轮胎被扎破了，需要送去维修，维修的人也没有在每个地方都修一下，而是只把轮胎拆下来修修就好了，这个轮胎要是实在坏得厉害，就干脆换上个新的，整个过程不需要很多时间。</p><p>席德梅尔出过一款很不错的游戏，叫做《文明》（Civilization），在第三代里面，有一项科技研究成功之后，会让工人工作效率加倍，这项科技的名字就叫做：可替换部件（Replacement Parts）。所以，软件行业也应当引入可替换的部件，一般称为组件。</p><p>#2. 早期的前端怎么做组件化的？</p><p>在服务端，我们有很多组件化的途径，像J2EE的Beans就是一种。组件建造完成之后，需要引入一些机制来让它们可配置，比如说，工作流引擎，规则引擎，这些引擎用配置的方式组织最基础的组件，把它们串联为业务流程。不管使用什么技术、什么语言，服务端的组件化思路基本没有本质差别，大家是有共识的，具体会有服务、流程、规则、模型等几个层次。</p><p>早期展示层基本以静态为主，服务端把界面生成好，浏览器去拿来展示，所以这个时期，有代码控制的东西几乎全在服务端，有分层的，也有不分的。如果做了分层，大致结构就是下图这样：</p><p><img src="https://raw.github.com/xufei/blog/master/assets/web-components/web1.0.png" alt="web1.0.png" title="Web 1.0"></p><p>这个图里，JSP（或者其他什么P，为了举例方便，本文中相关的服务端技术都用Java系的来表示）响应浏览器端的请求，把HTML生成出来，跟相关的JavaScript和CSS一起拿出去展示。注意这里的关键，浏览器端对界面的形态和相关业务逻辑基本都没有控制权，属于别人给什么就展示什么，想要什么要先提申请的尴尬局面。</p><p>这个时期的Web开发，前端的逻辑是基本可忽略的，所以前端组件化方式大同小异，无论是ASP还是JSP还是其他什么P，都可以自定义标签，把HTML代码和行间逻辑打包成一个标签，然后使用者直接放置在想要的地方，就可以了。</p><p>在这一时代，所谓的组件化，基本都是taglib这样的思路，把某一块界面包括它的业务逻辑一起打成一个端到端的组件，整个非常独立，直接一大块从界面到逻辑都有，而且逻辑基本上都是在服务端控制，大致结构如下图所示。</p><p><img src="https://raw.github.com/xufei/blog/master/assets/web-components/components1.0.png" alt="components in web1.0.png" title="Components in Web 1.0"></p><p>#3. SPA时代，出现了新问题</p><p>自从Web2.0逐渐流行，Web前端已经不再是纯展示了，它逐渐把以前在C/S里面做的一些东西做到B/S里面来，比如说Google和微软的在线Office，这种复杂度的Web应用如果还用传统那种方式做组件化，很显然是行不通的。</p><p>我们看看之前这种组件化的方式，本质是什么？是展现层跟业务逻辑层的隔离，后端在处理业务逻辑，前端纯展现。如果现在还这么划分，就变成了前端有界面和逻辑，后端也有逻辑，这就比较乱了。我们知道，纯逻辑的分层组件化还是比较容易的，任何逻辑如果跟展现混起来，就比较麻烦了，所以我们要把分层的点往前推，推到也能把单独的展现层剥离出来。</p><p>如下图所示，因为实际上HTML、CSS、JavaScript这些都逐渐静态化，所以不再需要把它们放在应用服务器上了，我们可以把它们放在专门的高性能静态服务器上，再进一步发展，就可以是CDN（Content Delivery Network，内容分发网络）。前端跟后端的通信，基本都是通过AJAX来，也会有一些其他的比如WebSocket之类，总之尽量少刷新了。</p><p><img src="https://raw.github.com/xufei/blog/master/assets/web-components/web2.0.png" alt="web2.0.png" title="Web 2.0"></p><p>在这张图里面可以看到，真正的前端已经形成了，它跟应用服务器之间形成了天然的隔离，所以也能够很独立地进行一些发展演进。</p><p>现在很多Web程序在往SPA（单页面程序，Single Page Application）的方向发展，这类系统通常比较类似传统的C/S程序，交互过程比较复杂，因此它的开发过程也会遇到一些困难。</p><p>那为什么大家要做SPA呢？它有很多明显的好处，最核心的优势就是高效。这个高效体现在两个方面：一是对于用户来说，这种方式做出来的东西体验较好，类似传统桌面程序，对于那些需要频繁操作的行业用户，有很大优势。二是运行的效率较高，之前集成一些菜单功能，可能要用iframe的方式引入，但每个iframe要独立引入一些公共文件，服务器文件传输的压力较大，还要初始化自己的一套内存环境，比较浪费，互相之间也不太方便通信，一般要通过postMessage之类的方式去交互。</p><p>有了SPA之后，比如一块界面，就可以是一个HTML片段，用AJAX去加载过来处理之后放到界面上。如果有逻辑的JavaScript代码，也可以用require之类的异步加载机制去运行时加载，整体的思路是比较好的。</p><p>很多人说，就以这样的需求，用jQuery再加一个异步js加载框架，不是很足够了吗？这两个东西用得好的话，也是能够解决一些问题的，但它们处理的并不是最关键的事情。在Web体系中，展现层是很天然的，因为就是HTML和CSS，如果只从文件隔离的角度，也可以做出一种划分的方式，逻辑放在单独的js文件里，html内部尽量不写js，这就是之前比较主流的前端代码划分方式。</p><p>刚才我们提到，SPA开发的过程中会遇到一些困难，这些困难是因为复杂度大为提升，导致了一些问题，有人把这些困难归结为纯界面的复杂度，比如说，控件更复杂了之类，没有这么简单。问题在于什么呢？我打个比方：我们在电脑上开两个资源管理器窗口，浏览到同一个目录，在一个目录里把某个文件删了，你猜猜另外一个里面会不会刷新？</p><p>毫无疑问，也会刷新，但是你看看你用的Web页面，如果把整个复杂系统整合成单页的，能保证对一个数据的更新就实时反馈到所有用它的地方吗？怎么做，是不是很头疼？代码组织的复杂度大为提高，所以需要做一些架构方面的提升。</p><p>#4. 架构的变更</p><p>提到架构，我们通常会往设计模式上想。在著名的《设计模式》一书中，刚开始就讲了一种典型的处理客户端开发的场景，那就是MVC。</p><p>传统的MVC理念我们并不陌生，因为有Struts，所以在Web领域也有比较经典的MVC架构，这里面的V，就负责了整个前端的渲染，而且是服务端的渲染，也就是输出HTML。如下图所示：</p><p><img src="https://raw.github.com/xufei/blog/master/assets/web-components/struts-mvc.png" alt="struts-mvc.png" title="Struts MVC"></p><p>在SPA时代，这已经不合适了，所以浏览器端形成了自己的MVC等层次，这里的V已经变成客户端渲染了，通常会使用一些客户端的HTML模版去实现，而模型和控制器，也相应地在浏览器端形成了。</p><p><img src="https://raw.github.com/xufei/blog/master/assets/web-components/spa.png" alt="struts-mvc.png" title="Single Page Application"></p><p>我们有很多这个层面的框架，比如Backbone，Knockout，Avalon，Angular等，采用了不同的设计思想，有的是MVC，有的是MVP，有的是MVVM，各有其特点。</p><p>以Angular为例，它推荐使用双向绑定去实现视图和模型的关联，这么一来，如果不同视图绑定在同一模型上，就解决了刚才所说的问题。而模型本身也通过某种机制，跟其他的逻辑模块进行协作。</p><p>这种方式就是依赖注入。依赖注入的核心理念就是通过配置来实例化所依赖的组件。使用这种模式来设计软件架构，会牺牲一些性能，在跟踪调试的便利性等方面也会有所损失，但换来的是无与伦比的松耦合和可替代性。</p><p>比如说，这些组件就可以单独测试，然后在用的时候随手引入，毫无压力。对于从事某一领域的企业来说，光这一条就足以吸引他在上面大量投入，把所有不常变动领域模型的业务代码都用此类办法维护起来，这是一种财富。</p><p>#5. MV*框架的基本原理</p><p>如果我们来设计Angular这么一个前端框架，应当如何入手呢？很显然，逻辑的控制必须使用JavaScript，一个框架，最本质的事情在于它的逻辑处理方式。</p><p>我们的界面为什么可以多姿多彩？因为有HTML和CSS，注意到这两种东西都是配置式的写法，参照后端的依赖注入，如果把这两者视为跟Spring框架中一些XML等同的配置文件，思路就豁然开朗了。</p><p>与后端不同的是，充当前端逻辑工具的JavaScript不能做入口，必须挂在HTML里才能运行，所以出现了一个怪异的状况：逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者Hybird的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。好消息是，过了这一步，逻辑层就开始大放异彩了。</p><p>从这个时候开始，框架就启动了，它要做哪些事情呢？</p><ul><li>初始化自身（bootstrap）</li><li>异步加载可能尚未引入的JavaScript代码（require）</li><li>解析定义在HTML上的规则（template parser）</li><li>实例化模型（scope）</li><li>创建模型和DOM的关联关系（binding, injection）</li></ul><p>这些是主线流程，还有一些支线，比如：</p><ul><li>解析url的search字符串，恢复状态（route）</li><li>加载HTML部件模板（template url）</li><li>部件模板和模型的关联（binding）</li></ul><p>#6. 如何做组件化</p><p>##6.1. HTML的组件化</p><p>SPA的一个典型特征就是部分加载，界面的部件化也是其中比较重要的一环。界面片段在动态请求得到之后，借助模版引擎之类的技术，经过某种转换，放置到主界面相应的地方。所以，从这个角度来看，HTML的组件化非常容易理解，那就是界面的片段化和模板化。</p><p>##6.2. JavaScript的组件化</p><p>JavaScript这个部分有好几个发展阶段。</p><ul><li>早期的共享文件，把公共功能的代码提出出来，多个页面共用</li><li>动态引用，消灭全局变量</li><li>在某些框架上进一步划分，比如Angular里面又分为provider，service，factory，controller</li></ul><p>JavaScript组件化的目标是什么呢，是清晰的职责，松耦合，便于单元测试和重复利用。这里的松耦合不仅体现在js代码之间，也体现在js跟DOM之间的关系，所以像Angular这样的框架会有directive的概念，把DOM操作限制到这类代码中，其他任何js代码不操作DOM。</p><p><img src="https://raw.github.com/xufei/blog/master/assets/web-components/componentsinspa.png" alt="componentsinspa.png" title="Components in SPA"></p><p>如上图所示，总的原则是先分层次，层内再作切分。这么做的话，不再存在之前那种端到端组件了，使用起来没有原先那么方便，但在另外很多方面比较好。</p><p>##6.3. CSS的组件化</p><p>这方面，业界也有很多探索，比如LESS，SASS，Stylus等。为什么CSS也要做组件化呢？传统的CSS是一种扁平的文本结构，变更成本较高，比如说想要把结构从松散改紧凑，需要改动很多。如果把实际使用的CSS只当作输出结果，而另外有一种适合变更的方式当作中间过程，这就好多了。比如说，我们把一些东西定义成变量，每个细节元素使用这些变量，当需要整体变更的时候，只需修改这些变量然后重新生成一下就可以了。</p><p>以上，我们讨论了大致的Web前端开发的组件化思路，后续将阐述组件化之后的协作过程和管控机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Web应用的组件化开发（一）&quot;&gt;&lt;a href=&quot;#Web应用的组件化开发（一）&quot; class=&quot;headerlink&quot; title=&quot;Web应用的组件化开发（一）&quot;&gt;&lt;/a&gt;Web应用的组件化开发（一）&lt;/h1&gt;&lt;h2 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h2&gt;&lt;p&gt;#1. 为什么要做组件化？&lt;/p&gt;
&lt;p&gt;无论前端也好，后端也好，都是整个软件体系的一部分。软件产品也是产品，它的研发过程也必然是有其目的。绝大多数软件产品是追逐利润的，在产品目标确定的情况下，成本有两个途径来优化：减少部署成本，提高开发效率。&lt;/p&gt;
&lt;p&gt;减少部署成本的方面，业界研究得非常多，比如近几年很流行的“去IOE”，就是很典型的，从一些费用较高的高性能产品迁移到开源的易替换的产品集群，又比如使用Linux + Mono来部署.net应用，避开Windows Server的费用。&lt;/p&gt;
&lt;p&gt;提高开发效率这方面，业界研究得更多，主要途径有两点：加快开发速度，减少变更代价。怎样才能加快开发速度呢？如果我们的开发不是重新造轮子，而是每一次做新产品都可以利用已有的东西，那就会好很多。怎样才能减少变更代价呢？如果我们能够理清模块之间的关系，合理分层，每次变更只需要修改其中某个部分，甚至不需要修改代码，仅仅是改变配置就可以，那就更好了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2013-07-10-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2013-07-10-从零开始编写自己的JavaScript框架（二）/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始编写自己的JavaScript框架（二）"><a href="#从零开始编写自己的JavaScript框架（二）" class="headerlink" title="从零开始编写自己的JavaScript框架（二）"></a>从零开始编写自己的JavaScript框架（二）</h1><p>#2. 数据绑定</p><p>##2.1 数据绑定的原理</p><p>数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。</p><p>在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。</p><p>先看数据到界面上的的绑定，比如：</p><pre><code>&lt;input vm-value=&quot;name&quot;/&gt;var person = {    name: &quot;Tom&quot;};</code></pre><p>如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？<br><a id="more"></a><br>从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如：</p><pre><code>var person = {    name: &quot;Tom&quot;,    setName: function(newName) {        this.name = newName;        //do something    }};</code></pre><p>这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做：</p><pre><code>var person = {    name: &quot;Tom&quot;,    gender: 5    set: function(key, value) {        this[key] = value;        //do something    }};</code></pre><p>或者合并两个方法，只判断是否传了参数：</p><pre><code>Person.prototype.name = function(value) {    if (arguments.length == 0) {        return this._name;    }    else {        this._name = value;    }}</code></pre><p>这种情况下，赋值的时候就是person.name(“Tom”)，取值的时候就是var name = person.name()了。</p><p>有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。</p><p>在C#等一些语言里，有一种东西叫做存取器，比如说：</p><pre><code>class Person{    private string name;    public string Name    {        get        {            return name;        }        set        {            name = value;        }    }}</code></pre><p>用的时候，person.Name = “Jerry”，就会调用到set里，相当于是个方法。</p><p>这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说：</p><pre><code>var person = {};// Add an accessor property to the object.Object.defineProperty(person, &quot;name&quot;, {    set: function (value) {        this._name = value;        //do something    },    get: function () {        return this._name;    },    enumerable: true,    configurable: true});</code></pre><p>赋值的时候，person.name = “Tom”，取值的时候，var name = person.name，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。</p><p>现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。</p><p>再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。</p><p>##2.2 数据绑定的实现</p><p>我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。</p><pre><code>function parseElement(element) {    for (var i=0; i&lt;element.attributes.length; i++) {        parseAttribute(element.attributes[i]);    }    for (var i=0; i&lt;element.children.length; i++) {        parseElement(element.children[i]);    }}</code></pre><p>但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？</p><p>我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。</p><p>因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。</p><pre><code>thin.define(&quot;Person&quot;, [], function() {    function Person() {        this.name = &quot;Tom&quot;;        this.age = 5;    }    Person.prototype = {        growUp: function() {            this.age++;        }    };    return Person;});</code></pre><p>模型方面都准备好了，现在来看界面：</p><pre><code>&lt;div vm-model=&quot;Person&quot;&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;&lt;/div&gt;</code></pre><p>为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。</p><p>好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？</p><p>当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样：</p><pre><code>function parseElement(element, vm) {    var model = vm;    if (element.getAttribute(&quot;vm-model&quot;)) {        model = bindModel(element.getAttribute(&quot;vm-model&quot;));    }    for (var i=0; i&lt;element.attributes.length; i++) {        parseAttribute(element, element.attributes[i], model);    }    for (var i=0; i&lt;element.children.length; i++) {        parseElement(element.children[i], model);    }}</code></pre><p>看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。</p><pre><code>function bindModel(modelName) {    thin.log(&quot;model&quot; + modelName);    var model = thin.use(modelName, true);    var instance = new model();    return instance;}</code></pre><p>现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的：</p><ul><li>init，用于绑定初始化方法</li><li>click，用于绑定点击</li><li>value，绑定变量</li><li>enable和disable，绑定可用状态</li><li>visible和invisible，绑定可见状态</li></ul><p>然后就可以实现我们parseAttribute函数了：</p><pre><code>function parseAttribute(element, attr, model) {    if (attr.name.indexOf(&quot;vm-&quot;) == 0) {        var type = attr.name.slice(3);        switch (type) {            case &quot;init&quot;:                bindInit(element, attr.value, model);                break;            case &quot;value&quot;:                bindValue(element, attr.value, model);                break;            case &quot;click&quot;:                bindClick(element, attr.value, model);                break;            case &quot;enable&quot;:                bindEnable(element, attr.value, model, true);                break;            case &quot;disable&quot;:                bindEnable(element, attr.value, model, false);                break;            case &quot;visible&quot;:                bindVisible(element, attr.value, model, true);                break;            case &quot;invisible&quot;:                bindVisible(element, attr.value, model, false);                break;            case &quot;element&quot;:                model[attr.value] = element;                break;        }    }}</code></pre><p>注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。</p><p>这么多绑定，不打算都讲，用bindValue函数来说明一下吧：</p><pre><code>function bindValue(element, key, vm) {    thin.log(&quot;binding value: &quot; + key);    vm.$watch(key, function (value, oldValue) {        element.value = value || &quot;&quot;;    });    element.onkeyup = function () {        vm[key] = element.value;    };    element.onpaste = function () {        vm[key] = element.value;    };}</code></pre><p>我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。</p><p>在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。</p><p>接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。</p><p>然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。</p><pre><code>var Binder = {    $watch: function (key, watcher) {        if (!this.$watchers[key]) {            this.$watchers[key] = {                value: this[key],                list: []            };            Object.defineProperty(this, key, {                set: function (val) {                    var oldValue = this.$watchers[key].value;                    this.$watchers[key].value = val;                    for (var i = 0; i &lt; this.$watchers[key].list.length; i++) {                        this.$watchers[key].list[i](val, oldValue);                    }                },                get: function () {                    return this.$watchers[key].value;                }            });        }        this.$watchers[key].list.push(watcher);    }};</code></pre><p>但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。</p><pre><code>function bindModel(name) {    thin.log(&quot;binding model: &quot; + name);    var model = thin.use(name, true);    var instance = new model().extend(Binder);    instance.$watchers = {};    return instance;}</code></pre><p>看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？</p><p>先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。</p><p>同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。</p><p>嗯，我们是不是可以试一下了？来写个代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Simple binding demo&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;binding&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;xu.fei@outlook.com&quot;&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/thin.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div vm-model=&quot;test.Person&quot;&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;&lt;/div&gt;&lt;div vm-model=&quot;test.Person&quot; vm-init=&quot;init&quot;&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    thin.define(&quot;test.Person&quot;, [], function () {        function Person() {            this.name = &quot;Tom&quot;;            this.age = 5;        }        Person.prototype = {            init: function () {                this.name = &quot;Jerry&quot;;                this.age = 3;            },            growUp: function () {                this.age++;            }        };        return Person;    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>或者访问这里：<a href="http://xufei.github.io/thin/demo/simple-binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/simple-binding.html</a></p><p>以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。</p><p>我们还有一个更实际一点的例子，结合了另外一个系列里面写的简单DataGrid控件，做了一个很基础的人员管理界面：<a href="http://xufei.github.io/thin/demo/binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/binding.html</a></p><p>##2.3 小结</p><p>到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。</p><p>注意Object.defineProperty仅在Chrome等浏览器中可用，IE需要9以上才比较正常。在司徒正美的avalon框架中，巧妙使用VBScript绕过这一限制，利用vbs的property和两种语言的互通，实现了低版本IE的兼容。我们这个框架的目标不是兼容，而是为了说明原理，所以感兴趣的朋友可以去看看avalon的源码。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始编写自己的JavaScript框架（二）&quot;&gt;&lt;a href=&quot;#从零开始编写自己的JavaScript框架（二）&quot; class=&quot;headerlink&quot; title=&quot;从零开始编写自己的JavaScript框架（二）&quot;&gt;&lt;/a&gt;从零开始编写自己的JavaScript框架（二）&lt;/h1&gt;&lt;p&gt;#2. 数据绑定&lt;/p&gt;
&lt;p&gt;##2.1 数据绑定的原理&lt;/p&gt;
&lt;p&gt;数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。&lt;/p&gt;
&lt;p&gt;在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。&lt;/p&gt;
&lt;p&gt;先看数据到界面上的的绑定，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input vm-value=&amp;quot;name&amp;quot;/&amp;gt;
var person = {
    name: &amp;quot;Tom&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qccs.github.io/2019/04/13/%E6%9D%82%E8%B0%88/2014-01-06-%E5%BD%B1%E5%93%8D%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%9B%A0%E7%B4%A0/"/>
    <id>https://qccs.github.io/2019/04/13/杂谈/2014-01-06-影响企业应用前端开发效率的因素/</id>
    <published>2019-04-13T07:28:25.000Z</published>
    <updated>2019-04-13T07:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="影响企业应用前端开发效率的因素"><a href="#影响企业应用前端开发效率的因素" class="headerlink" title="影响企业应用前端开发效率的因素"></a>影响企业应用前端开发效率的因素</h1><p>原先是在知乎上回答一个<a href="http://www.zhihu.com/question/22426434/answer/21433867" target="_blank" rel="noopener">问题</a>的，整理了放这里：</p><p>我们来分析一下究竟哪些因素让企业应用的前端开发这么困扰。</p><p>先看看界面部分吧。</p><p>#1. 命令式还是声明式<br>毫无疑问，就写界面来说，声明式的代码编写效率远高于命令式：</p><pre><code>&lt;Panel title=&quot;Test&quot;&gt;  &lt;Button label=&quot;Click me&quot;/&gt;&lt;/Panel&gt;Panel p = new Panel();p.title = &quot;Test&quot;;Button b = new Button();b.label = &quot;Click me&quot;;p.add(b);</code></pre><p>第一种容易写，容易理解。<br><a id="more"></a></p><p>#2. 控件标签集<br>不管你的软件面向什么行业，至少都要一些控件，或者是基本的表单输入，或者是复杂的比如树形表格，里面还可以跨行跨列渲染的。</p><p>如果我们有一套映射到控件的标签，那么写代码是肯定会简单很多的，比如说，在HTML里面没有原生的Panel，那么，刚才第一段代码可能就要变成：</p><pre><code>&lt;div class=&quot;panel panel-default&quot;&gt;  &lt;div class=&quot;panel-heading&quot;&gt;    &lt;h3 class=&quot;panel-title&quot;&gt;Simple HTML Loader&lt;/h3&gt;  &lt;/div&gt;  &lt;div class=&quot;panel-body&quot;&gt;    &lt;button&gt;Click me&lt;/button&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>我们为了使得界面代码编写更高效，毫无疑问会倾向于把这么一堆东西简化成一个Panel标签，这样就会逐步建立一套面向自己行业的标签集。</p><p>#3. 带逻辑的控件<br>刚才这个例子为什么简单呢，因为它只是一个普通容器，静态的，不带逻辑，所以即使你用什么静态模板也能解决问题。如果复杂一点，是一个TabNavigator，就要考虑切换的事件，再复杂一些是个树形表格，那就更麻烦了。</p><p>我们来看jQuery提供的插件方式实现TabNaviator：</p><pre><code>&lt;div id=&quot;tabs&quot;&gt;  &lt;ul&gt;    &lt;li&gt;&lt;a href=&quot;#tabs-1&quot;&gt;Nunc tincidunt&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#tabs-2&quot;&gt;Proin dolor&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#tabs-3&quot;&gt;Aenean lacinia&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;div id=&quot;tabs-1&quot;&gt;  &lt;/div&gt;  &lt;div id=&quot;tabs-2&quot;&gt;  &lt;/div&gt;  &lt;div id=&quot;tabs-3&quot;&gt;  &lt;/div&gt;&lt;/div&gt;  &lt;script&gt;  $(function() {    $( &quot;#tabs&quot; ).tabs();  });  &lt;/script&gt;</code></pre><p>从我个人的角度看，这种代码很愚蠢。蠢在何处呢？HTML这类声明式的界面描述语言，写起来本来应当直观一些的，但是被这么一搞，又往命令式的方向去了。而且两种东西混杂，声明和渲染居然分了两处，又增加了维护的成本。</p><p>难道就没有别的办法来解决这个问题吗？</p><p>我们看看其他语言和框架，比如Flex和Silverlight。</p><pre><code>&lt;mx:TabNavigator id=&quot;tn&quot;  width=&quot;100%&quot; height=&quot;100%&quot;&gt;  &lt;!-- Define each panel using a VBox container. --&gt;  &lt;mx:VBox label=&quot;Panel 1&quot;&gt;    &lt;mx:Label text=&quot;TabNavigator container panel 1&quot;/&gt;  &lt;/mx:VBox&gt;  &lt;mx:VBox label=&quot;Panel 2&quot;&gt;    &lt;mx:Label text=&quot;TabNavigator container panel 2&quot;/&gt;  &lt;/mx:VBox&gt;  &lt;mx:VBox label=&quot;Panel 3&quot;&gt;    &lt;mx:Label text=&quot;TabNavigator container panel 3&quot;/&gt;  &lt;/mx:VBox&gt;&lt;/mx:TabNavigator&gt;</code></pre><p>上面这段是Flex里面的TabNavigator，在这个链接底部有运行结果：TabNavigator</p><p>为什么它可以看不到逻辑的代码，但是又确实能有动作呢，因为它的实现类是mx.containers.TabNavigator，在这个代码里，可以自己手动去处理一切内部实现，但是暴露给业务开发人员的就是这么简单的标签。</p><p>我们看看在HTML和JS这个体系里用什么办法去解决。不要提JSF这类服务端技术，因为它的思路也是不好的，展示代码的生成和渲染都不在一个地方，会有很多问题。</p><p>#4. Polymer与Angular</p><p>早期IE里有HTC，也就是HTML Components，因为别的浏览器厂商不喜欢，所以快要消亡了。在W3C新的HTML规范里，有一个Web Components，参见这里：Introduction to Web Components</p><p>这个东西跟HTC的思想本出同源，它引入了Custom Elements和Shadow DOM这两个概念，也就是说，我可以自定义一个标签，然后在内部随便怎么折腾，用这个标签的人可以很方便。</p><p>很美好，是不是，但是只适用于比较新的浏览器，基于这个理念架构的框架Polymer的目标也只是支持一些比较新的浏览器。Polymer</p><p>那么怎么办呢？我们还有Angular，它也可以自定义标签，然后用directive的方式写内部实现。</p><pre><code>&lt;tabs&gt;  &lt;pane title=&quot;Localization&quot;&gt;  &lt;/pane&gt;  &lt;pane title=&quot;Pluralization&quot;&gt;  &lt;/pane&gt;&lt;/tabs&gt;&lt;script id=&quot;components.js&quot;&gt;  angular.module(&apos;components&apos;, [])    .directive(&apos;tabs&apos;, function() {      return {        restrict: &apos;E&apos;,        transclude: true,        scope: {},        controller: function($scope, $element) {          var panes = $scope.panes = [];          $scope.select = function(pane) {            angular.forEach(panes, function(pane) {              pane.selected = false;            });            pane.selected = true;          }          this.addPane = function(pane) {            if (panes.length == 0) $scope.select(pane);            panes.push(pane);          }        },        template:          &apos;&lt;div class=&quot;tabbable&quot;&gt;&apos; +            &apos;&lt;ul class=&quot;nav nav-tabs&quot;&gt;&apos; +              &apos;&lt;li ng-repeat=&quot;pane in panes&quot; ng-class=&quot;{active:pane.selected}&quot;&gt;&apos;+                &apos;&lt;a href=&quot;&quot; ng-click=&quot;select(pane)&quot;&gt;{{pane.title}}&lt;/a&gt;&apos; +              &apos;&lt;/li&gt;&apos; +            &apos;&lt;/ul&gt;&apos; +            &apos;&lt;div class=&quot;tab-content&quot; ng-transclude&gt;&lt;/div&gt;&apos; +          &apos;&lt;/div&gt;&apos;,        replace: true      };    })    .directive(&apos;pane&apos;, function() {      return {        require: &apos;^tabs&apos;,        restrict: &apos;E&apos;,        transclude: true,        scope: { title: &apos;@&apos; },        link: function(scope, element, attrs, tabsCtrl) {          tabsCtrl.addPane(scope);        },        template:          &apos;&lt;div class=&quot;tab-pane&quot; ng-class=&quot;{active: selected}&quot; ng-transclude&gt;&apos; +          &apos;&lt;/div&gt;&apos;,        replace: true      };    })&lt;/script&gt;</code></pre><p>这么一来，也就有些接近我们的目标了，看到现在，我们还记得目标是什么吗？是尽可能精简的面向领域的容器和控件标签集，有了这个，写界面代码才能更简单。</p><p>#5. 为什么HTML默认标签集这么小</p><p>事情结束了吗？没有呢。我们的HTML体系为什么标签集这么小？因为他要解决的是通用领域的东西，怎样才能通用呢？要的是尽可能无歧义。</p><p>怎样的东西会没有歧义？那就是它的含义尽可能少，比如说单行文本输入框，总没人对它有歧义吧，它无非就是可以设置最大最小长度，是否只读，是否禁用，最多通过某种规则来限制输入字符，最多最多，也就这些可做的了，大家都认同。</p><p>Button就不同了，一开始他是</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;Click&quot;/&gt;</code></pre><p>后来大家想要各种各样的button，于是开放了</p><pre><code>&lt;button&gt;&lt;/button&gt;</code></pre><p>这样的标签，可以在里面写各种HTML，我记得当时很多人在中间加上下和左右两层marquee，简直玩坏了。</p><p>现在HTML里面又有了数字输入，日期时间输入这样的东西，数字的没什么疑问，就是最大最小值，步进值等等，日期时间这个就复杂了，它怎么做，都有人不满意。有人要日期排左边，有人要时间排上面，有人只要年和月，有人只要分和秒。有人要点空白表示选中，有人要双击日期表示选中，还有人想用农历、波斯历、尼泊尔历，简直没完了，还不如不做，谁要谁自己做……</p><p>所以，面向各领域的人们，自己动手，丰衣足食吧。</p><p>#6. 界面修饰</p><p>好了，控件集的问题解决了，我们来看看界面的修饰。</p><p>你们发现没有，不管用什么非HTML的标签体系，可能写代码会很快，但是有时候要修饰界面，比如只是调整一下所有容器的边距，某些按钮的圆角之类，就会生不如死。</p><p>这时候你会发现，HTML里面的CSS真是神器，什么都能干，而且是面向切面的，只要你的HTML结构是良好的，完全不需要调整这个层面的代码。为什么其他体系的CSS没有这么强呢？比如说Flex也可以写CSS，QT也可以写CSS。</p><p>因为CSS的部分实在是太复杂了，复杂到整个浏览器里面绝大部分的代码都在处理这方面的东西，像Google的Chrome团队有1000多人，别的体系没法有这么大投入，只能看着羡慕。</p><p>上次看到一个问题，近30年来软件开发体系有哪些本质的改进？我觉得CSS真的可以入选，这是一个把结构和展现完全分离的典范，并且实现得很好。</p><p>我们的前端开发一般都是面向某个领域的，不管什么领域，CSS方向都可以有一个很独立的规划，因为它可以不影响界面的结构。所以这个方面，其实不太会对前端开发造成太多压力，压力只集中在维护CSS的人群身上。</p><p>好了，上面扯了那么多，其实到现在还在界面的层次，一直没有去谈到真正的逻辑。那么，最让我们困扰的部分是哪里呢？</p><p>#7. 模块化和加载</p><p>Web前端开发有个最苦闷的事情就是选型，因为HTML这个体系很开放，提供的默认能力又不是很足够，如果要做复杂交互的东西，会需要很多额外的工作。有各种框架从各种角度来解决问题，但怎么把这些东西整合到正好符合自己的需要，是一个很花精力的事情，很多时候恨不得自己把全部轮子都造一遍。</p><p>真正的开发工作中，跨浏览器，踩各种坑应该是最烦闷的事，其他部分，如果有做好自己领域里标签的定义，或者不用标签用其他方式，应该不算特别困难。<br>有人说JavaScript语言本身比较松散，所以写业务逻辑比较头疼，这不算大问题。基于B/S的开发，有一个大坑是你在运行的时候要先把代码加载过来，然后才能跑。你看那些C/S软件，有这困扰吗？再看看后端程序员，谁还要关心自己的代码执行之前要做的事情？</p><p>所以后端程序员写前端代码，都情不自禁地会引入一大堆库。我们形象一点来描述一下这个过程：</p><p>嗯，大家都用jQuery，我也引入，抄了两段代码发现真不错。咦，我要个树控件，网上逛了一圈，拿了个zTree回来。再埋头苦干半个小时，缺数据表格控件，于是过了一会，jQuery UI被整体引入了。再埋头苦干，上网乱点了点，浏览器跳出个广告，一看叫做Kendo UI，看看发现不错，引进来再说，用里面的某个控件。又过了一阵，听说最近Angular很火啊，看了看例子，表单功能怎么那么强，我也要用！捣鼓捣鼓又加进去了。项目里又要用图表库，看了半天眼睛都花了，百度的ECharts不错哦，引进来。哎呀我界面怎么那么丑，人家的怎么那么清爽，查看源码，一看，Bootstrap，去官网一看，真乃神器，不用简直对不起自己。</p><p>没多久之后，这个界面已经融合了各种主流框架，代码写法五花八门，依赖了几M的JS库，更要命的是里面某些JS有冲突，某些样式也互相覆盖，快疯了。</p><p>这里有哪些问题呢？</p><ul><li>JS代码要先加载到界面才能执行，而这么几M的代码加载过来就要好久了，然后每个框架还要把自己初始化，又耗不少时间，半分钟之后自己写的JS才开始执行，用户等得都快怀孕了。</li><li>不管是JS还是CSS，都应当控制基准的代码，这件事的主要意义是避免冲突，因为整个体系都比较松散，如果不加控制，就会造成冲突。即使在服务端写Java，也有类签名一致性之类的问题，所以这个部分必须要重视。</li></ul><p>刚才这两点，第二点暂时不是我们要探讨的范围，第一点，引出的话题就是异步加载，这是一个可以展开说很多的话题，也不再说了。异步加载和缓存是面对复杂场景必做的优化措施。</p><p>但是这个里面规范就有好几种，具体实现方式就更多了。ES6的module也许可以解决这个问题。harmony:modules [ES Wiki]</p><p>#8. 逻辑的分层</p><p>网站型和应用型Web程序对分层的需求是不一样的。网站型的逻辑大部分都在处理UI，而应用型可能有很多业务逻辑，这部分需要更好的组织，以便复用，或者即使我们的目标不包括复用，为了这个代码的可维护性，也需要有比较好的组织方式。</p><p>本质上这些组织方式与传统的客户端软件开发没什么不同，主要要做的无非就是UI层的隔离，或者模板化，或者别的什么方式。纯逻辑的代码大家都会写，但这个逻辑怎么跟界面产生关系，这是个问题。</p><p>有些框架通过在HTML元素上设置额外属性，然后启动的时候读取，在框架内部做一些相关的事情，比如Angular、Avalon和Knockout。有的框架在视图层中让开发人员手动去处理界面，就像未引入框架的那样，比如Backbone，两者是各有利弊的。</p><p>前面这种，一般功能是会很强大，但是它自身所做的东西必须足够多，多得帮你做掉绝大部分本来该自己做的事，你才会特别爽。所以，用这类框架来做表单型应用的时候，是会非常舒服的，因为这些需求他做框架的时候能预见，所以比如校验、联动、存取之类的都会处理掉。假如你要做一个绘图类应用，这就麻烦了，不管你是用Canvas还是SVG，它所能帮到的都不多。这时候，后面这类可能反而适合一些。</p><p>这些数据分层框架的原理是什么呢？是要做一层表单与数据的对应关系，所以他要检测数据的变动，比如一个Object，它某个值变更了，要去把对应的界面更改之类。这里面也有很多的坑，可以一步一步踩过来。。。</p><p>到现在，我大致可以回答你的问题，什么情况下前端开发会比较轻松呢？</p><ul><li>针对自己领域的界面标签库比较完善，或者易于扩展</li><li>样式容易调整，并且独立于界面元素</li><li>逻辑模块化，层次分明，在某种统一规范上存在大量可用库<br>咦，我这三点好像在说微软的WPF体系吗？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;影响企业应用前端开发效率的因素&quot;&gt;&lt;a href=&quot;#影响企业应用前端开发效率的因素&quot; class=&quot;headerlink&quot; title=&quot;影响企业应用前端开发效率的因素&quot;&gt;&lt;/a&gt;影响企业应用前端开发效率的因素&lt;/h1&gt;&lt;p&gt;原先是在知乎上回答一个&lt;a href=&quot;http://www.zhihu.com/question/22426434/answer/21433867&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题&lt;/a&gt;的，整理了放这里：&lt;/p&gt;
&lt;p&gt;我们来分析一下究竟哪些因素让企业应用的前端开发这么困扰。&lt;/p&gt;
&lt;p&gt;先看看界面部分吧。&lt;/p&gt;
&lt;p&gt;#1. 命令式还是声明式&lt;br&gt;毫无疑问，就写界面来说，声明式的代码编写效率远高于命令式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Panel title=&amp;quot;Test&amp;quot;&amp;gt;
  &amp;lt;Button label=&amp;quot;Click me&amp;quot;/&amp;gt;
&amp;lt;/Panel&amp;gt;

Panel p = new Panel();
p.title = &amp;quot;Test&amp;quot;;
Button b = new Button();
b.label = &amp;quot;Click me&amp;quot;;
p.add(b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一种容易写，容易理解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
